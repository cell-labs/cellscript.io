## package blockchain

Structures of a [CKB Cell](https://docs.nervos.org/docs/tech-explanation/cell).

Since everything is a collection of bytes, these structures just a wrapper of byte slice.

### Types

#### type [Script](https://docs.nervos.org/docs/tech-explanation/script)

```
type Script table {
    inner []byte
}

func (s *Script) TotalSize() uint64 
func (s *Script) FieldCount() uint64
func (s *Script) Len() uint64
func (s *Script) IsEmpty() bool
func (s *Script) CountExtraFields()
func (s *Script) HasExtraFields()
func (s *Script) CodeHash() Byte32
func (s *Script) HashType() Byte
func (s *Script) Args() Bytes
```

[hash_type](https://docs.nervos.org/docs/tech-explanation/hash-type)

#### type Byte32

```
type Bytes table {
	inner []byte
}

func (s *Bytes) TotalSize() uint64
func (s *Bytes) Len() uint64
func (s *Bytes) IsEmpty() bool
func (s *Bytes) Get(index uint64) Byte
func (s *Bytes) RawData() []byte
```

## package ckb

Developed on top of [ckb-c-stdlib](https://github.com/nervosnetwork/ckb-c-stdlib).

### loadScript

```
func loadScript() blockchain.Script
```

Load current running script, which could be a Lock Script or a Type Script. You can check it based on the [hash_type](#hash_type) field.

### verifyScript

```
func verifyScript(script blockchain.Script, compatible bool) bool
```

Verify the Script is valid or not. Check Script byte size, filed count, and so on.

## binary package

```
func ReadUint32FromSlice(slice []byte, order ByteOrder) uint32
```

Read an uint32 from a byte slice.

```
func ReadUint64FromSlice(slice []byte, order ByteOrder) uint64
```

Read an uint64 from a byte slice.

```
func ReadUint128FromSlice(slice []byte, order ByteOrder) uint128
```

Read an uint128 from a byte slice.

```
func ReadUint256FromSlice(slice []byte, order ByteOrder) uint256
```

Read an uint256 from a byte slice.
