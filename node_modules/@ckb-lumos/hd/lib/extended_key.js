"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExtendedPublicKey = exports.ExtendedPrivateKey = exports.AddressType = exports.AccountExtendedPublicKey = void 0;

var _keychain = _interopRequireDefault(require("./keychain"));

var _key = _interopRequireWildcard(require("./key"));

var _base = require("@ckb-lumos/base");

var _helper = require("./helper");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let AddressType;
exports.AddressType = AddressType;

(function (AddressType) {
  AddressType[AddressType["Receiving"] = 0] = "Receiving";
  AddressType[AddressType["Change"] = 1] = "Change";
})(AddressType || (exports.AddressType = AddressType = {}));

class ExtendedPublicKey {
  constructor(publicKey, chainCode) {
    (0, _helper.assertPublicKey)(publicKey);
    (0, _helper.assertChainCode)(chainCode);
    this.publicKey = publicKey;
    this.chainCode = chainCode;
  }

  serialize() {
    return this.publicKey + this.chainCode.slice(2);
  }

  static parse(serialized) {
    _base.utils.assertHexString("serialized", serialized);

    return new ExtendedPublicKey(serialized.slice(0, 68), "0x" + serialized.slice(68));
  }

} // Extended public key of the BIP44 path down to account level,
// which is `m/44'/309'/0'`. This key will be persisted to wallet
// and used to derive receiving/change addresses.


exports.ExtendedPublicKey = ExtendedPublicKey;

class AccountExtendedPublicKey extends ExtendedPublicKey {
  static ckbAccountPath = `m/44'/309'/0'`;

  static parse(serialized) {
    _base.utils.assertHexString("serialized", serialized);

    return new AccountExtendedPublicKey(serialized.slice(0, 68), "0x" + serialized.slice(68));
  }

  publicKeyInfo(type, index) {
    const publicKey = this.getPublicKey(type, index);

    const blake160 = _key.default.publicKeyToBlake160(publicKey);

    return {
      publicKey,
      blake160,
      path: AccountExtendedPublicKey.pathFor(type, index)
    };
  }

  static pathForReceiving(index) {
    return AccountExtendedPublicKey.pathFor(AddressType.Receiving, index);
  }

  static pathForChange(index) {
    return AccountExtendedPublicKey.pathFor(AddressType.Change, index);
  }

  static pathFor(type, index) {
    return `${AccountExtendedPublicKey.ckbAccountPath}/${type}/${index}`;
  }

  getPublicKey(type = AddressType.Receiving, index) {
    const keychain = _keychain.default.fromPublicKey(Buffer.from(this.publicKey.slice(2), "hex"), Buffer.from(this.chainCode.slice(2), "hex"), AccountExtendedPublicKey.ckbAccountPath).deriveChild(type, false).deriveChild(index, false);

    return "0x" + keychain.publicKey.toString("hex");
  }

}

exports.AccountExtendedPublicKey = AccountExtendedPublicKey;

class ExtendedPrivateKey {
  constructor(privateKey, chainCode) {
    (0, _helper.assertPrivateKey)(privateKey);
    (0, _helper.assertChainCode)(chainCode);
    this.privateKey = privateKey;
    this.chainCode = chainCode;
  }

  serialize() {
    return this.privateKey + this.chainCode.slice(2);
  }

  toExtendedPublicKey() {
    const publicKey = (0, _key.privateToPublic)(this.privateKey);
    return new ExtendedPublicKey(publicKey, this.chainCode);
  }

  toAccountExtendedPublicKey() {
    const masterKeychain = new _keychain.default(Buffer.from(this.privateKey.slice(2), "hex"), Buffer.from(this.chainCode.slice(2), "hex"));
    const accountKeychain = masterKeychain.derivePath(AccountExtendedPublicKey.ckbAccountPath);
    return new AccountExtendedPublicKey("0x" + accountKeychain.publicKey.toString("hex"), "0x" + accountKeychain.chainCode.toString("hex"));
  }

  static fromSeed(seed) {
    const keychain = _keychain.default.fromSeed(seed);

    return new ExtendedPrivateKey("0x" + keychain.privateKey.toString("hex"), "0x" + keychain.chainCode.toString("hex"));
  }

  privateKeyInfo(type, index) {
    const path = AccountExtendedPublicKey.pathFor(type, index);
    return this.privateKeyInfoByPath(path);
  }

  privateKeyInfoByPath(path) {
    const keychain = new _keychain.default(Buffer.from(this.privateKey.slice(2), "hex"), Buffer.from(this.chainCode.slice(2), "hex")).derivePath(path);
    return this.privateKeyInfoFromKeychain(keychain, path);
  }

  privateKeyInfoFromKeychain(keychain, path) {
    return {
      privateKey: "0x" + keychain.privateKey.toString("hex"),
      publicKey: "0x" + keychain.publicKey.toString("hex"),
      path: path
    };
  }

  static parse(serialized) {
    _base.utils.assertHexString("serialized", serialized);

    return new ExtendedPrivateKey(serialized.slice(0, 66), "0x" + serialized.slice(66));
  }

}

exports.ExtendedPrivateKey = ExtendedPrivateKey;
//# sourceMappingURL=extended_key.js.map