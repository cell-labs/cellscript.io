{"version":3,"file":"key.js","names":["ec","EC","signRecoverable","message","privateKey","utils","assertHexString","assertPrivateKey","key","keyFromPrivate","slice","r","s","recoveryParam","sign","canonical","Error","fmtR","toString","padStart","fmtS","fmtRecoverableParam","recoverFromSignature","signature","msgBuffer","Buffer","from","sigBuffer","point","recoverPubKey","publicKey","encode","toLowerCase","privateToPublic","pkBuffer","length","publickey","getPublic","publicKeyToBlake160","assertPublicKey","blake160","CKBHasher","update","digestHex","privateKeyToBlake160"],"sources":["../src/key.ts"],"sourcesContent":["import { HexString, utils } from \"@ckb-lumos/base\";\nimport { ec as EC, SignatureInput } from \"elliptic\";\nimport { assertPrivateKey, assertPublicKey } from \"./helper\";\n\nconst ec = new EC(\"secp256k1\");\n\nexport function signRecoverable(\n  message: HexString,\n  privateKey: HexString\n): HexString {\n  utils.assertHexString(\"message\", message);\n  assertPrivateKey(privateKey);\n\n  const key = ec.keyFromPrivate(privateKey.slice(2));\n  const { r, s, recoveryParam } = key.sign(message.slice(2), {\n    canonical: true,\n  });\n  if (recoveryParam === null) {\n    throw new Error(\"Sign message failed!\");\n  }\n  const fmtR = r.toString(16).padStart(64, \"0\");\n  const fmtS = s.toString(16).padStart(64, \"0\");\n  const fmtRecoverableParam = recoveryParam.toString(16).padStart(2, \"0\");\n  return \"0x\" + fmtR + fmtS + fmtRecoverableParam;\n}\n\nexport function recoverFromSignature(\n  message: HexString,\n  signature: HexString\n): HexString {\n  utils.assertHexString(\"message\", message);\n  utils.assertHexString(\"signature\", signature);\n\n  const msgBuffer = Buffer.from(message.slice(2), \"hex\");\n  const sigBuffer = Buffer.from(signature.slice(2), \"hex\");\n\n  const sign: SignatureInput = {\n    r: sigBuffer.slice(0, 32),\n    s: sigBuffer.slice(32, 64),\n    recoveryParam: sigBuffer[64],\n  };\n\n  const point = ec.recoverPubKey(msgBuffer, sign, sign.recoveryParam!);\n  const publicKey = \"0x\" + point.encode(\"hex\", true).toLowerCase();\n  return publicKey;\n}\n\nexport function privateToPublic(privateKey: Buffer): Buffer;\nexport function privateToPublic(privateKey: HexString): HexString;\n\nexport function privateToPublic(\n  privateKey: Buffer | HexString\n): Buffer | HexString {\n  let pkBuffer = privateKey;\n  if (typeof privateKey === \"string\") {\n    assertPrivateKey(privateKey);\n    pkBuffer = Buffer.from(privateKey.slice(2), \"hex\");\n  }\n  if (pkBuffer.length !== 32) {\n    throw new Error(\"Private key must be 32 bytes!\");\n  }\n\n  const publickey = ec.keyFromPrivate(pkBuffer).getPublic(true, \"hex\");\n  if (typeof privateKey === \"string\") {\n    return \"0x\" + publickey;\n  }\n  return Buffer.from(publickey, \"hex\");\n}\n\nexport function publicKeyToBlake160(publicKey: HexString): HexString {\n  assertPublicKey(publicKey);\n\n  const blake160: string = new utils.CKBHasher()\n    .update(publicKey)\n    .digestHex()\n    .slice(0, 42);\n\n  return blake160;\n}\n\nexport function privateKeyToBlake160(privateKey: HexString): HexString {\n  const publicKey: HexString = privateToPublic(privateKey);\n  return publicKeyToBlake160(publicKey);\n}\n\nexport default {\n  signRecoverable,\n  recoverFromSignature,\n  privateToPublic,\n  publicKeyToBlake160,\n  privateKeyToBlake160,\n};\n"],"mappings":"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"}