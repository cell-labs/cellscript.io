"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _crypto = _interopRequireDefault(require("crypto"));

var _elliptic = require("elliptic");

var _bn = _interopRequireDefault(require("bn.js"));

var _key = require("./key");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ec = new _elliptic.ec("secp256k1");
const EMPTY_BUFFER = Buffer.from(""); // BIP32 Keychain. Not a full implementation.

class Keychain {
  privateKey = EMPTY_BUFFER;
  publicKey = EMPTY_BUFFER;
  chainCode = EMPTY_BUFFER;
  index = 0;
  depth = 0;
  identifier = EMPTY_BUFFER;
  fingerprint = 0;
  parentFingerprint = 0;

  constructor(privateKey, chainCode) {
    this.privateKey = privateKey;
    this.chainCode = chainCode;

    if (!this.isNeutered()) {
      this.publicKey = (0, _key.privateToPublic)(this.privateKey);
    }
  }

  calculateFingerprint() {
    this.identifier = this.hash160(this.publicKey);
    this.fingerprint = this.identifier.slice(0, 4).readUInt32BE(0);
  }

  static fromSeed(seed) {
    const i = _crypto.default.createHmac("sha512", Buffer.from("Bitcoin seed", "utf8")).update(seed).digest();

    const keychain = new Keychain(i.slice(0, 32), i.slice(32));
    keychain.calculateFingerprint();
    return keychain;
  } // Create a child keychain with extended public key and path.
  // Children of this keychain should not have any hardened paths.


  static fromPublicKey(publicKey, chainCode, path) {
    const keychain = new Keychain(EMPTY_BUFFER, chainCode);
    keychain.publicKey = publicKey;
    keychain.calculateFingerprint();
    const pathComponents = path.split("/");
    keychain.depth = pathComponents.length - 1;
    keychain.index = parseInt(pathComponents[pathComponents.length - 1], 10);
    return keychain;
  }

  deriveChild(index, hardened) {
    let data;
    const indexBuffer = Buffer.allocUnsafe(4);

    if (hardened) {
      const pk = Buffer.concat([Buffer.alloc(1, 0), this.privateKey]);
      indexBuffer.writeUInt32BE(index + 0x80000000, 0);
      data = Buffer.concat([pk, indexBuffer]);
    } else {
      indexBuffer.writeUInt32BE(index, 0);
      data = Buffer.concat([this.publicKey, indexBuffer]);
    }

    const i = _crypto.default.createHmac("sha512", this.chainCode).update(data).digest();

    const il = i.slice(0, 32);
    const ir = i.slice(32);
    let child;

    if (this.isNeutered()) {
      child = new Keychain(EMPTY_BUFFER, ir);
      child.publicKey = Keychain.publicKeyAdd(this.publicKey, il);
      child.calculateFingerprint();
    } else {
      const privateKey = Keychain.privateKeyAdd(this.privateKey, il);
      child = new Keychain(privateKey, ir);
      child.calculateFingerprint();
    }

    child.index = index;
    child.depth = this.depth + 1;
    child.parentFingerprint = this.fingerprint;
    return child;
  }

  derivePath(path) {
    const master = ["m", `/`, ""];

    if (master.includes(path)) {
      return this;
    }

    let bip32 = this;
    let entries = path.split("/");

    if (entries[0] === "m") {
      entries = entries.slice(1);
    }

    entries.forEach(c => {
      const childIndex = parseInt(c, 10);
      const hardened = c.length > 1 && c[c.length - 1] === "'";
      bip32 = bip32.deriveChild(childIndex, hardened);
    });
    return bip32;
  }

  isNeutered() {
    return this.privateKey === EMPTY_BUFFER;
  }

  hash160(data) {
    const sha256 = _crypto.default.createHash("sha256").update(data).digest();

    return _crypto.default.createHash("ripemd160").update(sha256).digest();
  }

  static privateKeyAdd(privateKey, factor) {
    const result = new _bn.default(factor);
    result.iadd(new _bn.default(privateKey));

    if (result.cmp(ec.curve.n) >= 0) {
      result.isub(ec.curve.n);
    }

    return result.toArrayLike(Buffer, "be", 32);
  }

  static publicKeyAdd(publicKey, factor) {
    const x = new _bn.default(publicKey.slice(1)).toRed(ec.curve.red);
    let y = x.redSqr().redIMul(x).redIAdd(ec.curve.b).redSqrt();

    if (publicKey[0] === 0x03 !== y.isOdd()) {
      y = y.redNeg();
    }

    const point = ec.curve.g.mul(new _bn.default(factor)).add({
      x,
      y
    });
    return Buffer.from(point.encode(true, true));
  }

}

exports.default = Keychain;
//# sourceMappingURL=keychain.js.map