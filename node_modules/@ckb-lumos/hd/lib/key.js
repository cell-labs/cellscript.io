"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.privateKeyToBlake160 = privateKeyToBlake160;
exports.privateToPublic = privateToPublic;
exports.publicKeyToBlake160 = publicKeyToBlake160;
exports.recoverFromSignature = recoverFromSignature;
exports.signRecoverable = signRecoverable;

var _base = require("@ckb-lumos/base");

var _elliptic = require("elliptic");

var _helper = require("./helper");

const ec = new _elliptic.ec("secp256k1");

function signRecoverable(message, privateKey) {
  _base.utils.assertHexString("message", message);

  (0, _helper.assertPrivateKey)(privateKey);
  const key = ec.keyFromPrivate(privateKey.slice(2));
  const {
    r,
    s,
    recoveryParam
  } = key.sign(message.slice(2), {
    canonical: true
  });

  if (recoveryParam === null) {
    throw new Error("Sign message failed!");
  }

  const fmtR = r.toString(16).padStart(64, "0");
  const fmtS = s.toString(16).padStart(64, "0");
  const fmtRecoverableParam = recoveryParam.toString(16).padStart(2, "0");
  return "0x" + fmtR + fmtS + fmtRecoverableParam;
}

function recoverFromSignature(message, signature) {
  _base.utils.assertHexString("message", message);

  _base.utils.assertHexString("signature", signature);

  const msgBuffer = Buffer.from(message.slice(2), "hex");
  const sigBuffer = Buffer.from(signature.slice(2), "hex");
  const sign = {
    r: sigBuffer.slice(0, 32),
    s: sigBuffer.slice(32, 64),
    recoveryParam: sigBuffer[64]
  };
  const point = ec.recoverPubKey(msgBuffer, sign, sign.recoveryParam);
  const publicKey = "0x" + point.encode("hex", true).toLowerCase();
  return publicKey;
}

function privateToPublic(privateKey) {
  let pkBuffer = privateKey;

  if (typeof privateKey === "string") {
    (0, _helper.assertPrivateKey)(privateKey);
    pkBuffer = Buffer.from(privateKey.slice(2), "hex");
  }

  if (pkBuffer.length !== 32) {
    throw new Error("Private key must be 32 bytes!");
  }

  const publickey = ec.keyFromPrivate(pkBuffer).getPublic(true, "hex");

  if (typeof privateKey === "string") {
    return "0x" + publickey;
  }

  return Buffer.from(publickey, "hex");
}

function publicKeyToBlake160(publicKey) {
  (0, _helper.assertPublicKey)(publicKey);
  const blake160 = new _base.utils.CKBHasher().update(publicKey).digestHex().slice(0, 42);
  return blake160;
}

function privateKeyToBlake160(privateKey) {
  const publicKey = privateToPublic(privateKey);
  return publicKeyToBlake160(publicKey);
}

var _default = {
  signRecoverable,
  recoverFromSignature,
  privateToPublic,
  publicKeyToBlake160,
  privateKeyToBlake160
};
exports.default = _default;
//# sourceMappingURL=key.js.map