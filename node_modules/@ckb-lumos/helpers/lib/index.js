"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addressToScript = exports.TransactionSkeleton = void 0;
exports.createTransactionFromSkeleton = createTransactionFromSkeleton;
exports.encodeToAddress = encodeToAddress;
exports.encodeToConfigAddress = encodeToConfigAddress;
exports.generateAddress = generateAddress;
exports.generateSecp256k1Blake160Address = generateSecp256k1Blake160Address;
exports.generateSecp256k1Blake160MultisigAddress = generateSecp256k1Blake160MultisigAddress;
exports.locateCellDep = locateCellDep;
exports.minimalCellCapacity = minimalCellCapacity;
exports.minimalCellCapacityCompatible = minimalCellCapacityCompatible;
exports.minimalScriptCapacity = minimalScriptCapacity;
exports.minimalScriptCapacityCompatible = minimalScriptCapacityCompatible;
exports.objectToTransactionSkeleton = objectToTransactionSkeleton;
exports.parseAddress = parseAddress;
exports.scriptToAddress = void 0;
exports.sealTransaction = sealTransaction;
exports.transactionSkeletonToObject = transactionSkeletonToObject;

var _codec = require("@ckb-lumos/codec");

var _base = require("@ckb-lumos/base");

var _bech = require("bech32");

var _immutable = require("immutable");

var _configManager = require("@ckb-lumos/config-manager");

var _bi = require("@ckb-lumos/bi");

var _addressToScript = require("./address-to-script");

var _utils = require("./utils");

var _toolkit = require("@ckb-lumos/toolkit");

const {
  bytify,
  hexify
} = _codec.bytes;
const BECH32_LIMIT = 1023;

function minimalScriptCapacity(script, {
  validate = true
} = {}) {
  const result = minimalScriptCapacityCompatible(script, {
    validate
  });
  return BigInt(result.toString());
}

function minimalScriptCapacityCompatible(script, {
  validate = true
} = {}) {
  if (validate) {
    _toolkit.validators.ValidateScript(script);
  }

  let bytes = 0;
  bytes += bytify(script.codeHash).length;
  bytes += bytify(script.args).length; // hash_type field

  bytes += 1;
  return _bi.BI.from(bytes).mul(100000000);
}

function minimalCellCapacity(fullCell, {
  validate = true
} = {}) {
  const result = minimalCellCapacityCompatible(fullCell, {
    validate
  });
  return BigInt(result.toString());
}

function minimalCellCapacityCompatible(fullCell, {
  validate = true
} = {}) {
  if (validate) {
    _base.blockchain.CellOutput.pack(fullCell.cellOutput);
  } // Capacity field itself


  let bytes = 8;
  bytes += bytify(fullCell.cellOutput.lock.codeHash).length;
  bytes += bytify(fullCell.cellOutput.lock.args).length; // hashType field

  bytes += 1;

  if (fullCell.cellOutput.type) {
    bytes += bytify(fullCell.cellOutput.type.codeHash).length;
    bytes += bytify(fullCell.cellOutput.type.args).length;
    bytes += 1;
  }

  if (fullCell.data) {
    bytes += bytify(fullCell.data).length;
  }

  return _bi.BI.from(bytes).mul(100000000);
}

function locateCellDep(script, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const scriptTemplate = Object.values(config.SCRIPTS).find(s => s && s.CODE_HASH === script.codeHash && s.HASH_TYPE === script.hashType);

  if (scriptTemplate) {
    return {
      depType: scriptTemplate.DEP_TYPE,
      outPoint: {
        txHash: scriptTemplate.TX_HASH,
        index: scriptTemplate.INDEX
      }
    };
  }

  return null;
}

let HAS_WARNED_FOR_DEPRECATED_ADDRESS = false;
/**
 * @deprecated please migrate to {@link encodeToAddress}, the short format address will be removed in the future
 * @param script
 * @param param1
 * @returns
 */

function generateAddress(script, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();

  if (!HAS_WARNED_FOR_DEPRECATED_ADDRESS) {
    console.warn("The address format generated by generateAddress or scriptToAddress will be deprecated, please migrate to encodeToAddress to generate the new ckb2021 full format address as soon as possible");
    HAS_WARNED_FOR_DEPRECATED_ADDRESS = true;
  }

  _toolkit.validators.ValidateScript(script);

  const scriptTemplate = Object.values(config.SCRIPTS).find(s => s && s.CODE_HASH === script.codeHash && s.HASH_TYPE === script.hashType);
  const data = [];

  if (scriptTemplate && scriptTemplate.SHORT_ID !== undefined) {
    data.push(1, scriptTemplate.SHORT_ID);
    data.push(...(0, _utils.hexToByteArray)(script.args));
  } else {
    if (script.hashType === "type") data.push(0x04);else if (script.hashType === "data") data.push(0x02);else throw new Error(`Invalid hashType ${script.hashType}`);
    data.push(...(0, _utils.hexToByteArray)(script.codeHash));
    data.push(...(0, _utils.hexToByteArray)(script.args));
  }

  const words = _bech.bech32.toWords(data);

  return _bech.bech32.encode(config.PREFIX, words, BECH32_LIMIT);
}
/**
 * @deprecated please migrate to {@link encodeToAddress}, the short format address will be removed in the future */


const scriptToAddress = generateAddress;
/**
 * @deprecated please migrate to {@link encodeToConfigAddress}
 * @param args
 * @param scriptType
 * @param param2
 * @returns
 */

exports.scriptToAddress = scriptToAddress;

function generatePredefinedAddress(args, scriptType, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const template = config.SCRIPTS[scriptType];

  if (!template) {
    const availableKeys = Object.keys(config.SCRIPTS);
    throw new Error(`Invalid script type: ${scriptType}, only support: ${availableKeys}`);
  }

  const script = {
    codeHash: template.CODE_HASH,
    hashType: template.HASH_TYPE,
    args
  };
  return generateAddress(script, {
    config
  });
}
/**
 * @deprecated please migrate to {@link encodeToConfigAddress}
 * @param args
 * @param param1
 * @returns
 */


function generateSecp256k1Blake160Address(args, {
  config = undefined
} = {}) {
  return generatePredefinedAddress(args, "SECP256K1_BLAKE160", {
    config
  });
}
/**
 * @deprecated please migrate to {@link encodeToConfigAddress}
 * @param args
 * @param config
 */


function generateSecp256k1Blake160MultisigAddress(args, {
  config = undefined
} = {}) {
  return generatePredefinedAddress(args, "SECP256K1_BLAKE160_MULTISIG", {
    config
  });
}

function parseAddress(address, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();

  try {
    return (0, _addressToScript.parseFullFormatAddress)(address, {
      config
    });
  } catch {
    return (0, _addressToScript.parseDeprecatedCkb2019Address)(address, {
      config
    });
  }
}

const addressToScript = parseAddress;
/**
 * parse a lock script to an address
 * @param script
 * @param config
 */

exports.addressToScript = addressToScript;

function encodeToAddress(script, {
  config = undefined
} = {}) {
  _toolkit.validators.ValidateScript(script);

  config = config || (0, _configManager.getConfig)();
  const data = [];

  const hashType = (() => {
    if (script.hashType === "data") return 0;
    if (script.hashType === "type") return 1;
    if (script.hashType === "data1") return 2;
    /* c8 ignore next */

    throw new Error(`Invalid hashType ${script.hashType}`);
  })();

  data.push(0x00);
  data.push(...(0, _utils.hexToByteArray)(script.codeHash));
  data.push(hashType);
  data.push(...(0, _utils.hexToByteArray)(script.args));
  return _bech.bech32m.encode(config.PREFIX, _bech.bech32m.toWords(data), BECH32_LIMIT);
}

/**
 * encode a script to an address with args and a key of config
 * @example
 * ```ts
 * // parse a predefined lock to an address
 * encodeToConfigAddress('0x12345678123456781234567812345678', 'SECP256K1_BLAKE160');
 * // parse a custom lock to an address
 * encodeToConfigAddress('0x12345678123456781234567812345678', 'MY_CUSTOM_LOCK', {
 *   SCRIPTS: {
 *     MY_CUSTOM_LOCK: {...}
 *   }
 * })
 * ```
 * @param args script args
 * @param scriptType a key of `config.SCRIPTS`
 * @param options
 * @returns
 */
function encodeToConfigAddress(args, scriptType, options) {
  const config = (options === null || options === void 0 ? void 0 : options.config) || (0, _configManager.getConfig)();
  const template = config.SCRIPTS[scriptType];

  if (!template) {
    const availableKeys = Object.keys(config.SCRIPTS);
    throw new Error( // prettier-ignore
    `Invalid script type: ${String(scriptType)}, only support: ${availableKeys}`);
  }

  const script = {
    codeHash: template.CODE_HASH,
    hashType: template.HASH_TYPE,
    args
  };
  return encodeToAddress(script, {
    config
  });
}

const TransactionSkeleton = (0, _immutable.Record)({
  cellProvider: null,
  cellDeps: (0, _immutable.List)(),
  headerDeps: (0, _immutable.List)(),
  inputs: (0, _immutable.List)(),
  outputs: (0, _immutable.List)(),
  witnesses: (0, _immutable.List)(),
  fixedEntries: (0, _immutable.List)(),
  signingEntries: (0, _immutable.List)(),
  inputSinces: (0, _immutable.Map)()
});
exports.TransactionSkeleton = TransactionSkeleton;

function createTransactionFromSkeleton(txSkeleton, {
  validate = true
} = {}) {
  const tx = {
    version: "0x0",
    cellDeps: txSkeleton.get("cellDeps").toArray(),
    headerDeps: txSkeleton.get("headerDeps").toArray(),
    inputs: txSkeleton.get("inputs").map((input, i) => {
      if (!input.outPoint) {
        throw new Error(`cannot find OutPoint in Inputs[${i}] when createTransactionFromSkeleton`);
      }

      return {
        since: txSkeleton.get("inputSinces").get(i, "0x0"),
        previousOutput: input.outPoint
      };
    }).toArray(),
    outputs: txSkeleton.get("outputs").map(output => output.cellOutput).toArray(),
    outputsData: txSkeleton.get("outputs").map(output => output.data || "0x0").toArray(),
    witnesses: txSkeleton.get("witnesses").toArray()
  };

  if (validate) {
    _toolkit.validators.ValidateTransaction(tx);
  }

  return tx;
}

function sealTransaction(txSkeleton, sealingContents) {
  const tx = createTransactionFromSkeleton(txSkeleton);

  if (sealingContents.length !== txSkeleton.get("signingEntries").size) {
    throw new Error(`Requiring ${txSkeleton.get("signingEntries").size} sealing contents but provided ${sealingContents.length}!`);
  }

  txSkeleton.get("signingEntries").forEach((e, i) => {
    switch (e.type) {
      case "witness_args_lock":
        {
          const witness = tx.witnesses[e.index];

          const witnessArgs = _base.blockchain.WitnessArgs.unpack(bytify(witness));

          const newWitnessArgs = {
            lock: sealingContents[i]
          };
          const inputType = witnessArgs.inputType;

          if (inputType) {
            newWitnessArgs.inputType = inputType;
          }

          const outputType = witnessArgs.outputType;

          if (outputType) {
            newWitnessArgs.outputType = outputType;
          }

          tx.witnesses[e.index] = hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));
          break;
        }

      default:
        throw new Error(`Invalid signing entry type: ${e.type}`);
    }
  });
  return tx;
}

/**
 * Convert TransactionSkeleton to js object
 *
 * @param txSkelton
 */
function transactionSkeletonToObject(txSkelton) {
  return txSkelton.toJS();
}
/**
 * Convert js object to TransactionSkeleton
 *
 * @param obj
 */


function objectToTransactionSkeleton(obj) {
  let inputSinces = (0, _immutable.Map)();

  for (const [key, value] of Object.entries(obj.inputSinces)) {
    inputSinces = inputSinces.set(+key, value);
  }

  const txSkeleton = TransactionSkeleton({
    cellProvider: obj.cellProvider,
    cellDeps: (0, _immutable.List)(obj.cellDeps),
    headerDeps: (0, _immutable.List)(obj.headerDeps),
    inputs: (0, _immutable.List)(obj.inputs),
    outputs: (0, _immutable.List)(obj.outputs),
    witnesses: (0, _immutable.List)(obj.witnesses),
    fixedEntries: (0, _immutable.List)(obj.fixedEntries),
    signingEntries: (0, _immutable.List)(obj.signingEntries),
    inputSinces
  });
  return txSkeleton;
}
//# sourceMappingURL=index.js.map