"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateP2PKHMessage = validateP2PKHMessage;

var _codec = require("@ckb-lumos/codec");

var _base = require("@ckb-lumos/base");

var _utils = require("@ckb-lumos/base/lib/utils");

function createHasher(algorithm) {
  switch (algorithm) {
    case "ckb-blake2b-256":
      return new _utils.CKBHasher({
        outLength: 32
      });

    case "ckb-blake2b-160":
      return new _utils.CKBHasher({
        outLength: 20
      });

    default:
      throw new Error(`Unsupported hash algorithm: ${algorithm}`);
  }
}
/**
 * Validate a P2PKH(Pay to public key hash) message
 * @param messagesForSigning the message digest for signing. means hash(rawTransaction | extraData).
 * @param rawTransaction raw transaction object
 * @param hashContentExceptRawTx content to be hashed other than rawTransaction, is generally processed witness
 * @param hashAlgorithm hash algorithm for signing. Default is `"ckb-blake2b-256"`
 * @returns the validate result. unless all messages equals, it will return false.
 */


function validateP2PKHMessage(messagesForSigning, rawTransaction, hashContentExceptRawTx, hashAlgorithm = "ckb-blake2b-256") {
  const rawTxHasher = createHasher(hashAlgorithm);
  const txHash = rawTxHasher.update(_base.blockchain.RawTransaction.pack(rawTransaction)).digestHex();
  const hasher = createHasher(hashAlgorithm);
  hasher.update(txHash);
  hasher.update(hashContentExceptRawTx);
  const actual = hasher.digestHex();
  return _codec.bytes.equal(messagesForSigning, actual);
}
//# sourceMappingURL=validate.js.map