"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatter = void 0;

var _exceptions = require("./exceptions");

var _bi = require("@ckb-lumos/bi");

/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */
const formatter = {
  toOptional: format => arg => {
    if (!format || arg === undefined || arg === null) {
      return arg;
    }

    return format(arg);
  },
  toArray: format => arg => {
    if (typeof format !== "function" || !Array.isArray(arg)) {
      return arg;
    }

    return arg.map(format);
  },
  toHash: hash => {
    if (typeof hash !== "string") {
      throw new _exceptions.StringHashTypeException(hash);
    }

    return hash.startsWith("0x") ? hash : `0x${hash}`;
  },
  toNumber: number => {
    if (typeof number === "bigint") {
      return `0x${number.toString(16)}`;
    }

    if (typeof number !== "string") {
      throw new _exceptions.BigintOrHexStringTypeException(number);
    }

    if (!number.startsWith("0x")) {
      throw new _exceptions.HexStringWithout0xException(number);
    }

    return number;
  },
  toScript: script => {
    const {
      codeHash,
      hashType: hash_type,
      ...rest
    } = script;
    return {
      code_hash: formatter.toHash(codeHash),
      hash_type,
      ...rest
    };
  },
  toOutPoint: outPoint => {
    const {
      txHash,
      index,
      ...rest
    } = outPoint;
    return {
      tx_hash: formatter.toHash(txHash),
      index: formatter.toNumber(index),
      ...rest
    };
  },
  toInput: input => {
    if (!input) return input;
    const {
      previousOutput,
      since,
      ...rest
    } = input;
    return {
      previous_output: formatter.toOutPoint(previousOutput),
      since: formatter.toNumber(since),
      ...rest
    };
  },
  toOutput: output => {
    if (!output) return output;
    const {
      capacity,
      lock,
      type = undefined,
      ...rest
    } = output;
    return {
      capacity: formatter.toNumber(capacity),
      lock: formatter.toScript(lock),
      type: type ? formatter.toScript(type) : type,
      ...rest
    };
  },
  toDepType: type => {
    if (type === "depGroup") {
      return "dep_group";
    }

    return type;
  },
  toOrder: order => {
    return order;
  },
  toCellDep: cellDep => {
    if (!cellDep) return cellDep;
    const {
      outPoint,
      depType = "code",
      ...rest
    } = cellDep;
    return {
      out_point: formatter.toOutPoint(outPoint),
      dep_type: formatter.toDepType(depType),
      ...rest
    };
  },
  toRawTransaction: transaction => {
    if (!transaction) return transaction;
    const {
      version,
      cellDeps = [],
      inputs = [],
      outputs = [],
      outputsData: outputs_data = [],
      headerDeps: header_deps = [],
      ...rest
    } = transaction;
    const formattedInputs = inputs.map(input => formatter.toInput(input));
    const formattedOutputs = outputs.map(output => formatter.toOutput(output));
    const formattedCellDeps = cellDeps.map(cellDep => formatter.toCellDep(cellDep));
    const tx = {
      version: formatter.toNumber(version),
      cell_deps: formattedCellDeps,
      inputs: formattedInputs,
      outputs: formattedOutputs,
      outputs_data,
      header_deps,
      ...rest
    };
    return tx;
  },
  toPageNumber: (pageNo = "0x1") => formatter.toNumber(pageNo),
  toPageSize: (pageSize = "0x32") => {
    const size = _bi.BI.from(pageSize);

    const MAX_SIZE = 50;
    const MIN_SIZE = 0;
    if (_bi.BI.from(size).gt(MAX_SIZE)) throw new _exceptions.PageSizeTooLargeException(pageSize, MAX_SIZE);
    if (_bi.BI.from(size).lt(MIN_SIZE)) throw new _exceptions.PageSizeTooSmallException(pageSize, MIN_SIZE);
    return formatter.toNumber(`0x${size.toString(16)}`);
  },
  toReverseOrder: (reverse = false) => !!reverse,
  toOutputsValidator: outputsValidator => {
    if (!outputsValidator) return undefined;
    const VALIDATORS = ["default", "passthrough"];

    if (VALIDATORS.indexOf(outputsValidator) > -1) {
      return outputsValidator;
    }

    throw new _exceptions.OutputsValidatorTypeException();
  },
  toBoolean: value => {
    return !!value;
  },
  toTransactionProof: proof => {
    if (!proof) return proof;
    const {
      blockHash: block_hash,
      witnessesRoot: witnesses_root,
      ...rest
    } = proof;
    return {
      block_hash,
      witnesses_root,
      ...rest
    };
  },
  toSearchFilter: data => {
    if (!data) return data;
    return {
      script: data.script ? formatter.toScript(data.script) : data.script,
      output_data_len_range: data.outputDataLenRange,
      output_capacity_range: data.outputCapacityRange,
      block_range: data.blockRange,
      script_len_range: data.scriptLenRange
    };
  },
  toSearchKey: data => {
    if (!data) return data;
    return {
      script: formatter.toScript(data.script),
      script_type: data.scriptType,
      filter: data.filter ? formatter.toSearchFilter(data.filter) : data.filter
    };
  },
  toGetCellsSearchKey: data => {
    if (!data) return data;
    return { ...formatter.toSearchKey(data),
      with_data: data.withData
    };
  },
  toGetTransactionsSearchKey: data => {
    if (!data) return data;
    return { ...formatter.toSearchKey(data),
      group_by_transaction: data.groupByTransaction
    };
  }
};
/* eslint-enable camelcase, @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */

exports.formatter = formatter;
//# sourceMappingURL=paramsFormatter.js.map