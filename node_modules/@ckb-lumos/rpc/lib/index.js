"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResultFormatter = exports.RPC = exports.ParamsFormatter = exports.CKBRPC = void 0;

var _Base = require("./Base");

var _method = require("./method");

var _paramsFormatter = require("./paramsFormatter");

var resultFormatter = _interopRequireWildcard(require("./resultFormatter"));

var _exceptions = require("./exceptions");

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import axios from 'axios'
// import { MethodInBatchNotFoundException, PayloadInBatchException, IdNotMatchedInBatchException } from './exceptions'
const ParamsFormatter = _paramsFormatter.formatter;
exports.ParamsFormatter = ParamsFormatter;
const ResultFormatter = resultFormatter;
exports.ResultFormatter = ResultFormatter;

class CKBRPC extends _Base.Base {
  #config;
  #node = {
    url: ""
  };

  get node() {
    return this.#node;
  }

  #paramsFormatter = _paramsFormatter.formatter;

  get paramsFormatter() {
    return this.#paramsFormatter;
  }

  #resultFormatter = resultFormatter;

  get resultFormatter() {
    return this.#resultFormatter;
  }

  constructor(url, config = {
    timeout: 30000
  }) {
    super();
    this.setNode({
      url
    });
    this.#config = config;
    Object.defineProperties(this, {
      addMethod: {
        value: this.addMethod,
        enumerable: false,
        writable: false,
        configurable: false
      },
      setNode: {
        value: this.setNode,
        enumerable: false,
        writable: false,
        configurable: false
      } // createBatchRequest: { value: this.createBatchRequest, enumerable: false, writable: false, configurable: false },

    });
    Object.keys(this.rpcProperties).forEach(name => {
      this.addMethod({
        name,
        ...this.rpcProperties[name]
      }, config);
    });
  }

  setNode(node) {
    Object.assign(this.node, node);
    return this.node;
  }

  addMethod = (options, config) => {
    const method = new _method.Method(this.node, options, config);
    Object.defineProperty(this, options.name, {
      value: method.call,
      enumerable: true
    });
  };
  /* eslint-disable */

  createBatchRequest = ( // TODO fix me
  // params: [method: N, ...rest: P][] = [],
  params = []) => {
    const ctx = this; // TODO fix me

    const proxied = new Proxy([], {
      set(...p) {
        const methods = Object.keys(ctx);

        if (p[1] !== "length") {
          var _p$;

          const name = p === null || p === void 0 ? void 0 : (_p$ = p[2]) === null || _p$ === void 0 ? void 0 : _p$[0];

          if (methods.indexOf(name) === -1) {
            throw new _exceptions.MethodInBatchNotFoundException(name);
          }
        }

        return Reflect.set(...p);
      }

    });
    Object.defineProperties(proxied, {
      add: {
        value(...args) {
          this.push(args);
          return this;
        }

      },
      remove: {
        value(i) {
          this.splice(i, 1);
          return this;
        }

      },
      exec: {
        async value() {
          // TODO fix me
          const payload = proxied.map(([f, ...p], i) => {
            try {
              const method = new _method.Method(ctx.node, { ...ctx.rpcProperties[f],
                name: f
              });
              return method.getPayload(...p);
            } catch (err) {
              throw new _exceptions.PayloadInBatchException(i, err.message);
            }
          });
          const batchRes = await (0, _axios.default)({
            method: "POST",
            headers: {
              "content-type": "application/json"
            },
            data: payload,
            url: ctx.#node.url,
            httpAgent: ctx.#node.httpAgent,
            httpsAgent: ctx.#node.httpsAgent,
            timeout: ctx.#config.timeout
          });
          return batchRes.data.map((res, i) => {
            var _ctx$rpcProperties$pr, _ctx$rpcProperties$pr2, _ctx$rpcProperties$pr3;

            if (res.id !== payload[i].id) {
              return new _exceptions.IdNotMatchedInBatchException(i, payload[i].id, res.id);
            }

            return (_ctx$rpcProperties$pr = (_ctx$rpcProperties$pr2 = (_ctx$rpcProperties$pr3 = ctx.rpcProperties[proxied[i][0]]).resultFormatters) === null || _ctx$rpcProperties$pr2 === void 0 ? void 0 : _ctx$rpcProperties$pr2.call(_ctx$rpcProperties$pr3, res.result)) !== null && _ctx$rpcProperties$pr !== void 0 ? _ctx$rpcProperties$pr : res.result;
          });
        }

      }
    }); // TODO fix me

    params.forEach(p => proxied.push(p));
    return proxied;
  };
}

exports.RPC = exports.CKBRPC = CKBRPC;
//# sourceMappingURL=index.js.map