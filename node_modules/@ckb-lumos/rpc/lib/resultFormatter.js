"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toTip = exports.toSyncState = exports.toScript = exports.toRemoteNodeInfo = exports.toRawTxPool = exports.toPeers = exports.toOutput = exports.toOutPoint = exports.toNumber = exports.toLockHashIndexStates = exports.toLockHashIndexState = exports.toLocalNodeInfo = exports.toLiveCellsByLockHash = exports.toLiveCellWithStatus = exports.toLiveCell = exports.toInput = exports.toHeader = exports.toHash = exports.toGetTransactionsResult = exports.toGetCellsResult = exports.toFeeRate = exports.toEpoch = exports.toDepType = exports.toConsensus = exports.toCellsIncludingOutPoint = exports.toCellsCapacity = exports.toCells = exports.toCellbaseOutputCapacityDetails = exports.toCellIncludingOutPoint = exports.toCellDep = exports.toCell = exports.toCapacityByLockHash = exports.toBlockchainInfo = exports.toBlockEconomicState = exports.toBlock = exports.toBannedAddresses = exports.toBannedAddress = exports.toAlertMessage = void 0;
exports.toTransaction = toTransaction;
exports.toUncleBlock = exports.toTxPoolInfo = exports.toTransactionsByLockHash = exports.toTransactionWithStatus = exports.toTransactionProof = exports.toTransactionPoint = void 0;

const isTxPoolIds = rawTxPool => {
  return Array.isArray(rawTxPool.pending);
};
/* eslint-disable camelcase */


const toNumber = number => number.toString();

exports.toNumber = toNumber;

const toHash = hash => hash;

exports.toHash = toHash;

const toHeader = header => {
  if (!header) return header;
  const {
    compact_target: compactTarget,
    transactions_root: transactionsRoot,
    proposals_hash: proposalsHash,
    extra_hash: extraHash,
    parent_hash: parentHash,
    ...rest
  } = header;
  return {
    compactTarget,
    parentHash,
    transactionsRoot,
    proposalsHash,
    extraHash,
    ...rest
  };
};

exports.toHeader = toHeader;

const toScript = script => {
  if (!script) return script;
  const {
    code_hash: codeHash,
    hash_type: hashType,
    ...rest
  } = script;
  return {
    codeHash,
    hashType,
    ...rest
  };
};

exports.toScript = toScript;

const toInput = input => {
  if (!input) return input;
  const {
    previous_output: previousOutput,
    ...rest
  } = input;
  return {
    previousOutput: previousOutput ? toOutPoint(previousOutput) : previousOutput,
    ...rest
  };
};

exports.toInput = toInput;

const toOutput = output => {
  if (!output) return output;
  const {
    lock,
    type,
    ...rest
  } = output;
  return {
    lock: toScript(lock),
    type: type ? toScript(type) : type,
    ...rest
  };
};

exports.toOutput = toOutput;

const toOutPoint = outPoint => {
  const {
    tx_hash: txHash,
    ...rest
  } = outPoint;
  return {
    txHash,
    ...rest
  };
};

exports.toOutPoint = toOutPoint;

const toDepType = type => {
  if (type === "dep_group") {
    return "depGroup";
  }

  return type;
};

exports.toDepType = toDepType;

const toCellDep = cellDep => {
  if (!cellDep) return cellDep;
  const {
    out_point: outPoint,
    dep_type = "code",
    ...rest
  } = cellDep;
  return {
    outPoint: toOutPoint(outPoint),
    depType: toDepType(dep_type),
    ...rest
  };
};

exports.toCellDep = toCellDep;

function toTransaction(tx) {
  if (!tx) return tx;
  const {
    cell_deps: cellDeps = [],
    inputs = [],
    outputs = [],
    outputs_data: outputsData = [],
    header_deps: headerDeps = [],
    ...rest
  } = tx;
  return {
    cellDeps: cellDeps.map(toCellDep),
    inputs: inputs.map(toInput),
    outputs: outputs.map(toOutput),
    outputsData,
    headerDeps,
    ...rest
  };
}

const toUncleBlock = uncleBlock => {
  if (!uncleBlock) return uncleBlock;
  const {
    header,
    ...rest
  } = uncleBlock;
  return {
    header: toHeader(header),
    ...rest
  };
};

exports.toUncleBlock = toUncleBlock;

const toTip = tip => ({
  blockHash: tip.block_hash,
  blockNumber: tip.block_number
});

exports.toTip = toTip;

const toBlock = block => {
  if (!block) return block;
  const {
    header,
    uncles = [],
    transactions = [],
    ...rest
  } = block;
  return {
    header: toHeader(header),
    uncles: uncles.map(toUncleBlock),
    transactions: transactions.map(toTransaction),
    ...rest
  };
};

exports.toBlock = toBlock;

const toAlertMessage = alertMessage => {
  if (!alertMessage) return alertMessage;
  const {
    notice_until: noticeUntil,
    ...rest
  } = alertMessage;
  return {
    noticeUntil,
    ...rest
  };
};

exports.toAlertMessage = toAlertMessage;

const toBlockchainInfo = info => {
  if (!info) return info;
  const {
    is_initial_block_download: isInitialBlockDownload,
    median_time: medianTime,
    alerts,
    ...rest
  } = info;
  return {
    isInitialBlockDownload,
    medianTime,
    alerts: alerts.map(toAlertMessage),
    ...rest
  };
};

exports.toBlockchainInfo = toBlockchainInfo;

const toLocalNodeInfo = info => {
  if (!info) return info;
  const {
    node_id: nodeId,
    protocols,
    ...rest
  } = info;
  return {
    nodeId,
    protocols: protocols.map(({
      id,
      name,
      support_versions: supportVersions
    }) => ({
      id,
      name,
      supportVersions
    })),
    ...rest
  };
};

exports.toLocalNodeInfo = toLocalNodeInfo;

const toRemoteNodeInfo = info => {
  if (!info) return info;
  const {
    node_id: nodeId,
    connected_duration: connectedDuration,
    is_outbound: isOutbound,
    last_ping_duration: lastPingDuration,
    sync_state,
    ...rest
  } = info;
  return {
    nodeId,
    connectedDuration,
    isOutbound,
    lastPingDuration,
    syncState: {
      bestKnownHeaderHash: sync_state.best_known_header_hash,
      bestKnownHeaderNumber: sync_state.best_known_header_number,
      canFetchCount: sync_state.can_fetch_count,
      inflightCount: sync_state.inflight_count,
      lastCommonHeaderHash: sync_state.last_common_header_hash,
      lastCommonHeaderNumber: sync_state.last_common_header_number,
      unknownHeaderListSize: sync_state.unknown_header_list_size
    },
    ...rest
  };
};

exports.toRemoteNodeInfo = toRemoteNodeInfo;

const toTxPoolInfo = info => {
  if (!info) return info;
  const {
    last_txs_updated_at: lastTxsUpdatedAt,
    tip_hash: tipHash,
    tip_number: tipNumber,
    total_tx_cycles: totalTxCycles,
    total_tx_size: totalTxSize,
    min_fee_rate: minFeeRate,
    ...rest
  } = info;
  return {
    lastTxsUpdatedAt,
    tipHash,
    tipNumber,
    totalTxCycles,
    totalTxSize,
    minFeeRate,
    ...rest
  };
};

exports.toTxPoolInfo = toTxPoolInfo;

const toPeers = nodes => {
  if (!Array.isArray(nodes)) return [];
  return nodes.map(toRemoteNodeInfo);
};

exports.toPeers = toPeers;

const toCell = cell => {
  if (!cell) return cell;
  const {
    lock,
    type,
    ...rest
  } = cell;
  return {
    lock: toScript(lock),
    type: type ? toScript(type) : undefined,
    ...rest
  };
};

exports.toCell = toCell;

const toLiveCell = liveCell => {
  if (!liveCell) return liveCell;
  const {
    data,
    output,
    ...rest
  } = liveCell;
  return {
    data,
    output: toOutput(output),
    ...rest
  };
};

exports.toLiveCell = toLiveCell;

const toLiveCellWithStatus = cellWithStatus => {
  if (!cellWithStatus) return cellWithStatus;
  const {
    cell,
    ...rest
  } = cellWithStatus;
  return {
    cell: toLiveCell(cell),
    ...rest
  };
};

exports.toLiveCellWithStatus = toLiveCellWithStatus;

const toCells = cells => {
  if (!Array.isArray(cells)) return [];
  return cells.map(toCell);
}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


exports.toCells = toCells;

const toCellIncludingOutPoint = cell => {
  if (!cell) return cell;
  const {
    lock,
    block_hash: blockHash,
    out_point,
    output_data_len: outputDataLen,
    ...rest
  } = cell;
  return {
    blockHash,
    lock: toScript(lock),
    outPoint: toOutPoint(out_point),
    outputDataLen,
    ...rest
  };
};

exports.toCellIncludingOutPoint = toCellIncludingOutPoint;

const toCellsIncludingOutPoint = cells => {
  if (!Array.isArray(cells)) return [];
  return cells.map(toCellIncludingOutPoint);
}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


exports.toCellsIncludingOutPoint = toCellsIncludingOutPoint;

const toTransactionWithStatus = txWithStatus => {
  if (!txWithStatus) return txWithStatus;
  const {
    transaction,
    tx_status: {
      block_hash: blockHash,
      status
    },
    ...rest
  } = txWithStatus;
  return {
    transaction: toTransaction(transaction),
    txStatus: {
      blockHash,
      status
    },
    ...rest
  };
};

exports.toTransactionWithStatus = toTransactionWithStatus;

const toEpoch = epoch => {
  if (!epoch) return epoch;
  const {
    start_number: startNumber,
    compact_target: compactTarget,
    ...rest
  } = epoch;
  return {
    compactTarget,
    startNumber,
    ...rest
  };
};

exports.toEpoch = toEpoch;

const toTransactionPoint = transactionPoint => {
  if (!transactionPoint) return transactionPoint;
  const {
    block_number: blockNumber,
    tx_hash: txHash,
    ...rest
  } = transactionPoint;
  return {
    blockNumber,
    txHash,
    ...rest
  };
};

exports.toTransactionPoint = toTransactionPoint;

const toTransactionsByLockHash = transactions => {
  if (!transactions) return transactions;
  return transactions.map(tx => ({
    consumedBy: tx.consumed_by ? toTransactionPoint(tx.consumed_by) : tx.consumed_by,
    createdBy: toTransactionPoint(tx.created_by)
  }));
};

exports.toTransactionsByLockHash = toTransactionsByLockHash;

const toLiveCellsByLockHash = cells => {
  if (!cells) return cells;
  return cells.map(cell => ({
    cellOutput: toCell(cell.cell_output),
    createdBy: toTransactionPoint(cell.created_by),
    cellbase: cell.cellbase,
    outputDataLen: cell.output_data_len
  }));
};

exports.toLiveCellsByLockHash = toLiveCellsByLockHash;

const toLockHashIndexState = index => {
  if (!index) return index;
  const {
    block_hash: blockHash,
    block_number: blockNumber,
    lock_hash: lockHash,
    ...rest
  } = index;
  return {
    blockHash,
    blockNumber,
    lockHash,
    ...rest
  };
};

exports.toLockHashIndexState = toLockHashIndexState;

const toLockHashIndexStates = states => {
  if (!states) return states;
  return states.map(toLockHashIndexState);
};

exports.toLockHashIndexStates = toLockHashIndexStates;

const toBannedAddress = bannedAddress => {
  if (!bannedAddress) return bannedAddress;
  const {
    ban_reason: banReason,
    ban_until: banUntil,
    created_at: createdAt,
    ...rest
  } = bannedAddress;
  return {
    banReason,
    banUntil,
    createdAt,
    ...rest
  };
};

exports.toBannedAddress = toBannedAddress;

const toBannedAddresses = bannedAddresses => {
  if (!bannedAddresses) return bannedAddresses;
  return bannedAddresses.map(banAddr => toBannedAddress(banAddr));
};

exports.toBannedAddresses = toBannedAddresses;

const toCellbaseOutputCapacityDetails = details => {
  if (!details) return details;
  const {
    proposal_reward: proposalReward,
    tx_fee: txFee,
    ...rest
  } = details;
  return {
    proposalReward,
    txFee,
    ...rest
  };
};

exports.toCellbaseOutputCapacityDetails = toCellbaseOutputCapacityDetails;

const toFeeRate = feeRateObj => {
  if (!feeRateObj) {
    return feeRateObj;
  }

  const {
    fee_rate: feeRate,
    ...rest
  } = feeRateObj;
  return {
    feeRate,
    ...rest
  };
};

exports.toFeeRate = toFeeRate;

const toCapacityByLockHash = capacityByLockHash => {
  if (!capacityByLockHash) {
    return capacityByLockHash;
  }

  const {
    cells_count: cellsCount,
    block_number: blockNumber,
    capacity,
    ...rest
  } = capacityByLockHash;
  return {
    blockNumber,
    capacity,
    cellsCount,
    ...rest
  };
};

exports.toCapacityByLockHash = toCapacityByLockHash;

const toBlockEconomicState = blockEconomicState => {
  if (!blockEconomicState) {
    return blockEconomicState;
  }

  const {
    finalized_at: finalizedAt,
    miner_reward: minerReward,
    txs_fee: txsFee,
    ...rest
  } = blockEconomicState;
  return {
    finalizedAt,
    minerReward,
    txsFee,
    ...rest
  };
};

exports.toBlockEconomicState = toBlockEconomicState;

const toSyncState = state => {
  if (!state) {
    return state;
  }

  return {
    bestKnownBlockNumber: state.best_known_block_number,
    bestKnownBlockTimestamp: state.best_known_block_timestamp,
    fastTime: state.fast_time,
    ibd: state.ibd,
    inflightBlocksCount: state.inflight_blocks_count,
    lowTime: state.low_time,
    normalTime: state.normal_time,
    orphanBlocksCount: state.orphan_blocks_count
  };
};

exports.toSyncState = toSyncState;

const toTransactionProof = proof => {
  if (!proof) {
    return proof;
  }

  const {
    block_hash: blockHash,
    witnesses_root: witnessesRoot,
    ...rest
  } = proof;
  return {
    blockHash,
    witnessesRoot,
    ...rest
  };
};

exports.toTransactionProof = toTransactionProof;

const toConsensus = consensus => {
  var _consensus$hardfork_f, _consensus$hardfork_f2;

  if (!consensus) return consensus;
  return {
    blockVersion: consensus.block_version,
    cellbaseMaturity: consensus.cellbase_maturity,
    daoTypeHash: consensus.dao_type_hash,
    epochDurationTarget: consensus.epoch_duration_target,
    genesisHash: consensus.genesis_hash,
    id: consensus.id,
    initialPrimaryEpochReward: consensus.initial_primary_epoch_reward,
    maxBlockBytes: consensus.max_block_bytes,
    maxBlockCycles: consensus.max_block_cycles,
    maxBlockProposalsLimit: consensus.max_block_proposals_limit,
    maxUnclesNum: consensus.max_uncles_num,
    medianTimeBlockCount: consensus.median_time_block_count,
    orphanRateTarget: consensus.orphan_rate_target,
    permanentDifficultyInDummy: consensus.permanent_difficulty_in_dummy,
    primaryEpochRewardHalvingInterval: consensus.primary_epoch_reward_halving_interval,
    proposerRewardRatio: consensus.proposer_reward_ratio,
    secondaryEpochReward: consensus.secondary_epoch_reward,
    secp256k1Blake160MultisigAllTypeHash: consensus.secp256k1_blake160_multisig_all_type_hash,
    secp256k1Blake160SighashAllTypeHash: consensus.secp256k1_blake160_sighash_all_type_hash,
    txProposalWindow: consensus.tx_proposal_window,
    txVersion: consensus.tx_version,
    typeIdCodeHash: consensus.type_id_code_hash,
    hardforkFeatures: (_consensus$hardfork_f = (_consensus$hardfork_f2 = consensus.hardfork_features) === null || _consensus$hardfork_f2 === void 0 ? void 0 : _consensus$hardfork_f2.map(({
      epoch_number: epochNumber,
      ...rest
    }) => ({
      epochNumber,
      ...rest
    }))) !== null && _consensus$hardfork_f !== void 0 ? _consensus$hardfork_f : consensus.hardfork_features
  };
};

exports.toConsensus = toConsensus;

const toRawTxPool = rawTxPool => {
  if (!rawTxPool) return rawTxPool;

  if (isTxPoolIds(rawTxPool)) {
    return rawTxPool;
  }

  const toTxVerbosity = ({
    ancestors_count: ancestorsCount,
    ancestors_cycles: ancestorsCycles,
    ancestors_size: ancestorsSize,
    ...rest
  }) => ({
    ancestorsCount,
    ancestorsCycles,
    ancestorsSize,
    ...rest
  });

  const proposed = {};
  const pending = {};
  Object.keys(rawTxPool.proposed).forEach(hash => {
    proposed[hash] = toTxVerbosity(rawTxPool.proposed[hash]);
  });
  Object.keys(rawTxPool.pending).forEach(hash => {
    pending[hash] = toTxVerbosity(rawTxPool.pending[hash]);
  });
  return {
    proposed,
    pending
  };
};

exports.toRawTxPool = toRawTxPool;

const toIndexerCell = indexerCell => {
  if (!indexerCell) return indexerCell;
  return {
    blockNumber: indexerCell.block_number,
    outPoint: toOutPoint(indexerCell.out_point),
    output: toOutput(indexerCell.output),
    outputData: indexerCell.output_data,
    txIndex: indexerCell.tx_index
  };
};

const toGetCellsResult = getCellsResult => ({
  lastCursor: getCellsResult.last_cursor,
  objects: getCellsResult.objects.map(object => toIndexerCell(object))
});

exports.toGetCellsResult = toGetCellsResult;

const isUngroupedIndexerTransaction = value => {
  if (value.cells) {
    return false;
  }

  return true;
};

const toIndexerTransaction = indexerTransaction => {
  if (!indexerTransaction) return indexerTransaction;

  if (isUngroupedIndexerTransaction(indexerTransaction)) {
    return {
      txHash: indexerTransaction.tx_hash,
      blockNumber: indexerTransaction.block_number,
      ioIndex: indexerTransaction.io_index,
      ioType: indexerTransaction.io_type,
      txIndex: indexerTransaction.tx_index
    };
  }

  return {
    txHash: indexerTransaction.tx_hash,
    txIndex: indexerTransaction.tx_index,
    blockNumber: indexerTransaction.block_number,
    cells: indexerTransaction.cells
  };
};

const toGetTransactionsResult = getTransactionsResult => {
  if (!getTransactionsResult) return getTransactionsResult;
  return {
    lastCursor: getTransactionsResult.last_cursor,
    objects: getTransactionsResult.objects.map(object => toIndexerTransaction(object))
  };
};

exports.toGetTransactionsResult = toGetTransactionsResult;

const toCellsCapacity = cellsCapacity => {
  if (!cellsCapacity) return cellsCapacity;
  return {
    capacity: cellsCapacity.capacity,
    blockHash: cellsCapacity.block_hash,
    blockNumber: cellsCapacity.block_number
  };
};
/* eslint-enable camelcase */


exports.toCellsCapacity = toCellsCapacity;
//# sourceMappingURL=resultFormatter.js.map