"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareScriptBinaryWithOnChainData = compareScriptBinaryWithOnChainData;
exports.default = void 0;
exports.generateDeployWithDataTx = generateDeployWithDataTx;
exports.generateDeployWithTypeIdTx = generateDeployWithTypeIdTx;
exports.generateUpgradeTypeIdDataTx = generateUpgradeTypeIdDataTx;

var _base = require("@ckb-lumos/base");

var _codec = require("@ckb-lumos/codec");

var _configManager = require("@ckb-lumos/config-manager");

var _helpers = require("@ckb-lumos/helpers");

var _immutable = require("immutable");

var _from_info = require("./from_info");

var _bi = require("@ckb-lumos/bi");

const {
  ScriptValue
} = _base.values;

function bytesToHex(bytes) {
  let res = "0x";

  for (let i = 0; i < bytes.length; i++) {
    res += bytes[i].toString(16).padStart(2, "0");
  }

  return res;
}

async function findCellsByLock(lockScript, cellProvider) {
  const collector = cellProvider.collector({
    lock: lockScript,
    type: "empty",
    data: "0x"
  });
  const cells = [];

  for await (const cell of collector.collect()) {
    cells.push(cell);
  }

  return cells;
}

function updateOutputs(txSkeleton, output) {
  const cellCapacity = (0, _helpers.minimalCellCapacityCompatible)(output);
  output.cellOutput.capacity = `0x${cellCapacity.toString(16)}`;
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push(output);
  });
  return txSkeleton;
}

function updateCellDeps(txSkeleton, config) {
  txSkeleton = txSkeleton.update("cellDeps", cellDeps => {
    return cellDeps.clear();
  });
  config = config || (0, _configManager.getConfig)();
  const secp256k1Config = config.SCRIPTS.SECP256K1_BLAKE160;
  const secp256k1MultiSigConfig = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;

  if (!secp256k1Config || !secp256k1MultiSigConfig) {
    throw new Error("Provided config does not have SECP256K1_BLAKE160 or SECP256K1_BLAKE160_MULTISIG script setup!");
  }

  txSkeleton = txSkeleton.update("cellDeps", cellDeps => {
    return cellDeps.push({
      outPoint: {
        txHash: secp256k1Config.TX_HASH,
        index: secp256k1Config.INDEX
      },
      depType: secp256k1Config.DEP_TYPE
    }, // TODO: optimize me, push dep directly without checking actual locks used would cause bigger tx
    {
      outPoint: {
        txHash: secp256k1MultiSigConfig.TX_HASH,
        index: secp256k1MultiSigConfig.INDEX
      },
      depType: secp256k1MultiSigConfig.DEP_TYPE
    });
  });
  return txSkeleton;
}

async function completeTx(txSkeleton, fromInfo, config, feeRate) {
  const inputCapacity = txSkeleton.get("inputs").map(c => _bi.BI.from(c.cellOutput.capacity)).reduce((a, b) => a.add(b), _bi.BI.from(0));
  const outputCapacity = txSkeleton.get("outputs").map(c => _bi.BI.from(c.cellOutput.capacity)).reduce((a, b) => a.add(b), _bi.BI.from(0));
  const needCapacity = outputCapacity.sub(inputCapacity);
  txSkeleton = await injectCapacity(txSkeleton, fromInfo, _bi.BI.from(needCapacity), {
    config: config,
    feeRate: feeRate
  });
  return txSkeleton;
}

async function injectCapacity(txSkeleton, fromInfo, amount, {
  config = undefined,
  feeRate = undefined
}) {
  config = config || (0, _configManager.getConfig)();

  const _feeRate = feeRate || 1000;

  let _amount = _bi.BI.from(amount);

  const {
    fromScript,
    multisigScript
  } = (0, _from_info.parseFromInfo)(fromInfo, {
    config
  });
  _amount = _amount.add(_bi.BI.from(10).pow(8));

  let changeCapacity = _bi.BI.from(10).pow(8);

  const changeCell = {
    cellOutput: {
      capacity: "0x0",
      lock: fromScript,
      type: undefined
    },
    data: "0x"
  };

  const minimalChangeCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell)).add(_bi.BI.from(10).pow(8));

  if (_amount.lt(0)) {
    changeCapacity = changeCapacity.sub(_amount);
    _amount = _bi.BI.from(0);
  }

  if (_amount.gt(0) || changeCapacity.lt(minimalChangeCapacity)) {
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) throw new Error("Cell provider is missing!");
    const cellCollector = cellProvider.collector({
      lock: fromScript,
      type: "empty",
      data: "0x"
    });
    let previousInputs = (0, _immutable.Set)();

    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(`${input.outPoint.txHash}_${input.outPoint.index}`);
    }

    for await (const inputCell of cellCollector.collect()) {
      if (previousInputs.has(`${inputCell.outPoint.txHash}_${inputCell.outPoint.index}`)) continue;
      txSkeleton = txSkeleton.update("inputs", inputs => inputs.push(inputCell));
      txSkeleton = txSkeleton.update("witnesses", witnesses => witnesses.push("0x"));

      const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);

      let deductCapacity = inputCapacity;

      if (deductCapacity.gt(_amount)) {
        deductCapacity = _amount;
      }

      _amount = _amount.sub(deductCapacity);
      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);
      if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gte(minimalChangeCapacity))) break;
    }
  }

  if (changeCapacity.gt(0)) {
    changeCell.cellOutput.capacity = "0x" + changeCapacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", outputs => outputs.push(changeCell));
  }

  if (_amount.gt(0) || changeCapacity.lt(minimalChangeCapacity)) throw new Error("Not enough capacity in from address!");
  /*
   * Modify the skeleton, so the first witness of the fromAddress script group
   * has a WitnessArgs construct with 65-byte zero filled values. While this
   * is not required, it helps in transaction fee estimation.
   */

  const firstIndex = txSkeleton.get("inputs").findIndex(input => new ScriptValue(input.cellOutput.lock, {
    validate: false
  }).equals(new ScriptValue(fromScript, {
    validate: false
  })));

  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", witnesses => witnesses.push("0x"));
    }

    let witness = txSkeleton.get("witnesses").get(firstIndex);
    let newWitnessArgs;
    const SECP_SIGNATURE_PLACEHOLDER = "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

    if (typeof fromInfo !== "string") {
      newWitnessArgs = {
        lock: "0x" + multisigScript.slice(2) + SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(fromInfo.M)
      };
    } else {
      newWitnessArgs = {
        lock: SECP_SIGNATURE_PLACEHOLDER
      };
    }

    if (witness !== "0x") {
      const witnessArgs = _base.blockchain.WitnessArgs.unpack(_codec.bytes.bytify(witness));

      const lock = witnessArgs.lock;

      if (!!lock && !!newWitnessArgs.lock && !_codec.bytes.equal(lock, newWitnessArgs.lock)) {
        throw new Error("Lock field in first witness is set aside for signature!");
      }

      const inputType = witnessArgs.inputType;

      if (inputType) {
        newWitnessArgs.inputType = inputType;
      }

      const outputType = witnessArgs.outputType;

      if (outputType) {
        newWitnessArgs.outputType = outputType;
      }
    }

    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));
    txSkeleton = txSkeleton.update("witnesses", witnesses => witnesses.set(firstIndex, witness));
  }

  const txFee = calculateTxFee(txSkeleton, _feeRate);
  changeCapacity = changeCapacity.sub(txFee);
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.pop();
  });

  if (changeCapacity.gt(0)) {
    changeCell.cellOutput.capacity = "0x" + changeCapacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", outputs => outputs.push(changeCell));
  }

  return txSkeleton;
}

function getTransactionSize(txSkeleton) {
  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);
  return getTransactionSizeByTx(tx);
}

function getTransactionSizeByTx(tx) {
  const serializedTx = _base.blockchain.Transaction.pack(tx); // 4 is serialized offset bytesize


  const size = serializedTx.byteLength + 4;
  return size;
}

function calculateFee(size, feeRate) {
  const ratio = _bi.BI.from(1000);

  const base = _bi.BI.from(size).mul(feeRate);

  const fee = base.div(ratio);

  if (fee.mul(ratio).lt(base)) {
    return fee.add(1);
  }

  return _bi.BI.from(fee);
}

function calculateTxFee(txSkeleton, feeRate) {
  const txSize = getTransactionSize(txSkeleton);
  return _bi.BI.from(calculateFee(txSize, feeRate));
}

function calculateCodeHashByBin(scriptBin) {
  const bin = scriptBin.valueOf();
  return new _base.utils.CKBHasher().update(bin.buffer.slice(bin.byteOffset, bin.byteLength + bin.byteOffset)).digestHex();
}

async function getDataHash(outPoint, rpc) {
  const txHash = outPoint.txHash;
  const index = parseInt(outPoint.index, 10);
  const tx = await rpc.getTransaction(txHash);
  if (!tx) throw new Error(`TxHash(${txHash}) is not found`);
  const outputData = tx.transaction.outputsData[index];
  if (!outputData) throw new Error(`cannot find output data`);
  return new _base.utils.CKBHasher().update(_codec.bytes.bytify(outputData)).digestHex();
}

function calculateTxHash(txSkeleton) {
  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);

  const txHash = _base.utils.ckbHash(_base.blockchain.Transaction.pack(tx));

  return txHash;
}

function getScriptConfigByDataHash(txSkeleton, outputIndex) {
  const data = txSkeleton.outputs.get(outputIndex).data;

  const codeHash = _base.utils.ckbHash(_codec.bytes.bytify(data));

  const txHash = calculateTxHash(txSkeleton);
  const scriptConfig = {
    CODE_HASH: codeHash,
    HASH_TYPE: "data1",
    TX_HASH: txHash,
    INDEX: "0x0",
    DEP_TYPE: "code"
  };
  return scriptConfig;
}

function getScriptConfigByTypeHash(txSkeleton, outputIndex) {
  const typeScript = txSkeleton.outputs.get(outputIndex).cellOutput.type;

  const codeHash = _base.utils.computeScriptHash(typeScript);

  const txHash = calculateTxHash(txSkeleton);
  const scriptConfig = {
    CODE_HASH: codeHash,
    HASH_TYPE: "type",
    TX_HASH: txHash,
    INDEX: "0x0",
    DEP_TYPE: "code"
  };
  return scriptConfig;
}

function getScriptConfig(txSkeleton, outputIndex) {
  const outputCell = txSkeleton.outputs.get(outputIndex);
  if (outputCell == undefined) throw new Error("Invalid txSkeleton or outputIndex");
  const type = outputCell.cellOutput.type;
  if (type !== undefined) return getScriptConfigByTypeHash(txSkeleton, outputIndex);
  return getScriptConfigByDataHash(txSkeleton, outputIndex);
}

function isMultisigFromInfo(fromInfo) {
  if (typeof fromInfo !== "object") return false;
  return "M" in fromInfo && "R" in fromInfo && Array.isArray(fromInfo.publicKeyHashes);
}

function verifyFromInfo(fromInfo, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();

  if (typeof fromInfo === "string") {
    if (_configManager.helpers.nameOfScript((0, _helpers.parseAddress)(fromInfo, {
      config
    }), config.SCRIPTS) !== "SECP256K1_BLAKE160") throw new Error("only SECP256K1_BLAKE160 or SECP256K1_MULTISIG is supported");
  } else if (!isMultisigFromInfo(fromInfo)) {
    throw new Error("only SECP256K1_BLAKE160 or SECP256K1_MULTISIG is supported");
  }
}

/**
 * Generate txSkeleton for writing binary data to CKB, usually for deploying contracts.
 * This generator only supports `SECP256K1_BLAKE160` and `SECP256K1_BLAKE160_MULTISIG` currently.
 *
 * @param options
 */
async function generateDeployWithDataTx(options) {
  verifyFromInfo(options.fromInfo, {
    config: options.config
  });
  let txSkeleton = (0, _helpers.TransactionSkeleton)({
    cellProvider: options.cellProvider
  });
  const {
    fromScript
  } = (0, _from_info.parseFromInfo)(options.fromInfo, {
    config: options.config
  });
  const output = {
    cellOutput: {
      capacity: "0x0",
      lock: fromScript
    },
    data: bytesToHex(options.scriptBinary)
  };
  txSkeleton = updateOutputs(txSkeleton, output);
  txSkeleton = updateCellDeps(txSkeleton, options.config);
  txSkeleton = await completeTx(txSkeleton, options.fromInfo, options.config, options.feeRate);
  const scriptConfig = getScriptConfig(txSkeleton, 0);
  return {
    txSkeleton,
    scriptConfig
  };
}
/**
 * Generate txSkeleton for writing binary data to CKB via Type ID, usually for deploying contracts.
 * Deploying via Type ID makes it possible to upgrade contract, for more information about Type ID, please check: https://xuejie.space/2020_02_03_introduction_to_ckb_script_programming_type_id/
 * This generator only supports `SECP256K1_BLAKE160` and `SECP256K1_BLAKE160_MULTISIG` currently.
 *
 * @param options
 */


async function generateDeployWithTypeIdTx(options) {
  verifyFromInfo(options.fromInfo, {
    config: options.config
  });
  let txSkeleton = (0, _helpers.TransactionSkeleton)({
    cellProvider: options.cellProvider
  });
  const {
    fromScript
  } = (0, _from_info.parseFromInfo)(options.fromInfo, {
    config: options.config
  });
  const [resolved] = await findCellsByLock(fromScript, options.cellProvider);
  if (!resolved) throw new Error(`fromAddress has no live ckb`);

  const typeId = _base.utils.generateTypeIdScript({
    previousOutput: resolved.outPoint,
    since: "0x0"
  }, "0x0");

  const output = {
    cellOutput: {
      capacity: "0x0",
      lock: fromScript,
      type: typeId
    },
    data: bytesToHex(options.scriptBinary)
  };
  txSkeleton = updateOutputs(txSkeleton, output);
  txSkeleton = updateCellDeps(txSkeleton, options.config);
  txSkeleton = await completeTx(txSkeleton, options.fromInfo, options.config, options.feeRate);
  const scriptConfig = getScriptConfig(txSkeleton, 0);
  return {
    txSkeleton,
    scriptConfig,
    typeId
  };
}

async function generateUpgradeTypeIdDataTx(options) {
  verifyFromInfo(options.fromInfo, {
    config: options.config
  });
  let txSkeleton = (0, _helpers.TransactionSkeleton)({
    cellProvider: options.cellProvider
  });
  const {
    fromScript
  } = (0, _from_info.parseFromInfo)(options.fromInfo, {
    config: options.config
  });
  const collector = options.cellProvider.collector({
    type: options.typeId
  });
  const cells = [];

  for await (const cell of collector.collect()) {
    cells.push(cell);
  }

  if (cells.length !== 1) throw new Error("the typeid maybe wrong");
  const deployedCell = cells[0];
  txSkeleton = txSkeleton.update("inputs", inputs => {
    return inputs.push(deployedCell);
  });
  const output = {
    cellOutput: {
      capacity: "0x0",
      lock: fromScript,
      type: options.typeId
    },
    data: bytesToHex(options.scriptBinary)
  };
  txSkeleton = updateOutputs(txSkeleton, output);
  txSkeleton = updateCellDeps(txSkeleton, options.config);
  txSkeleton = await completeTx(txSkeleton, options.fromInfo, options.config, options.feeRate);
  const scriptConfig = getScriptConfig(txSkeleton, 0);
  return {
    txSkeleton,
    scriptConfig
  };
}

async function compareScriptBinaryWithOnChainData(scriptBinary, outPoint, rpc) {
  const localHash = calculateCodeHashByBin(scriptBinary);
  const onChainHash = await getDataHash(outPoint, rpc);
  return localHash === onChainHash;
}

var _default = {
  generateDeployWithDataTx,
  generateDeployWithTypeIdTx,
  generateUpgradeTypeIdDataTx,
  compareScriptBinaryWithOnChainData,
  __tests__: {
    calculateTxFee
  }
};
exports.default = _default;
//# sourceMappingURL=deploy.js.map