"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SECP_SIGNATURE_PLACEHOLDER = exports.OMNILOCK_SIGNATURE_PLACEHOLDER = void 0;
exports.addCellDep = addCellDep;
exports.default = void 0;
exports.ensureScript = ensureScript;
exports.generateDaoScript = generateDaoScript;
exports.hashWitness = hashWitness;
exports.isAcpAddress = isAcpAddress;
exports.isAcpScript = isAcpScript;
exports.isDaoScript = isDaoScript;
exports.isOmnilockAddress = isOmnilockAddress;
exports.isOmnilockScript = isOmnilockScript;
exports.isSecp256k1Blake160Address = isSecp256k1Blake160Address;
exports.isSecp256k1Blake160MultisigAddress = isSecp256k1Blake160MultisigAddress;
exports.isSecp256k1Blake160MultisigScript = isSecp256k1Blake160MultisigScript;
exports.isSecp256k1Blake160Script = isSecp256k1Blake160Script;
exports.isSudtScript = isSudtScript;
exports.prepareSigningEntries = prepareSigningEntries;

var omnilock = _interopRequireWildcard(require("./omnilock"));

var _immutable = require("immutable");

var _helpers = require("@ckb-lumos/helpers");

var _codec = require("@ckb-lumos/codec");

var _base = require("@ckb-lumos/base");

var _bi = require("@ckb-lumos/bi");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable @typescript-eslint/no-non-null-assertion, @typescript-eslint/explicit-module-boundary-types */
const {
  CKBHasher,
  ckbHash
} = _base.utils;

function addCellDep(txSkeleton, newCellDep) {
  const cellDep = txSkeleton.get("cellDeps").find(cellDep => {
    return cellDep.depType === newCellDep.depType && new _base.values.OutPointValue(cellDep.outPoint, {
      validate: false
    }).equals(new _base.values.OutPointValue(newCellDep.outPoint, {
      validate: false
    }));
  });

  if (!cellDep) {
    txSkeleton = txSkeleton.update("cellDeps", cellDeps => {
      return cellDeps.push({
        outPoint: newCellDep.outPoint,
        depType: newCellDep.depType
      });
    });
  }

  return txSkeleton;
}

function generateDaoScript(config) {
  const template = config.SCRIPTS.DAO;
  return {
    codeHash: template.CODE_HASH,
    hashType: template.HASH_TYPE,
    args: "0x"
  };
}

function isSecp256k1Blake160Script(script, config) {
  const template = config.SCRIPTS.SECP256K1_BLAKE160;
  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}

function isSecp256k1Blake160Address(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isSecp256k1Blake160Script(script, config);
}

function isOmnilockScript(script, config) {
  const template = config.SCRIPTS.OMNILOCK;
  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}

function isOmnilockAddress(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isOmnilockScript(script, config);
}

function isSecp256k1Blake160MultisigScript(script, config) {
  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}

function isSecp256k1Blake160MultisigAddress(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isSecp256k1Blake160MultisigScript(script, config);
}

function isDaoScript(script, config) {
  const template = config.SCRIPTS.DAO;
  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}

function isSudtScript(script, config) {
  const template = config.SCRIPTS.SUDT;

  if (!template) {
    throw new Error(`SUDT script not defined in config!`);
  }

  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}

function isAcpScript(script, config) {
  const template = config.SCRIPTS.ANYONE_CAN_PAY;

  if (!template) {
    throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
  }

  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}

function isAcpAddress(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isAcpScript(script, config);
}
/**
 * Hash a witness in a hasher
 * @param hasher The hasher object which should have a `update` method.
 * @param witness witness data, the inputs to hasher will derived from it
 */


function hashWitness(hasher, witness) {
  const lengthBuffer = new ArrayBuffer(8);
  const view = new DataView(lengthBuffer);

  const witnessHexString = _bi.BI.from(_codec.bytes.bytify(witness).length).toString(16);

  if (witnessHexString.length <= 8) {
    view.setUint32(0, Number("0x" + witnessHexString), true);
    view.setUint32(4, Number("0x" + "00000000"), true);
  }

  if (witnessHexString.length > 8 && witnessHexString.length <= 16) {
    view.setUint32(0, Number("0x" + witnessHexString.slice(-8)), true);
    view.setUint32(4, Number("0x" + witnessHexString.slice(0, -8)), true);
  }

  hasher.update(lengthBuffer);
  hasher.update(witness);
}
/* eslint-enable camelcase, @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */


function prepareSigningEntries(txSkeleton, config, scriptType) {
  const template = config.SCRIPTS[scriptType];

  if (!template) {
    throw new Error(`Provided config does not have ${scriptType} script setup!`);
  }

  let processedArgs = (0, _immutable.Set)();
  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);
  const txHash = ckbHash(_base.blockchain.RawTransaction.pack(tx));
  const inputs = txSkeleton.get("inputs");
  const witnesses = txSkeleton.get("witnesses");
  let signingEntries = txSkeleton.get("signingEntries");

  for (let i = 0; i < inputs.size; i++) {
    const input = inputs.get(i);

    if (template.CODE_HASH === input.cellOutput.lock.codeHash && template.HASH_TYPE === input.cellOutput.lock.hashType && !processedArgs.has(input.cellOutput.lock.args)) {
      processedArgs = processedArgs.add(input.cellOutput.lock.args);
      const lockValue = new _base.values.ScriptValue(input.cellOutput.lock, {
        validate: false
      });
      const hasher = new CKBHasher();
      hasher.update(txHash);

      if (i >= witnesses.size) {
        throw new Error(`The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`);
      }

      hashWitness(hasher, witnesses.get(i));

      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
        const otherInput = inputs.get(j);

        if (lockValue.equals(new _base.values.ScriptValue(otherInput.cellOutput.lock, {
          validate: false
        }))) {
          hashWitness(hasher, witnesses.get(j));
        }
      }

      for (let j = inputs.size; j < witnesses.size; j++) {
        hashWitness(hasher, witnesses.get(j));
      }

      const signingEntry = {
        type: "witness_args_lock",
        index: i,
        message: hasher.digestHex()
      };
      signingEntries = signingEntries.push(signingEntry);
    }
  }

  txSkeleton = txSkeleton.set("signingEntries", signingEntries);
  return txSkeleton;
}

function ensureScript(script, config, scriptType) {
  const template = config.SCRIPTS[scriptType];

  if (!template) {
    throw new Error(`Provided config does not have ${scriptType} script setup!`);
  }

  if (template.CODE_HASH !== script.codeHash || template.HASH_TYPE !== script.hashType) {
    throw new Error(`Provided script is not ${scriptType} script!`);
  }
}
/* 65-byte zeros in hex */


const SECP_SIGNATURE_PLACEHOLDER = "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
/* 85-byte zeros in hex */

exports.SECP_SIGNATURE_PLACEHOLDER = SECP_SIGNATURE_PLACEHOLDER;
const OMNILOCK_SIGNATURE_PLACEHOLDER = `0x${"00".repeat(omnilock.OmnilockWitnessLock.pack({
  signature: SECP_SIGNATURE_PLACEHOLDER
}).byteLength)}`;
exports.OMNILOCK_SIGNATURE_PLACEHOLDER = OMNILOCK_SIGNATURE_PLACEHOLDER;
var _default = {
  addCellDep,
  generateDaoScript,
  isSecp256k1Blake160Script,
  isSecp256k1Blake160MultisigScript,
  isDaoScript,
  isSudtScript,
  prepareSigningEntries,
  isSecp256k1Blake160Address,
  isSecp256k1Blake160MultisigAddress,
  ensureScript,
  isAcpScript,
  isAcpAddress
};
exports.default = _default;
//# sourceMappingURL=helper.js.map