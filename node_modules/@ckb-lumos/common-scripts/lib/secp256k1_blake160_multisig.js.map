{"version":3,"file":"secp256k1_blake160_multisig.js","names":["ScriptValue","values","CellCollector","constructor","fromInfo","cellProvider","config","undefined","queryOptions","Error","getConfig","result","parseFromInfo","fromScript","multisigScript","lock","type","cellCollector","collector","collect","isSecp256k1Blake160MultisigScript","inputCell","setupInputCell","txSkeleton","defaultWitness","since","requireMultisigScript","cellOutput","parsedFromScript","validate","equals","update","inputs","push","inputSinces","set","get","size","witnesses","outputCell","capacity","data","outputs","template","SCRIPTS","SECP256K1_BLAKE160_MULTISIG","scriptOutPoint","txHash","TX_HASH","index","INDEX","addCellDep","outPoint","depType","DEP_TYPE","firstIndex","findIndex","input","firstIndexWitness","witness","newWitnessArgs","slice","SECP_SIGNATURE_PLACEHOLDER","repeat","M","witnessArgs","blockchain","WitnessArgs","unpack","bytes","bytify","equal","inputType","outputType","hexify","pack","transfer","toAddress","amount","requireToAddress","assertAmountEnough","transferCompatible","_txSkeleton","_amount","Array","BigInt","toString","ensureScript","noMultisigBefore","find","i","BI","from","toScript","parseAddress","blockHash","lastFreezedOutput","filter","field","maxBy","gt","output","cellCapacity","deductCapacity","gte","sub","minimalCellCapacityCompatible","eq","changeCell","changeCapacity","previousInputs","Set","add","has","inputCapacity","payFee","injectCapacity","outputIndex","prepareSigningEntries","_prepareSigningEntries","serializeMultisigScript","multisigArgs"],"sources":["../src/secp256k1_blake160_multisig.ts"],"sourcesContent":["import {\n  parseAddress,\n  TransactionSkeletonType,\n  Options,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport { bytes } from \"@ckb-lumos/codec\";\nimport {\n  values,\n  HexString,\n  Script,\n  Address,\n  OutPoint,\n  Cell,\n  WitnessArgs,\n  CellCollector as CellCollectorType,\n  CellProvider,\n  QueryOptions,\n  PackedSince,\n  blockchain,\n} from \"@ckb-lumos/base\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nconst { ScriptValue } = values;\nimport { Set } from \"immutable\";\nimport {\n  addCellDep,\n  ensureScript,\n  SECP_SIGNATURE_PLACEHOLDER,\n  prepareSigningEntries as _prepareSigningEntries,\n  isSecp256k1Blake160MultisigScript,\n} from \"./helper\";\nimport {\n  FromInfo,\n  parseFromInfo,\n  MultisigScript,\n  serializeMultisigScript,\n  multisigArgs,\n} from \"./from_info\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { CellCollectorConstructor } from \"./type\";\n\nexport { serializeMultisigScript, multisigArgs };\n\nexport const CellCollector: CellCollectorConstructor = class CellCollector\n  implements CellCollectorType\n{\n  private cellCollector: CellCollectorType;\n  private config: Config;\n  public readonly fromScript: Script;\n  public readonly multisigScript?: HexString;\n\n  constructor(\n    fromInfo: FromInfo,\n    cellProvider: CellProvider,\n    {\n      config = undefined,\n      queryOptions = {},\n    }: Options & {\n      queryOptions?: QueryOptions;\n    } = {}\n  ) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || getConfig();\n    const result = parseFromInfo(fromInfo, { config });\n    this.fromScript = result.fromScript;\n    this.multisigScript = result.multisigScript;\n\n    this.config = config;\n\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n      type: queryOptions.type || \"empty\",\n    };\n\n    this.cellCollector = cellProvider.collector(queryOptions);\n  }\n\n  async *collect(): AsyncGenerator<Cell> {\n    if (!isSecp256k1Blake160MultisigScript(this.fromScript, this.config)) {\n      return;\n    }\n\n    for await (const inputCell of this.cellCollector.collect()) {\n      yield inputCell;\n    }\n  }\n};\n\n/**\n * Setup input cell infos, such as cell deps and witnesses.\n *\n * @param txSkeleton\n * @param inputCell\n * @param fromInfo\n * @param options\n */\nexport async function setupInputCell(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    defaultWitness = \"0x\",\n    since = undefined,\n    requireMultisigScript = true,\n  }: Options & {\n    defaultWitness?: HexString;\n    requireMultisigScript?: boolean;\n    since?: PackedSince;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n\n  if (requireMultisigScript && typeof fromInfo !== \"object\") {\n    throw new Error(\"`fromInfo` must be MultisigScript format!\");\n  }\n\n  const fromScript: Script = inputCell.cellOutput.lock;\n\n  if (fromInfo) {\n    const parsedFromScript: Script = parseFromInfo(fromInfo, {\n      config,\n    }).fromScript;\n    if (\n      !new ScriptValue(parsedFromScript, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      throw new Error(\"`fromInfo` not match to input lock!\");\n    }\n  }\n\n  if (!isSecp256k1Blake160MultisigScript(fromScript, config)) {\n    throw new Error(`Not SECP256K1_BLAKE160_MULTISIG input!`);\n  }\n\n  // add inputCell to txSkeleton\n  txSkeleton = txSkeleton.update(\"inputs\", (inputs) => {\n    return inputs.push(inputCell);\n  });\n\n  if (since) {\n    txSkeleton = txSkeleton.update(\"inputSinces\", (inputSinces) => {\n      return inputSinces.set(txSkeleton.get(\"inputs\").size - 1, since);\n    });\n  }\n\n  txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => {\n    return witnesses.push(defaultWitness);\n  });\n\n  const outputCell: Cell = {\n    cellOutput: {\n      capacity: inputCell.cellOutput.capacity,\n      lock: inputCell.cellOutput.lock,\n      type: inputCell.cellOutput.type,\n    },\n    data: inputCell.data,\n  };\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push(outputCell);\n  });\n\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!template) {\n    throw new Error(\n      `SECP256K1_BLAKE160_MULTISIG script not defined in config!`\n    );\n  }\n\n  const scriptOutPoint: OutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX,\n  };\n\n  // add cell dep\n  txSkeleton = addCellDep(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE,\n  });\n\n  // add witness\n  const firstIndex = txSkeleton\n    .get(\"inputs\")\n    .findIndex((input) =>\n      new ScriptValue(input.cellOutput.lock, { validate: false }).equals(\n        new ScriptValue(fromScript!, { validate: false })\n      )\n    );\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n    }\n\n    const firstIndexWitness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n    // If never prepared witness of this lock script before, should using fromInfo(MultisigScript) to update witness\n    if (firstIndexWitness === \"0x\" && typeof fromInfo !== \"object\") {\n      throw new Error(\"`fromInfo` must be MultisigScript format!\");\n    }\n\n    // if using MultisigScript, check witnesses\n    if (typeof fromInfo === \"object\") {\n      const multisigScript: HexString = parseFromInfo(fromInfo, { config })\n        .multisigScript!;\n      let witness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n      const newWitnessArgs: WitnessArgs = {\n        lock:\n          \"0x\" +\n          multisigScript.slice(2) +\n          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(\n            (fromInfo as MultisigScript).M\n          ),\n      };\n      if (witness !== \"0x\") {\n        const witnessArgs = blockchain.WitnessArgs.unpack(\n          bytes.bytify(witness)\n        );\n        const lock = witnessArgs.lock;\n        if (\n          !!lock &&\n          !!newWitnessArgs.lock &&\n          !bytes.equal(lock, newWitnessArgs.lock)\n        ) {\n          throw new Error(\n            \"Lock field in first witness is set aside for signature!\"\n          );\n        }\n        const inputType = witnessArgs.inputType;\n        if (inputType) {\n          newWitnessArgs.inputType = inputType;\n        }\n        const outputType = witnessArgs.outputType;\n        if (outputType) {\n          newWitnessArgs.outputType = outputType;\n        }\n      }\n      witness = bytes.hexify(blockchain.WitnessArgs.pack(newWitnessArgs));\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.set(firstIndex, witness)\n      );\n    }\n  }\n\n  return txSkeleton;\n}\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  options?: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  options: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n  }\n): Promise<[TransactionSkeletonType, bigint]>;\n\n/**\n * transfer capacity from multisig script cells\n *\n * @param txSkeleton\n * @param fromInfo fromAddress or fromMultisigScript, if this address new to txSkeleton inputs, must use fromMultisigScript\n * @param toAddress\n * @param amount transfer CKB capacity in shannon.\n * @param options\n */\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {\n  const result = await transferCompatible(\n    txSkeleton,\n    fromInfo,\n    toAddress,\n    amount,\n    {\n      config,\n      requireToAddress,\n      assertAmountEnough: assertAmountEnough as true | undefined,\n    }\n  );\n  let _txSkeleton: TransactionSkeletonType;\n  let _amount: bigint;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  options?: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  options: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n  }\n): Promise<[TransactionSkeletonType, BI]>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  config = config || getConfig();\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!template) {\n    throw new Error(\n      \"Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!\"\n    );\n  }\n  const scriptOutPoint: OutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX,\n  };\n\n  txSkeleton = addCellDep(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE,\n  });\n\n  const { fromScript, multisigScript } = parseFromInfo(fromInfo, { config });\n\n  ensureScript(fromScript, config, \"SECP256K1_BLAKE160_MULTISIG\");\n\n  const noMultisigBefore = !txSkeleton.get(\"inputs\").find((i) => {\n    return new ScriptValue(i.cellOutput.lock, { validate: false }).equals(\n      new ScriptValue(fromScript!, { validate: false })\n    );\n  });\n\n  if (noMultisigBefore && fromInfo === \"string\") {\n    throw new Error(\"MultisigScript is required for witness!\");\n  }\n\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n\n  let _amount = amount ? BI.from(amount) : BI.from(0);\n  if (toAddress) {\n    const toScript = parseAddress(toAddress, { config });\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.push({\n        cellOutput: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined,\n        },\n        data: \"0x\",\n        outPoint: undefined,\n        blockHash: undefined,\n      });\n    });\n  }\n\n  const lastFreezedOutput = txSkeleton\n    .get(\"fixedEntries\")\n    .filter(({ field }) => field === \"outputs\")\n    .maxBy(({ index }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n    const output = txSkeleton.get(\"outputs\").get(i)!;\n    if (\n      new ScriptValue(output.cellOutput.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      const cellCapacity = BI.from(output.cellOutput.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub(\n          minimalCellCapacityCompatible(output)\n        );\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n      output.cellOutput.capacity =\n        \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n    }\n  }\n  // remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.filter(\n      (output) => !BI.from(output.cellOutput.capacity).eq(0)\n    );\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n    // TODO: ignore locktime now.\n    const cellCollector = cellProvider.collector({\n      lock: fromScript,\n    });\n    const changeCell: Cell = {\n      cellOutput: {\n        capacity: \"0x0\",\n        lock: fromScript,\n        type: undefined,\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined,\n    };\n    let changeCapacity = BI.from(0);\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(\n        `${input.outPoint!.txHash}_${input.outPoint!.index}`\n      );\n    }\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      if (\n        previousInputs.has(\n          `${inputCell.outPoint!.txHash}_${inputCell.outPoint!.index}`\n        )\n      ) {\n        continue;\n      }\n      txSkeleton = txSkeleton.update(\"inputs\", (inputs) =>\n        inputs.push(inputCell)\n      );\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n      const inputCapacity = BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));\n      if (\n        _amount.eq(0) &&\n        (changeCapacity.eq(0) ||\n          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))\n      ) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n        outputs.push(changeCell)\n      );\n    }\n  }\n  if (_amount.gt(0) && assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n\n  const firstIndex = txSkeleton\n    .get(\"inputs\")\n    .findIndex((input) =>\n      new ScriptValue(input.cellOutput.lock, { validate: false }).equals(\n        new ScriptValue(fromScript!, { validate: false })\n      )\n    );\n  if (firstIndex !== -1) {\n    while (BI.from(firstIndex).gte(txSkeleton.get(\"witnesses\").size)) {\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n    }\n\n    // if using MultisigScript, check witnesses\n    if (noMultisigBefore || typeof fromInfo !== \"string\") {\n      let witness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n      const newWitnessArgs: WitnessArgs = {\n        lock:\n          \"0x\" +\n          multisigScript!.slice(2) +\n          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(\n            (fromInfo as MultisigScript).M\n          ),\n      };\n      if (witness !== \"0x\") {\n        const witnessArgs = blockchain.WitnessArgs.unpack(\n          bytes.bytify(witness)\n        );\n        const lock = witnessArgs.lock;\n        if (\n          !!lock &&\n          !!newWitnessArgs.lock &&\n          !bytes.equal(lock, newWitnessArgs.lock)\n        ) {\n          throw new Error(\n            \"Lock field in first witness is set aside for signature!\"\n          );\n        }\n        const inputType = witnessArgs.inputType;\n        if (inputType) {\n          newWitnessArgs.inputType = inputType;\n        }\n        const outputType = witnessArgs.outputType;\n        if (outputType) {\n          newWitnessArgs.outputType = outputType;\n        }\n      }\n      witness = bytes.hexify(blockchain.WitnessArgs.pack(newWitnessArgs));\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.set(firstIndex, witness)\n      );\n    }\n  }\n  if (!assertAmountEnough) {\n    return [txSkeleton, BI.from(_amount)];\n  }\n  return txSkeleton;\n}\n\n/**\n * pay fee by multisig script cells\n *\n * @param txSkeleton\n * @param fromInfo\n * @param amount fee in shannon\n * @param options\n */\nexport async function payFee(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  amount: BIish,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  return transferCompatible(txSkeleton, fromInfo, undefined, amount, {\n    config,\n    requireToAddress: false,\n  });\n}\n\n/**\n * Inject capacity from `fromInfo` to target output.\n *\n * @param txSkeleton\n * @param outputIndex\n * @param fromInfo\n * @param options\n */\nexport async function injectCapacity(\n  txSkeleton: TransactionSkeletonType,\n  outputIndex: number,\n  fromInfo: FromInfo,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = BI.from(\n    txSkeleton.get(\"outputs\").get(outputIndex)!.cellOutput.capacity\n  );\n  return transferCompatible(txSkeleton, fromInfo, undefined, capacity, {\n    config,\n    requireToAddress: false,\n  });\n}\n\n/**\n * prepare for txSkeleton signingEntries, will update txSkeleton.get(\"signingEntries\")\n *\n * @param txSkeleton\n * @param options\n */\nexport function prepareSigningEntries(\n  txSkeleton: TransactionSkeletonType,\n  { config = undefined }: Options = {}\n): TransactionSkeletonType {\n  config = config || getConfig();\n\n  return _prepareSigningEntries(\n    txSkeleton,\n    config,\n    \"SECP256K1_BLAKE160_MULTISIG\"\n  );\n}\n\nexport default {\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  serializeMultisigScript,\n  multisigArgs,\n  injectCapacity,\n  setupInputCell,\n  CellCollector,\n};\n"],"mappings":"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"}