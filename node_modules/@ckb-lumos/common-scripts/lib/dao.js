"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CellCollector = void 0;
exports.calculateDaoEarliestSince = calculateDaoEarliestSince;
exports.calculateDaoEarliestSinceCompatible = calculateDaoEarliestSinceCompatible;
exports.calculateMaximumWithdraw = calculateMaximumWithdraw;
exports.calculateMaximumWithdrawCompatible = calculateMaximumWithdrawCompatible;
exports.default = void 0;
exports.deposit = deposit;
exports.extractDaoDataCompatible = extractDaoDataCompatible;
exports.listDaoCells = listDaoCells;
exports.unlock = unlock;

var _helpers = require("@ckb-lumos/helpers");

var _base = require("@ckb-lumos/base");

var _codec = require("@ckb-lumos/codec");

var _configManager = require("@ckb-lumos/config-manager");

var _secp256k1_blake = _interopRequireDefault(require("./secp256k1_blake160"));

var _secp256k1_blake160_multisig = _interopRequireDefault(require("./secp256k1_blake160_multisig"));

var _from_info = require("./from_info");

var _helper = require("./helper");

var _bi = require("@ckb-lumos/bi");

var _rpc = require("@ckb-lumos/rpc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  parseSince
} = _base.since;
const DEPOSIT_DAO_DATA = "0x0000000000000000";

const DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE = _bi.BI.from(180);

class CellCollector {
  constructor(fromInfo, cellProvider, cellType, {
    config = undefined
  } = {}) {
    if (!cellProvider) {
      throw new Error("Cell Provider is missing!");
    }

    config = config || (0, _configManager.getConfig)();
    const fromScript = (0, _from_info.parseFromInfo)(fromInfo, {
      config
    }).fromScript;
    const daoTypeScript = (0, _helper.generateDaoScript)(config);
    const data = cellType === "deposit" ? DEPOSIT_DAO_DATA : "any";
    this.cellType = cellType;
    this.cellCollector = cellProvider.collector({
      lock: fromScript,
      type: daoTypeScript,
      data
    });
  }

  async *collect() {
    for await (const inputCell of this.cellCollector.collect()) {
      if (this.cellType === "withdraw" && inputCell.data === DEPOSIT_DAO_DATA) {
        continue;
      }

      yield inputCell;
    }
  }

}
/**
 * list DAO cells,
 *
 * @param cellProvider
 * @param fromAddress
 * @param cellType
 * @param options
 */


exports.CellCollector = CellCollector;

async function* listDaoCells(cellProvider, fromAddress, cellType, {
  config = undefined
} = {}) {
  const collector = new CellCollector(fromAddress, cellProvider, cellType, {
    config
  });

  for await (const cell of collector.collect()) {
    yield cell;
  }
} // TODO: reject multisig with non absolute-epoch-number locktime lock

/**
 * deposit a cell to DAO
 *
 * @param txSkeleton
 * @param fromInfo
 * @param toAddress deposit cell lock address
 * @param amount capacity in shannon
 * @param options
 */


async function deposit(txSkeleton, fromInfo, toAddress, amount, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const DAO_SCRIPT = config.SCRIPTS.DAO;

  if (!DAO_SCRIPT) {
    throw new Error("Provided config does not have DAO script setup!");
  }

  _checkFromInfoSince(fromInfo, config); // check and add cellDep if not exists


  txSkeleton = _addDaoCellDep(txSkeleton, config);

  if (!toAddress) {
    throw new Error("You must provide a to address!");
  }

  const toScript = (0, _helpers.parseAddress)(toAddress, {
    config
  });
  const daoTypeScript = {
    codeHash: DAO_SCRIPT.CODE_HASH,
    hashType: DAO_SCRIPT.HASH_TYPE,
    args: "0x"
  };
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push({
      cellOutput: {
        capacity: "0x" + _bi.BI.from(amount).toString(16),
        lock: toScript,
        type: daoTypeScript
      },
      data: DEPOSIT_DAO_DATA,
      outPoint: undefined,
      blockHash: undefined
    });
  });
  const outputIndex = txSkeleton.get("outputs").size - 1; // fix entry

  txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
    return fixedEntries.push({
      field: "outputs",
      index: outputIndex
    });
  });

  if (typeof fromInfo === "string") {
    const fromScript = (0, _helpers.parseAddress)(fromInfo, {
      config
    }); // address

    if ((0, _helper.isSecp256k1Blake160Script)(fromScript, config)) {
      txSkeleton = await _secp256k1_blake.default.injectCapacity(txSkeleton, outputIndex, fromInfo, {
        config
      });
    } else if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromScript, config)) {
      txSkeleton = await _secp256k1_blake160_multisig.default.injectCapacity(txSkeleton, outputIndex, fromInfo, {
        config
      });
    }
  } else if (fromInfo) {
    txSkeleton = await _secp256k1_blake160_multisig.default.injectCapacity(txSkeleton, outputIndex, fromInfo, {
      config
    });
  }

  return txSkeleton;
}

function _checkFromInfoSince(fromInfo, config) {
  let since;

  if (typeof fromInfo === "string") {
    // fromInfo is an address
    const fromScript = (0, _helpers.parseAddress)(fromInfo, {
      config
    });
    const args = fromScript.args;

    if (args.length === 58) {
      since = _codec.number.Uint64LE.unpack("0x" + args.slice(42)).toHexString();
    }
  } else if ("R" in fromInfo) {
    since = fromInfo.since;
  }

  if (since != null) {
    const {
      relative,
      type
    } = parseSince(since);

    if (!(!relative && type === "epochNumber")) {
      throw new Error("Can't deposit a dao cell with multisig locktime which not using absolute-epoch-number format!");
    }
  }
}
/**
 * withdraw an deposited DAO cell
 *
 * @param txSkeleton
 * @param fromInput deposited DAO cell
 * @param fromInfo
 * @param options
 */


async function withdraw(txSkeleton, fromInput, fromInfo, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();

  _checkDaoScript(config);

  txSkeleton = _addDaoCellDep(txSkeleton, config); // check inputs.size == outputs.size

  if (txSkeleton.get("inputs").size !== txSkeleton.get("outputs").size) {
    throw new Error("Input size must equals to output size in txSkeleton!");
  }

  if (!config.SCRIPTS.DAO) {
    throw new Error("Provided config does not have DAO script setup!");
  } // TODO: check fromInput


  const cellProvider = txSkeleton.get("cellProvider");

  if (!cellProvider) {
    throw new Error("Cell provider is missing!");
  }

  const typeScript = fromInput.cellOutput.type;
  const DAO_SCRIPT = config.SCRIPTS.DAO;

  if (!typeScript || typeScript.codeHash !== DAO_SCRIPT.CODE_HASH || typeScript.hashType !== DAO_SCRIPT.HASH_TYPE || fromInput.data !== DEPOSIT_DAO_DATA) {
    throw new Error("fromInput is not a DAO deposit cell.");
  } // setup input cell


  const fromLockScript = fromInput.cellOutput.lock;

  if ((0, _helper.isSecp256k1Blake160Script)(fromLockScript, config)) {
    txSkeleton = await _secp256k1_blake.default.setupInputCell(txSkeleton, fromInput, undefined, {
      config
    });
  } else if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromLockScript, config)) {
    txSkeleton = await _secp256k1_blake160_multisig.default.setupInputCell(txSkeleton, fromInput, fromInfo || (0, _helpers.generateAddress)(fromLockScript, {
      config
    }), {
      config
    });
  }

  const targetOutputIndex = txSkeleton.get("outputs").size - 1;
  const targetOutput = txSkeleton.get("outputs").get(targetOutputIndex);
  const clonedTargetOutput = JSON.parse(JSON.stringify(targetOutput));

  if (!fromInput.blockNumber) {
    throw new Error("fromInput has no blockNumber!");
  } else {
    clonedTargetOutput.data = _codec.bytes.hexify(_codec.number.Uint64.pack(fromInput.blockNumber));
  }

  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.update(targetOutputIndex, () => clonedTargetOutput);
  }); // add header deps

  txSkeleton = txSkeleton.update("headerDeps", headerDeps => {
    return headerDeps.push(fromInput.blockHash);
  }); // fix inputs / outputs / witnesses

  txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
    return fixedEntries.push({
      field: "inputs",
      index: txSkeleton.get("inputs").size - 1
    }, {
      field: "outputs",
      index: txSkeleton.get("outputs").size - 1
    });
  });
  return txSkeleton;
}

function parseEpochCompatible(epoch) {
  const _epoch = _bi.BI.from(epoch);

  return {
    length: _epoch.shr(40).and(0xfff),
    index: _epoch.shr(24).and(0xfff),
    number: _epoch.and(0xffffff)
  };
}

function epochSinceCompatible({
  length,
  index,
  number
}) {
  const _length = _bi.BI.from(length);

  const _index = _bi.BI.from(index);

  const _number = _bi.BI.from(number);

  return _bi.BI.from(0x20).shl(56).add(_length.shl(40)).add(_index.shl(24)).add(_number);
}
/**
 * Unlock a withdrew DAO cell
 *
 * @param txSkeleton
 * @param depositInput deposited DAO cell
 * @param withdrawInput withdrew DAO cell
 * @param toAddress
 * @param fromInfo
 * @param options
 */


async function unlock(txSkeleton, depositInput, withdrawInput, toAddress, fromInfo, {
  config = undefined,
  RpcClient = _rpc.RPC
} = {}) {
  config = config || (0, _configManager.getConfig)();

  _checkDaoScript(config);

  txSkeleton = _addDaoCellDep(txSkeleton, config);

  if (!config.SCRIPTS.DAO) {
    throw new Error("Provided config does not have DAO script setup!");
  }

  const cellProvider = txSkeleton.get("cellProvider");

  if (!cellProvider) {
    throw new Error("Cell provider is missing!");
  }

  const rpc = new RpcClient(cellProvider.uri);
  const typeScript = depositInput.cellOutput.type;
  const DAO_SCRIPT = config.SCRIPTS.DAO;

  if (!typeScript || typeScript.codeHash !== DAO_SCRIPT.CODE_HASH || typeScript.hashType !== DAO_SCRIPT.HASH_TYPE || depositInput.data !== DEPOSIT_DAO_DATA) {
    throw new Error("depositInput is not a DAO deposit cell.");
  }

  const withdrawTypeScript = withdrawInput.cellOutput.type;

  if (!withdrawTypeScript || withdrawTypeScript.codeHash !== DAO_SCRIPT.CODE_HASH || withdrawTypeScript.hashType !== DAO_SCRIPT.HASH_TYPE || withdrawInput.data === DEPOSIT_DAO_DATA) {
    throw new Error("withdrawInput is not a DAO withdraw cell.");
  } // calculate since & capacity (interest)


  const depositBlockHeader = await rpc.getHeader(depositInput.blockHash);
  const depositEpoch = parseEpochCompatible(depositBlockHeader.epoch); // const depositCapacity = BigInt(depositInput.cellOutput.capacity)

  const withdrawBlockHeader = await rpc.getHeader(withdrawInput.blockHash);
  const withdrawEpoch = parseEpochCompatible(withdrawBlockHeader.epoch);
  const withdrawFraction = withdrawEpoch.index.mul(depositEpoch.length);
  const depositFraction = depositEpoch.index.mul(withdrawEpoch.length);
  let depositedEpochs = withdrawEpoch.number.sub(depositEpoch.number);

  if (withdrawFraction.gt(depositFraction)) {
    depositedEpochs = depositedEpochs.add(1);
  }

  const lockEpochs = depositedEpochs.add(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE).sub(1).div(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE).mul(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE);
  const minimalSinceEpoch = {
    number: _bi.BI.from(depositEpoch.number.add(lockEpochs)),
    index: _bi.BI.from(depositEpoch.index),
    length: _bi.BI.from(depositEpoch.length)
  };
  const minimalSince = epochSinceCompatible(minimalSinceEpoch);
  const outputCapacity = "0x" + calculateMaximumWithdrawCompatible(withdrawInput, depositBlockHeader.dao, withdrawBlockHeader.dao).toString(16);
  const toScript = (0, _helpers.parseAddress)(toAddress, {
    config
  });
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push({
      cellOutput: {
        capacity: outputCapacity,
        lock: toScript,
        type: undefined
      },
      data: "0x",
      outPoint: undefined,
      blockHash: undefined
    });
  });
  const since = "0x" + minimalSince.toString(16);

  while (txSkeleton.get("witnesses").size < txSkeleton.get("inputs").size - 1) {
    txSkeleton = txSkeleton.update("witnesses", witnesses => witnesses.push("0x"));
  } // add header deps


  txSkeleton = txSkeleton.update("headerDeps", headerDeps => {
    return headerDeps.push(depositInput.blockHash, withdrawInput.blockHash);
  });
  const depositHeaderDepIndex = txSkeleton.get("headerDeps").size - 2; // setup input cell

  const defaultWitnessArgs = {
    inputType: _codec.bytes.hexify(_codec.number.Uint64LE.pack(depositHeaderDepIndex))
  };

  const defaultWitness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(defaultWitnessArgs));

  const fromLockScript = withdrawInput.cellOutput.lock;

  if ((0, _helper.isSecp256k1Blake160Script)(fromLockScript, config)) {
    txSkeleton = await _secp256k1_blake.default.setupInputCell(txSkeleton, withdrawInput, undefined, {
      config,
      since,
      defaultWitness
    });
  } else if ((0, _helper.isSecp256k1Blake160MultisigScript)(fromLockScript, config)) {
    txSkeleton = await _secp256k1_blake160_multisig.default.setupInputCell(txSkeleton, withdrawInput, fromInfo || (0, _helpers.generateAddress)(fromLockScript, {
      config
    }), {
      config,
      since,
      defaultWitness
    });
  } // remove change output by setupInputCell


  const lastOutputIndex = txSkeleton.get("outputs").size - 1;
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.remove(lastOutputIndex);
  }); // fix inputs / outputs / witnesses

  txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
    return fixedEntries.push({
      field: "inputs",
      index: txSkeleton.get("inputs").size - 1
    }, {
      field: "outputs",
      index: txSkeleton.get("outputs").size - 1
    }, {
      field: "witnesses",
      index: txSkeleton.get("witnesses").size - 1
    }, {
      field: "headerDeps",
      index: txSkeleton.get("headerDeps").size - 2
    });
  });
  return txSkeleton;
}
/**
 * calculate a withdraw dao cell minimal unlock since
 *
 * @param depositBlockHeaderEpoch depositBlockHeader.epoch
 * @param withdrawBlockHeaderEpoch withdrawBlockHeader.epoch
 */


function calculateDaoEarliestSince(depositBlockHeaderEpoch, withdrawBlockHeaderEpoch) {
  const result = calculateDaoEarliestSinceCompatible(depositBlockHeaderEpoch, withdrawBlockHeaderEpoch);
  return BigInt(result.toString());
}
/**
 * calculate a withdraw dao cell minimal unlock since
 *
 * @param depositBlockHeaderEpoch depositBlockHeader.epoch
 * @param withdrawBlockHeaderEpoch withdrawBlockHeader.epoch
 */


function calculateDaoEarliestSinceCompatible(depositBlockHeaderEpoch, withdrawBlockHeaderEpoch) {
  const depositEpoch = parseEpochCompatible(depositBlockHeaderEpoch);
  const withdrawEpoch = parseEpochCompatible(withdrawBlockHeaderEpoch);
  const withdrawFraction = withdrawEpoch.index.mul(depositEpoch.length);
  const depositFraction = depositEpoch.index.mul(withdrawEpoch.length);
  let depositedEpochs = withdrawEpoch.number.sub(depositEpoch.number);

  if (withdrawFraction.gt(depositFraction)) {
    depositedEpochs = depositedEpochs.add(1);
  }

  const lockEpochs = depositedEpochs.add(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE).sub(1).div(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE).mul(DAO_LOCK_PERIOD_EPOCHS_COMPATIBLE);
  const minimalSinceEpoch = {
    number: _bi.BI.from(depositEpoch.number.add(lockEpochs)),
    index: _bi.BI.from(depositEpoch.index),
    length: _bi.BI.from(depositEpoch.length)
  };
  return epochSinceCompatible(minimalSinceEpoch);
}

function _checkDaoScript(config) {
  const DAO_SCRIPT = config.SCRIPTS.DAO;

  if (!DAO_SCRIPT) {
    throw new Error("Provided config does not have DAO script setup!");
  }
}
/**
 *
 * @param {TransactionSkeleton} txSkeleton
 * @param {any} config
 * @returns {TransactionSkeleton} txSkeleton
 */


function _addDaoCellDep(txSkeleton, config) {
  const template = config.SCRIPTS.DAO;
  return (0, _helper.addCellDep)(txSkeleton, {
    outPoint: {
      txHash: template.TX_HASH,
      index: template.INDEX
    },
    depType: template.DEP_TYPE
  });
}

function extractDaoDataCompatible(dao) {
  if (!/^(0x)?([0-9a-fA-F]){64}$/.test(dao)) {
    throw new Error("Invalid dao format!");
  }

  const len = 8 * 2;
  const hex = dao.startsWith("0x") ? dao.slice(2) : dao;
  return ["c", "ar", "s", "u"].map((key, i) => {
    return {
      [key]: _codec.number.Uint64LE.unpack("0x" + hex.slice(len * i, len * (i + 1)))
    };
  }).reduce((result, c) => ({ ...result,
    ...c
  }), {});
}
/**
 * calculate maximum withdraw capacity when unlock
 *
 * @param withdrawCell withdrawCell or depositCell
 * @param depositDao depositBlockHeader.dao
 * @param withdrawDao withdrawBlockHeader.dao
 */


function calculateMaximumWithdraw(withdrawCell, depositDao, withdrawDao) {
  return calculateMaximumWithdrawCompatible(withdrawCell, depositDao, withdrawDao).toBigInt();
}
/**
 * calculate maximum withdraw capacity when unlock
 *
 * @param withdrawCell withdrawCell or depositCell
 * @param depositDao depositBlockHeader.dao
 * @param withdrawDao withdrawBlockHeader.dao
 */


function calculateMaximumWithdrawCompatible(withdrawCell, depositDao, withdrawDao) {
  const depositAR = _bi.BI.from(extractDaoDataCompatible(depositDao).ar);

  const withdrawAR = _bi.BI.from(extractDaoDataCompatible(withdrawDao).ar);

  const occupiedCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(withdrawCell));

  const outputCapacity = _bi.BI.from(withdrawCell.cellOutput.capacity);

  const countedCapacity = outputCapacity.sub(occupiedCapacity);
  const withdrawCountedCapacity = countedCapacity.mul(withdrawAR).div(depositAR);
  return withdrawCountedCapacity.add(occupiedCapacity);
}

var _default = {
  deposit,
  withdraw,
  unlock,
  calculateMaximumWithdraw,
  calculateMaximumWithdrawCompatible,
  calculateDaoEarliestSince,
  calculateDaoEarliestSinceCompatible,
  CellCollector,
  listDaoCells
};
exports.default = _default;
//# sourceMappingURL=dao.js.map