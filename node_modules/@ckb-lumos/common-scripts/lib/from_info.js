"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.multisigArgs = multisigArgs;
exports.parseFromInfo = parseFromInfo;
exports.serializeMultisigScript = serializeMultisigScript;

var _base = require("@ckb-lumos/base");

var _helpers = require("@ckb-lumos/helpers");

var _configManager = require("@ckb-lumos/config-manager");

var _codec = require("@ckb-lumos/codec");

const {
  CKBHasher
} = _base.utils;
/**
 * secp256k1_blake160_multisig script requires S, R, M, N and public key hashes
 * S must be zero now
 * and N equals to publicKeyHashes size
 * so only need to provide R, M and public key hashes
 */

/**
 *
 * @param params multisig script params
 * @returns serialized multisig script
 */
function serializeMultisigScript({
  R,
  M,
  publicKeyHashes
}) {
  if (R < 0 || R > 255) {
    throw new Error("`R` should be less than 256!");
  }

  if (M < 0 || M > 255) {
    throw new Error("`M` should be less than 256!");
  } // TODO: validate publicKeyHashes


  return "0x00" + ("00" + R.toString(16)).slice(-2) + ("00" + M.toString(16)).slice(-2) + ("00" + publicKeyHashes.length.toString(16)).slice(-2) + publicKeyHashes.map(h => h.slice(2)).join("");
}
/**
 *
 * @param serializedMultisigScript
 * @param since
 * @returns lock script args
 */


function multisigArgs(serializedMultisigScript, since) {
  let sinceLE = "0x";

  if (since != null) {
    sinceLE = _codec.bytes.hexify(_codec.number.Uint64LE.pack(since));
  }

  return new CKBHasher().update(serializedMultisigScript).digestHex().slice(0, 42) + sinceLE.slice(2);
}

function parseFromInfo(fromInfo, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  let fromScript;
  let multisigScript;
  let destroyable;
  let customData;

  if (typeof fromInfo === "string") {
    // fromInfo is an address
    fromScript = (0, _helpers.parseAddress)(fromInfo, {
      config
    });
  } else {
    if ("R" in fromInfo) {
      const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;

      if (!template) {
        throw new Error("Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!");
      }

      multisigScript = serializeMultisigScript(fromInfo);
      const fromScriptArgs = multisigArgs(multisigScript, fromInfo.since);
      fromScript = {
        codeHash: template.CODE_HASH,
        hashType: template.HASH_TYPE,
        args: fromScriptArgs
      };
    } else if ("address" in fromInfo) {
      const template = config.SCRIPTS.ANYONE_CAN_PAY;

      if (!template) {
        throw new Error("Provided config does not have ANYONE_CAN_PAY script setup!");
      }

      const address = fromInfo.address;
      fromScript = (0, _helpers.parseAddress)(address, {
        config
      });
      destroyable = fromInfo.destroyable;

      if (fromScript.codeHash !== template.CODE_HASH || fromScript.hashType !== template.HASH_TYPE) {
        throw new Error(`fromInfo.address is not ANYONE_CAN_PAY address!`);
      }
    } else if ("script" in fromInfo) {
      fromScript = fromInfo.script;
      customData = fromInfo.customData;
    } else {
      throw new Error("Invalid fromInfo format!");
    }
  }

  return {
    fromScript,
    multisigScript,
    destroyable,
    customData
  };
}
//# sourceMappingURL=from_info.js.map