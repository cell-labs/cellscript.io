"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CellCollector = void 0;
exports.checkLimit = checkLimit;
exports.default = void 0;
exports.injectCapacity = injectCapacity;
exports.prepareSigningEntries = prepareSigningEntries;
exports.setupInputCell = setupInputCell;
exports.setupOutputCell = setupOutputCell;
exports.withdraw = withdraw;

var _base = require("@ckb-lumos/base");

var _codec = require("@ckb-lumos/codec");

var _configManager = require("@ckb-lumos/config-manager");

var _helpers = require("@ckb-lumos/helpers");

var _immutable = require("immutable");

var _bi = require("@ckb-lumos/bi");

var _from_info = require("./from_info");

var _helper = require("./helper");

const {
  ScriptValue
} = _base.values;
const {
  CKBHasher,
  ckbHash
} = _base.utils;
const CellCollector = class CellCollector {
  constructor(fromInfo, cellProvider, {
    config = undefined,
    queryOptions = {}
  } = {}) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }

    config = config || (0, _configManager.getConfig)();
    this.fromScript = (0, _from_info.parseFromInfo)(fromInfo, {
      config
    }).fromScript;
    this.config = config;
    queryOptions = { ...queryOptions,
      lock: this.fromScript,
      type: queryOptions.type || "empty"
    };
    this.cellCollector = cellProvider.collector(queryOptions);
  }

  async *collect() {
    if (!(0, _helper.isAcpScript)(this.fromScript, this.config)) {
      return;
    }

    for await (const inputCell of this.cellCollector.collect()) {
      yield inputCell;
    }
  }

};
exports.CellCollector = CellCollector;

async function setupInputCell(txSkeleton, inputCell, _fromInfo, {
  config = undefined,
  defaultWitness = "0x",
  since = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const inputLock = inputCell.cellOutput.lock;

  if (!(0, _helper.isAcpScript)(inputLock, config)) {
    throw new Error("Not anyone-can-pay input!");
  } // add inputCell to txSkeleton


  txSkeleton = txSkeleton.update("inputs", inputs => {
    return inputs.push(inputCell);
  });

  if (since) {
    txSkeleton = txSkeleton.update("inputSinces", inputSinces => {
      return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
    });
  }

  txSkeleton = txSkeleton.update("witnesses", witnesses => {
    return witnesses.push(defaultWitness);
  });
  const outputCell = {
    cellOutput: {
      capacity: inputCell.cellOutput.capacity,
      lock: inputCell.cellOutput.lock,
      type: inputCell.cellOutput.type
    },
    data: inputCell.data
  };
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push(outputCell);
  });
  txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
    return fixedEntries.push({
      field: "outputs",
      index: txSkeleton.get("outputs").size - 1
    });
  });
  const template = config.SCRIPTS.ANYONE_CAN_PAY;

  if (!template) {
    throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
  }

  const scriptOutPoint = {
    txHash: template.TX_HASH,
    index: template.INDEX
  }; // add cell_dep

  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
    outPoint: scriptOutPoint,
    depType: template.DEP_TYPE
  }); // add witness

  const firstIndex = txSkeleton.get("inputs").findIndex(input => {
    return new ScriptValue(input.cellOutput.lock, {
      validate: false
    }).equals(new ScriptValue(inputLock, {
      validate: false
    }));
  });

  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", witnesses => {
        return witnesses.push("0x");
      });
    }

    let witness = txSkeleton.get("witnesses").get(firstIndex);
    const newWitnessArgs = {
      /* 65-byte zeros in hex */
      lock: _helper.SECP_SIGNATURE_PLACEHOLDER
    };

    if (witness !== "0x") {
      const witnessArgs = _base.blockchain.WitnessArgs.unpack(_codec.bytes.bytify(witness));

      const lock = witnessArgs.lock;

      if (!!lock && !!newWitnessArgs.lock && !_codec.bytes.equal(lock, newWitnessArgs.lock)) {
        throw new Error("Lock field in first witness is set aside for signature!");
      }

      const inputType = witnessArgs.inputType;

      if (inputType) {
        newWitnessArgs.inputType = inputType;
      }

      const outputType = witnessArgs.outputType;

      if (outputType) {
        newWitnessArgs.outputType = outputType;
      }
    }

    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));
    txSkeleton = txSkeleton.update("witnesses", witnesses => {
      return witnesses.set(firstIndex, witness);
    });
  }

  return txSkeleton;
} // export for tests


function checkLimit(acpArgs, capacity) {
  const _capacity = _bi.BI.from(capacity);

  let minimalAmount;
  let minimalCapacity;

  if (acpArgs.length >= 46) {
    minimalAmount = _bi.BI.from(10).pow("0x" + acpArgs.slice(44, 46));
  }

  if (acpArgs.length >= 44) {
    // should convert to shannons
    const multiplier = _bi.BI.from(10).pow("0x" + acpArgs.slice(42, 44));

    const multiplicand = _bi.BI.from(10).pow(8);

    minimalCapacity = multiplier.mul(multiplicand);
  } // Both minimalAmount & minimalCapacity OR only minimalCapacity


  if (minimalCapacity && minimalAmount) {
    //check if undefined
    if (_capacity.lt(minimalCapacity)) {
      throw new Error(`capacity(${capacity}) less than toAddress minimal capacity limit(${minimalCapacity}), and amount less then toAddress minimal amount limit(${minimalAmount})! If you want to transfer sudt, maybe sudt.transfer can help you.`);
    }
  } else if (minimalCapacity) {
    //check if undefined
    if (_capacity.lt(minimalCapacity)) {
      throw new Error(`capacity(${capacity}) less than toAddress minimal capacity limit(${minimalCapacity})!`);
    }
  }
}

async function setupOutputCell(txSkeleton, outputCell, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const toScript = outputCell.cellOutput.lock;

  const capacity = _bi.BI.from(outputCell.cellOutput.capacity);

  checkLimit(toScript.args, capacity.toString());
  const cellProvider = txSkeleton.get("cellProvider");

  if (!cellProvider) {
    throw new Error(`Cell Provider is missing!`);
  }

  const toAddress = (0, _helpers.generateAddress)(toScript, {
    config
  });
  const toAddressCellCollector = new CellCollector(toAddress, cellProvider, {
    config
  });
  const toAddressInput = (await toAddressCellCollector.collect().next()).value;
  let outputCapacity = capacity;

  if (toAddressInput) {
    outputCapacity = capacity.add(toAddressInput.cellOutput.capacity);
    txSkeleton = txSkeleton.update("inputs", inputs => {
      return inputs.push(toAddressInput);
    });
    txSkeleton = txSkeleton.update("witnesses", witnesses => {
      return witnesses.push("0x");
    });
  }

  outputCell.cellOutput.capacity = "0x" + outputCapacity.toString(16);
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push(outputCell);
  });

  if (toAddressInput) {
    const template = config.SCRIPTS.ANYONE_CAN_PAY;

    if (!template) {
      throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
    }

    const scriptOutPoint = {
      txHash: template.TX_HASH,
      index: template.INDEX
    }; // add cell_dep

    txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
      outPoint: scriptOutPoint,
      depType: template.DEP_TYPE
    });
  }

  return txSkeleton;
}

async function injectCapacity(cellCollector, txSkeleton, outputIndex, capacity, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();

  if (outputIndex >= txSkeleton.get("outputs").size) {
    throw new Error(`Invalid output index!`);
  }

  let _capacity = _bi.BI.from(capacity);

  const template = config.SCRIPTS.ANYONE_CAN_PAY;

  if (!template) {
    throw new Error(`Provided config does not have ANYONE_CAN_PAY script setup!`);
  }

  const fromScript = cellCollector.fromScript;
  /*
   * First, check if there is any output cells that contains enough capacity
   * for us to tinker with.
   *
   * TODO: the solution right now won't cover all cases, some outputs before the
   * last output might still be tinkerable, right now we are working on the
   * simple solution, later we can change this for more optimizations.
   */

  const lastFreezedOutput = txSkeleton.get("fixedEntries").filter(({
    field
  }) => field === "outputs").maxBy(({
    index
  }) => index);
  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;

  for (; i < txSkeleton.get("outputs").size && _capacity.gt(0); i++) {
    const output = txSkeleton.get("outputs").get(i);

    if (new ScriptValue(output.cellOutput.lock, {
      validate: false
    }).equals(new ScriptValue(fromScript, {
      validate: false
    }))) {
      const cellCapacity = _bi.BI.from(output.cellOutput.capacity);

      const availableCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(output)); // should maintain minimal cell capcity in anyone-can-pay output

      const deductCapacity = _capacity.gte(availableCapacity) ? availableCapacity : _capacity;
      _capacity = _capacity.sub(deductCapacity);
      output.cellOutput.capacity = "0x" + cellCapacity.sub(deductCapacity).toString(16);
    }
  } // Remove all output cells with capacity equal to 0


  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.filter(output => !_bi.BI.from(output.cellOutput.capacity).eq(0));
  });

  const getInputKey = input => `${input.outPoint.txHash}_${input.outPoint.index}`;

  if (_capacity.gt(0)) {
    const changeCell = {
      cellOutput: {
        capacity: "0x0",
        lock: fromScript,
        type: undefined
      },
      data: "0x",
      outPoint: undefined,
      blockHash: undefined
    };

    let changeCapacity = _bi.BI.from(0);

    const minimalChangeCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell));

    let previousInputs = (0, _immutable.Set)();

    for (const input of txSkeleton.get("inputs")) {
      previousInputs = previousInputs.add(getInputKey(input));
    } // Are all from same lock script and type script, so only need one change cell


    for await (const inputCell of cellCollector.collect()) {
      if (previousInputs.has(getInputKey(inputCell))) {
        continue;
      }

      txSkeleton = await setupInputCell(txSkeleton, inputCell, undefined, {
        config
      });
      const lastOutputIndex = txSkeleton.get("outputs").size - 1;
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.remove(lastOutputIndex);
      });
      const fixedEntryIndex = txSkeleton.get("fixedEntries").findIndex(fixedEntry => {
        return fixedEntry.field === "outputs" && fixedEntry.index === lastOutputIndex;
      });

      if (fixedEntryIndex >= 0) {
        txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
          return fixedEntries.remove(fixedEntryIndex);
        });
      }

      const inputCapacity = _bi.BI.from(inputCell.cellOutput.capacity);

      let deductCapacity = inputCapacity;

      if (deductCapacity.gt(_capacity)) {
        deductCapacity = _capacity;
      }

      _capacity = _capacity.sub(deductCapacity);
      changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));

      if (_capacity.eq(0) && changeCapacity.gte(minimalChangeCapacity)) {
        break;
      }

      changeCell.cellOutput.capacity = "0x" + changeCapacity.toString(16);
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.push(changeCell);
      });
    }

    if (_capacity.gt(0) || changeCapacity < minimalChangeCapacity) {
      throw new Error(`Not enough capacity in from address!`);
    }

    changeCell.cellOutput.capacity = "0x" + changeCapacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", outputs => {
      return outputs.push(changeCell);
    });
  }

  return txSkeleton;
}

function prepareSigningEntries(txSkeleton, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const scriptType = "ANYONE_CAN_PAY";
  const template = config.SCRIPTS[scriptType];

  if (!template) {
    throw new Error(`Provided config does not have ${scriptType} script setup!`);
  }

  let processedArgs = (0, _immutable.Set)();
  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);
  const txHash = ckbHash(_base.blockchain.RawTransaction.pack(tx));
  const inputs = txSkeleton.get("inputs");
  const witnesses = txSkeleton.get("witnesses");
  let signingEntries = txSkeleton.get("signingEntries");

  for (let i = 0; i < inputs.size; i++) {
    const input = inputs.get(i);

    if (template.CODE_HASH === input.cellOutput.lock.codeHash && template.HASH_TYPE === input.cellOutput.lock.hashType && !processedArgs.has(input.cellOutput.lock.args)) {
      processedArgs = processedArgs.add(input.cellOutput.lock.args); // skip if input sum capcity <= output sum capacity
      // and input sum amount <= output sum amount

      const outputs = txSkeleton.get("outputs").filter(output => {
        return new ScriptValue(output.cellOutput.lock, {
          validate: false
        }).equals(new ScriptValue(input.cellOutput.lock, {
          validate: false
        }));
      });
      const sumOfOutputCapacity = outputs.map(output => _bi.BI.from(output.cellOutput.capacity)).reduce((result, c) => result.add(c), _bi.BI.from(0));
      const sumOfOutputAmount = outputs.filter(output => output.data !== "0x").map(output => _codec.number.Uint128LE.unpack(output.data)).reduce((result, c) => result.add(c), _bi.BI.from(0));
      const fInputs = inputs.filter(i => {
        return new ScriptValue(i.cellOutput.lock, {
          validate: false
        }).equals(new ScriptValue(input.cellOutput.lock, {
          validate: false
        }));
      });
      const sumOfInputCapacity = fInputs.map(i => _bi.BI.from(i.cellOutput.capacity)).reduce((result, c) => result.add(c), _bi.BI.from(0));
      const sumOfInputAmount = fInputs.filter(i => i.data !== "0x").map(i => _bi.BI.from(_codec.number.Uint128LE.unpack(i.data))).reduce((result, c) => result.add(c), _bi.BI.from(0));

      if (sumOfInputCapacity.lte(sumOfOutputCapacity) && sumOfInputAmount.lte(sumOfOutputAmount)) {
        continue;
      }

      const lockValue = new _base.values.ScriptValue(input.cellOutput.lock, {
        validate: false
      });
      const hasher = new CKBHasher();
      hasher.update(txHash);

      if (i >= witnesses.size) {
        throw new Error(`The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`);
      }

      (0, _helper.hashWitness)(hasher, witnesses.get(i));

      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
        const otherInput = inputs.get(j);

        if (lockValue.equals(new _base.values.ScriptValue(otherInput.cellOutput.lock, {
          validate: false
        }))) {
          (0, _helper.hashWitness)(hasher, witnesses.get(j));
        }
      }

      for (let j = inputs.size; j < witnesses.size; j++) {
        (0, _helper.hashWitness)(hasher, witnesses.get(j));
      }

      const signingEntry = {
        type: "witness_args_lock",
        index: i,
        message: hasher.digestHex()
      };
      signingEntries = signingEntries.push(signingEntry);
    }
  }

  txSkeleton = txSkeleton.set("signingEntries", signingEntries);
  return txSkeleton;
}

async function withdraw(txSkeleton, fromInput, toAddress, capacity, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)(); // from input must be a anyone-can-pay script

  if (!(0, _helper.isAcpScript)(fromInput.cellOutput.lock, config)) {
    throw new Error(`fromInput is not a ANYONE_CAN_PAY cell!`);
  } // check capacity


  const _capacity = _bi.BI.from(capacity);

  const fromInputCapacity = _bi.BI.from(fromInput.cellOutput.capacity);

  const inputMinimalCellCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(fromInput));

  if (!(_capacity.gte(0) && _capacity.lte(fromInputCapacity.sub(inputMinimalCellCapacity)) || _capacity.eq(fromInputCapacity))) {
    throw new Error(`capacity must be in [0, ${fromInputCapacity.sub(inputMinimalCellCapacity)}] or ${fromInputCapacity} !`);
  }

  const toScript = (0, _helpers.parseAddress)(toAddress, {
    config
  });
  const targetOutput = {
    cellOutput: {
      capacity: "0x" + capacity.toString(16),
      lock: toScript,
      type: undefined
    },
    data: "0x",
    outPoint: undefined,
    blockHash: undefined
  };

  if ((0, _helper.isAcpScript)(toScript, config)) {
    checkLimit(toScript.args, capacity);
    const cellProvider = txSkeleton.get("cellProvider");

    if (!cellProvider) {
      throw new Error(`Cell Provider is missing!`);
    }

    const toAddressCellCollector = new CellCollector(toAddress, cellProvider, {
      config
    });
    const toAddressInput = (await toAddressCellCollector.collect().next()).value;

    if (!toAddressInput) {
      throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);
    }

    const outputCapacity = _capacity.add(toAddressInput.cellOutput.capacity);

    targetOutput.cellOutput.capacity = "0x" + outputCapacity.toString(16);
    txSkeleton = txSkeleton.update("inputs", inputs => {
      return inputs.push(toAddressInput);
    });
    txSkeleton = txSkeleton.update("witnesses", witnesses => {
      return witnesses.push("0x");
    });
  }

  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push(targetOutput);
  });
  txSkeleton = await setupInputCell(txSkeleton, fromInput, (0, _helpers.generateAddress)(fromInput.cellOutput.lock, {
    config
  }), {
    config
  }); // remove output and fixedEntry added by `setupInputCell`

  const lastOutputIndex = txSkeleton.get("outputs").size - 1;
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.remove(lastOutputIndex);
  });
  const fixedEntryIndex = txSkeleton.get("fixedEntries").findIndex(fixedEntry => {
    return fixedEntry.field === "outputs" && fixedEntry.index === lastOutputIndex;
  });

  if (fixedEntryIndex >= 0) {
    txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
      return fixedEntries.remove(fixedEntryIndex);
    });
  }

  if (!_capacity.eq(fromInputCapacity)) {
    txSkeleton = txSkeleton.update("outputs", outputs => {
      return outputs.push({
        cellOutput: {
          capacity: "0x" + fromInputCapacity.sub(capacity).toString(16),
          lock: fromInput.cellOutput.lock,
          type: fromInput.cellOutput.type
        },
        data: fromInput.data
      });
    });
  }

  return txSkeleton;
}

var _default = {
  CellCollector,
  setupInputCell,
  setupOutputCell,
  injectCapacity,
  prepareSigningEntries,
  withdraw
};
exports.default = _default;
//# sourceMappingURL=anyone_can_pay.js.map