{"version":3,"file":"sudt.js","names":["computeScriptHash","utils","ScriptValue","values","issueToken","txSkeleton","fromInfo","amount","capacity","tipHeader","config","undefined","getConfig","template","SCRIPTS","SUDT","Error","addCellDep","outPoint","txHash","TX_HASH","index","INDEX","depType","DEP_TYPE","fromScript","parseFromInfo","toScript","sudtTypeScript","codeHash","CODE_HASH","hashType","HASH_TYPE","args","targetOutput","cellOutput","lock","type","data","bytes","hexify","number","Uint128LE","pack","blockHash","minimalCellCapacityCompatible","_capacity","BI","from","toString","update","outputs","push","outputIndex","get","size","fixedEntries","field","common","injectCapacity","transfer","fromInfos","sudtToken","toAddress","changeAddress","LocktimePoolCellCollector","LocktimeCellCollector","splitChangeCell","_amount","SUDT_SCRIPT","length","parseAddress","fromScripts","map","changeOutputLockScript","lte","sudtType","_generateSudtScript","cellProvider","toAddressInputCapacity","toAddressInputAmount","isAcpScript","toAddressCellCollector","AnyoneCanPayCellCollector","queryOptions","toAddressInput","collect","next","value","inputs","witnesses","unpack","add","changeCell","changeCellWithoutSudt","changeCapacity","changeAmount","previousInputs","Set","input","cellCollectorInfos","List","forEach","locktimePoolCellCollector","cellCollector","secpCollector","secp256k1Blake160","CellCollector","multisigCollector","secp256k1Blake160Multisig","acpCollector","anyoneCanPay","isAnyoneCanPay","destroyable","locktimeCellCollector","inputCell","key","has","setupInputCell","lastOutputIndex","remove","fixedEntryIndex","findIndex","fixedEntry","inputCapacity","inputAmount","deductCapacity","sub","deductAmount","gt","currentChangeCapacity","currentChangeAmount","acpChangeCell","eq","changeOutputIndex","output","validate","equals","gte","originOutput","clonedOutput","JSON","parse","stringify","minimalChangeCellCapcaity","minimalChangeCellWithoutSudtCapacity","splitFlag","set","lt","token","ownerForSudt","lockHash"],"sources":["../src/sudt.ts"],"sourcesContent":["import { addCellDep, isAcpScript } from \"./helper\";\nimport {\n  utils,\n  Hash,\n  Address,\n  Cell,\n  Script,\n  Header,\n  CellCollector as CellCollectorInterface,\n  values,\n} from \"@ckb-lumos/base\";\nconst { computeScriptHash } = utils;\nimport secp256k1Blake160Multisig from \"./secp256k1_blake160_multisig\";\nimport { FromInfo, parseFromInfo } from \"./from_info\";\nimport common from \"./common\";\nimport {\n  parseAddress,\n  TransactionSkeletonType,\n  Options,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport { Set, List } from \"immutable\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nimport { CellCollector as LocktimeCellCollector } from \"./locktime_pool\";\nimport anyoneCanPay, {\n  CellCollector as AnyoneCanPayCellCollector,\n} from \"./anyone_can_pay\";\nconst { ScriptValue } = values;\nimport secp256k1Blake160 from \"./secp256k1_blake160\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { bytes, number } from \"@ckb-lumos/codec\";\n\nexport type Token = Hash;\n\n/**\n * Issue an sUDT cell\n *\n * @param txSkeleton\n * @param fromInfo\n * @param amount\n * @param capacity\n * @param tipHeader\n * @param options\n */\nexport async function issueToken(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  amount: BIish,\n  capacity?: BIish,\n  tipHeader?: Header,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  const template = config.SCRIPTS.SUDT;\n\n  if (!template) {\n    throw new Error(\"Provided config does not have SUDT script setup!\");\n  }\n\n  txSkeleton = addCellDep(txSkeleton, {\n    outPoint: {\n      txHash: template.TX_HASH,\n      index: template.INDEX,\n    },\n    depType: template.DEP_TYPE,\n  });\n\n  const fromScript = parseFromInfo(fromInfo, { config }).fromScript;\n\n  const toScript = fromScript;\n\n  const sudtTypeScript = {\n    codeHash: template.CODE_HASH,\n    hashType: template.HASH_TYPE,\n    args: computeScriptHash(fromScript),\n  };\n\n  const targetOutput: Cell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: toScript,\n      type: sudtTypeScript,\n    },\n    data: bytes.hexify(number.Uint128LE.pack(amount)),\n    outPoint: undefined,\n    blockHash: undefined,\n  };\n\n  if (!capacity) {\n    capacity = minimalCellCapacityCompatible(targetOutput);\n  }\n  const _capacity = BI.from(capacity);\n  targetOutput.cellOutput.capacity = \"0x\" + _capacity.toString(16);\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push(targetOutput);\n  });\n\n  const outputIndex = txSkeleton.get(\"outputs\").size - 1;\n\n  // fix entry\n  txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: outputIndex,\n    });\n  });\n\n  txSkeleton = await common.injectCapacity(\n    txSkeleton,\n    [fromInfo],\n    BI.from(BI.from(targetOutput.cellOutput.capacity)),\n    undefined,\n    tipHeader,\n    {\n      config,\n    }\n  );\n\n  return txSkeleton;\n}\n\n/**\n *\n * @param txSkeleton\n * @param fromInfos\n * @param sudtToken\n * @param toAddress\n * @param amount\n * @param changeAddress if not provided, will use first fromInfo\n * @param capacity\n * @param tipHeader\n * @param options When `splitChangeCell = true` && change amount > 0 && change capacity >= minimalCellCapacity(change cell with sudt) + minimalCellCapacity(change cell without sudt), change cell will split to two change cells, one with sudt and one without.\n */\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  sudtToken: Token,\n  toAddress: Address,\n  amount: BIish,\n  changeAddress?: Address,\n  capacity?: BIish,\n  tipHeader?: Header,\n  {\n    config = undefined,\n    LocktimePoolCellCollector = LocktimeCellCollector,\n    splitChangeCell = false,\n  }: Options & {\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    LocktimePoolCellCollector?: any;\n    splitChangeCell?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  let _amount = BI.from(amount);\n  let _capacity = capacity ? BI.from(capacity) : undefined;\n\n  const SUDT_SCRIPT = config.SCRIPTS.SUDT;\n\n  if (!SUDT_SCRIPT) {\n    throw new Error(\"Provided config does not have SUDT script setup!\");\n  }\n\n  if (fromInfos.length === 0) {\n    throw new Error(\"`fromInfos` can't be empty!\");\n  }\n\n  if (!toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n  const toScript = parseAddress(toAddress, { config });\n\n  const fromScripts: Script[] = fromInfos.map(\n    (fromInfo) => parseFromInfo(fromInfo, { config }).fromScript\n  );\n  const changeOutputLockScript = changeAddress\n    ? parseAddress(changeAddress, { config })\n    : fromScripts[0];\n\n  if (_amount.lte(0)) {\n    throw new Error(\"amount must be greater than 0\");\n  }\n\n  const sudtType = _generateSudtScript(sudtToken, config);\n\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(\"Cell provider is missing!\");\n  }\n\n  // if toScript is an anyone-can-pay script\n  let toAddressInputCapacity: BI = BI.from(0);\n  let toAddressInputAmount: BI = BI.from(0);\n  if (isAcpScript(toScript, config)) {\n    const toAddressCellCollector = new AnyoneCanPayCellCollector(\n      toAddress,\n      cellProvider,\n      {\n        config,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\",\n        },\n      }\n    );\n\n    const toAddressInput: Cell | void = (\n      await toAddressCellCollector.collect().next()\n    ).value;\n    if (!toAddressInput) {\n      throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);\n    }\n\n    txSkeleton = txSkeleton.update(\"inputs\", (inputs) => {\n      return inputs.push(toAddressInput);\n    });\n\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => {\n      return witnesses.push(\"0x\");\n    });\n\n    toAddressInputCapacity = BI.from(toAddressInput.cellOutput.capacity);\n    toAddressInputAmount = number.Uint128LE.unpack(toAddressInput.data);\n  }\n\n  const targetOutput: Cell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: toScript,\n      type: sudtType,\n    },\n    data: bytes.hexify(number.Uint128LE.pack(_amount)),\n    outPoint: undefined,\n    blockHash: undefined,\n  };\n  if (isAcpScript(toScript, config)) {\n    if (!_capacity) {\n      _capacity = BI.from(0);\n    }\n    targetOutput.cellOutput.capacity =\n      \"0x\" + toAddressInputCapacity.add(_capacity).toString(16);\n    targetOutput.data = bytes.hexify(\n      number.Uint128LE.pack(toAddressInputAmount.add(_amount))\n    );\n  } else {\n    if (!_capacity) {\n      _capacity = BI.from(minimalCellCapacityCompatible(targetOutput));\n    }\n    targetOutput.cellOutput.capacity = \"0x\" + _capacity.toString(16);\n  }\n\n  // collect cells with which includes sUDT info\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push(targetOutput);\n  });\n\n  txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: txSkeleton.get(\"outputs\").size - 1,\n    });\n  });\n\n  txSkeleton = addCellDep(txSkeleton, {\n    outPoint: {\n      txHash: SUDT_SCRIPT.TX_HASH,\n      index: SUDT_SCRIPT.INDEX,\n    },\n    depType: SUDT_SCRIPT.DEP_TYPE,\n  });\n\n  // collect cells\n  const changeCell: Cell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: changeOutputLockScript,\n      type: sudtType,\n    },\n    data: bytes.hexify(number.Uint128LE.pack(0)),\n    outPoint: undefined,\n    blockHash: undefined,\n  };\n  const changeCellWithoutSudt: Cell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: changeOutputLockScript,\n      type: undefined,\n    },\n    data: \"0x\",\n    outPoint: undefined,\n    blockHash: undefined,\n  };\n  let changeCapacity = BI.from(0);\n  let changeAmount = BI.from(0);\n  let previousInputs = Set<string>();\n  for (const input of txSkeleton.get(\"inputs\")) {\n    previousInputs = previousInputs.add(\n      `${input.outPoint!.txHash}_${input.outPoint!.index}`\n    );\n  }\n  let cellCollectorInfos: List<{\n    cellCollector: CellCollectorInterface;\n    index: number;\n    isAnyoneCanPay?: boolean;\n    destroyable?: boolean;\n  }> = List();\n  if (tipHeader) {\n    fromInfos.forEach((fromInfo, index) => {\n      const locktimePoolCellCollector = new LocktimePoolCellCollector(\n        fromInfo,\n        cellProvider,\n        {\n          config,\n          tipHeader,\n          queryOptions: {\n            type: sudtType,\n            data: \"any\",\n          },\n        }\n      );\n\n      cellCollectorInfos = cellCollectorInfos.push({\n        cellCollector: locktimePoolCellCollector,\n        index,\n      });\n    });\n  }\n  fromInfos.forEach((fromInfo, index) => {\n    const secpCollector = new secp256k1Blake160.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\",\n        },\n      }\n    );\n    const multisigCollector = new secp256k1Blake160Multisig.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\",\n        },\n      }\n    );\n    const acpCollector = new anyoneCanPay.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\",\n        },\n      }\n    );\n\n    cellCollectorInfos = cellCollectorInfos.push(\n      {\n        cellCollector: secpCollector,\n        index,\n      },\n      {\n        cellCollector: multisigCollector,\n        index,\n      },\n      {\n        cellCollector: acpCollector,\n        index,\n        isAnyoneCanPay: true,\n        destroyable: parseFromInfo(fromInfo, { config }).destroyable,\n      }\n    );\n  });\n  if (tipHeader) {\n    fromInfos.forEach((fromInfo, index) => {\n      const locktimeCellCollector = new LocktimePoolCellCollector(\n        fromInfo,\n        cellProvider,\n        {\n          config,\n          tipHeader,\n        }\n      );\n\n      cellCollectorInfos = cellCollectorInfos.push({\n        cellCollector: locktimeCellCollector,\n        index,\n      });\n    });\n  }\n  fromInfos.forEach((fromInfo, index) => {\n    const secpCollector = new secp256k1Blake160.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n      }\n    );\n    const multisigCollector = new secp256k1Blake160Multisig.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n      }\n    );\n    const acpCollector = new anyoneCanPay.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n      }\n    );\n\n    cellCollectorInfos = cellCollectorInfos.push(\n      {\n        cellCollector: secpCollector,\n        index,\n      },\n      {\n        cellCollector: multisigCollector,\n        index,\n      },\n      {\n        cellCollector: acpCollector,\n        index,\n        isAnyoneCanPay: true,\n        destroyable: parseFromInfo(fromInfo, { config }).destroyable,\n      }\n    );\n  });\n  for (const {\n    index,\n    cellCollector,\n    isAnyoneCanPay,\n    destroyable,\n  } of cellCollectorInfos) {\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      const key = `${inputCell.outPoint!.txHash}_${inputCell.outPoint!.index}`;\n      if (previousInputs.has(key)) {\n        continue;\n      }\n      previousInputs = previousInputs.add(key);\n\n      const fromInfo = fromInfos[index];\n      txSkeleton = await common.setupInputCell(\n        txSkeleton,\n        inputCell,\n        fromInfo,\n        {\n          config,\n        }\n      );\n      // remove output which added by `setupInputCell`\n      const lastOutputIndex: number = txSkeleton.get(\"outputs\").size - 1;\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.remove(lastOutputIndex);\n      });\n      // remove output fixedEntry\n      const fixedEntryIndex: number = txSkeleton\n        .get(\"fixedEntries\")\n        .findIndex((fixedEntry) => {\n          return (\n            fixedEntry.field === \"outputs\" &&\n            fixedEntry.index === lastOutputIndex\n          );\n        });\n      if (fixedEntryIndex >= 0) {\n        txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n          return fixedEntries.remove(fixedEntryIndex);\n        });\n      }\n\n      const inputCapacity: BI = BI.from(inputCell.cellOutput.capacity);\n      const inputAmount: BI = inputCell.cellOutput.type\n        ? number.Uint128LE.unpack(inputCell.data)\n        : BI.from(0);\n      let deductCapacity: BI =\n        isAnyoneCanPay && !destroyable\n          ? inputCapacity.sub(minimalCellCapacityCompatible(inputCell))\n          : inputCapacity;\n      let deductAmount: BI = inputAmount;\n      if (deductCapacity.gt(_capacity)) {\n        deductCapacity = BI.from(_capacity);\n      }\n      _capacity = _capacity.sub(deductCapacity);\n      const currentChangeCapacity: BI = inputCapacity.sub(deductCapacity);\n      if (!isAnyoneCanPay || (isAnyoneCanPay && destroyable)) {\n        changeCapacity = changeCapacity.add(currentChangeCapacity);\n      }\n      if (deductAmount.gt(_amount)) {\n        deductAmount = _amount;\n      }\n      _amount = _amount.sub(deductAmount);\n      const currentChangeAmount: BI = inputAmount.sub(deductAmount);\n      if (!isAnyoneCanPay || (isAnyoneCanPay && destroyable)) {\n        changeAmount = changeAmount.add(currentChangeAmount);\n      }\n\n      if (isAnyoneCanPay && !destroyable) {\n        const acpChangeCell: Cell = {\n          cellOutput: {\n            capacity: \"0x\" + currentChangeCapacity.toString(16),\n            lock: inputCell.cellOutput.lock,\n            type: inputCell.cellOutput.type,\n          },\n          data: inputCell.cellOutput.type\n            ? bytes.hexify(number.Uint128LE.pack(currentChangeAmount))\n            : \"0x\",\n        };\n\n        txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n          return outputs.push(acpChangeCell);\n        });\n\n        if (inputCell.cellOutput.type) {\n          txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n            return fixedEntries.push({\n              field: \"outputs\",\n              index: txSkeleton.get(\"outputs\").size - 1,\n            });\n          });\n        }\n      }\n\n      // changeAmount = 0n, the change output no need to include sudt type script\n      if (\n        _capacity.eq(0) &&\n        _amount.eq(0) &&\n        ((changeCapacity.eq(0) && changeAmount.eq(0)) ||\n          (changeCapacity.gt(\n            minimalCellCapacityCompatible(changeCellWithoutSudt)\n          ) &&\n            changeAmount.eq(0)))\n      ) {\n        changeCell.cellOutput.type = undefined;\n        changeCell.data = \"0x\";\n        break;\n      }\n      if (\n        _capacity.eq(0) &&\n        _amount.eq(0) &&\n        changeCapacity.gt(\n          minimalCellCapacityCompatible(changeCellWithoutSudt)\n        ) &&\n        changeAmount.gt(0)\n      ) {\n        break;\n      }\n    }\n  }\n\n  // if change cell is an anyone-can-pay cell and exists in txSkeleton.get(\"outputs\") and not in fixedEntries\n  // 1. change lock script is acp\n  // 2. lock and type are equal to output OutputA in outputs\n  // 3. OutputA is not fixed.\n  let changeOutputIndex = -1;\n  if (\n    isAcpScript(changeCell.cellOutput.lock, config) &&\n    (changeOutputIndex = txSkeleton.get(\"outputs\").findIndex((output) => {\n      return (\n        new ScriptValue(changeCell.cellOutput.lock, {\n          validate: false,\n        }).equals(\n          new ScriptValue(output.cellOutput.lock, { validate: false })\n        ) &&\n        ((changeAmount.eq(0) &&\n          !changeCell.cellOutput.type &&\n          !output.cellOutput.type) ||\n          (changeAmount.gte(0) &&\n            !!changeCell.cellOutput.type &&\n            !!output.cellOutput.type &&\n            new ScriptValue(changeCell.cellOutput.type, {\n              validate: false,\n            }).equals(\n              new ScriptValue(output.cellOutput.type, { validate: false })\n            )))\n      );\n    })) !== -1 &&\n    txSkeleton.get(\"fixedEntries\").findIndex((fixedEntry) => {\n      return (\n        fixedEntry.field === \"output\" && fixedEntry.index === changeOutputIndex\n      );\n    }) === -1\n  ) {\n    const originOutput: Cell = txSkeleton\n      .get(\"outputs\")\n      .get(changeOutputIndex)!;\n    const clonedOutput: Cell = JSON.parse(JSON.stringify(originOutput));\n    clonedOutput.cellOutput.capacity =\n      \"0x\" +\n      BI.from(originOutput.cellOutput.capacity)\n        .add(changeCapacity)\n        .toString(16);\n    if (changeAmount.gt(0)) {\n      clonedOutput.data = bytes.hexify(\n        number.Uint128LE.pack(\n          number.Uint128LE.unpack(originOutput.data).add(changeAmount)\n        )\n      );\n    }\n\n    const minimalChangeCellCapcaity = BI.from(\n      minimalCellCapacityCompatible(changeCell)\n    );\n    const minimalChangeCellWithoutSudtCapacity = BI.from(\n      minimalCellCapacityCompatible(changeCellWithoutSudt)\n    );\n    let splitFlag = false;\n    if (\n      changeAmount.gt(0) &&\n      splitChangeCell &&\n      changeCapacity.gte(\n        minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity)\n      )\n    ) {\n      clonedOutput.cellOutput.capacity = originOutput.cellOutput.capacity;\n      changeCellWithoutSudt.cellOutput.capacity =\n        \"0x\" + changeCapacity.toString(16);\n      splitFlag = true;\n    }\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.set(changeOutputIndex, clonedOutput);\n    });\n\n    if (splitFlag) {\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.push(changeCellWithoutSudt);\n      });\n    }\n  } else if (changeCapacity.gte(minimalCellCapacityCompatible(changeCell))) {\n    changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n    if (changeAmount.gt(0)) {\n      changeCell.data = bytes.hexify(number.Uint128LE.pack(changeAmount));\n    }\n\n    const minimalChangeCellCapcaity = BI.from(\n      minimalCellCapacityCompatible(changeCell)\n    );\n    const minimalChangeCellWithoutSudtCapacity = BI.from(\n      minimalCellCapacityCompatible(changeCellWithoutSudt)\n    );\n    let splitFlag = false;\n    if (changeAmount.gt(0) && splitChangeCell) {\n      if (\n        changeCapacity.gte(\n          minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity)\n        )\n      ) {\n        changeCell.cellOutput.capacity =\n          \"0x\" + minimalChangeCellCapcaity.toString(16);\n        changeCellWithoutSudt.cellOutput.capacity =\n          \"0x\" + changeCapacity.sub(minimalChangeCellCapcaity).toString(16);\n        splitFlag = true;\n      }\n    }\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n      outputs.push(changeCell)\n    );\n    if (changeAmount.gt(0)) {\n      txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n        return fixedEntries.push({\n          field: \"outputs\",\n          index: txSkeleton.get(\"outputs\").size - 1,\n        });\n      });\n    }\n    if (splitFlag) {\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.push(changeCellWithoutSudt);\n      });\n    }\n  } else if (\n    changeAmount.gt(0) &&\n    changeCapacity.lt(minimalCellCapacityCompatible(changeCell))\n  ) {\n    throw new Error(\"Not enough capacity for change in from infos!\");\n  }\n  if (_capacity.gt(0)) {\n    throw new Error(\"Not enough capacity in from infos!\");\n  }\n  if (_amount.gt(0)) {\n    throw new Error(\"Not enough amount in from infos!\");\n  }\n\n  return txSkeleton;\n}\n\nfunction _generateSudtScript(token: Hash, config: Config): Script {\n  const SUDT_SCRIPT = config.SCRIPTS.SUDT!;\n  // TODO: check token is a valid hash\n  return {\n    codeHash: SUDT_SCRIPT.CODE_HASH,\n    hashType: SUDT_SCRIPT.HASH_TYPE,\n    args: token,\n  };\n}\n\n/**\n * Compute sudt token by owner from info.\n *\n * @param fromInfo\n * @param options\n */\nexport function ownerForSudt(\n  fromInfo: FromInfo,\n  { config = undefined }: Options = {}\n): Token {\n  config = config || getConfig();\n  const { fromScript } = parseFromInfo(fromInfo, { config });\n  const lockHash = computeScriptHash(fromScript);\n  return lockHash;\n}\n\nexport default {\n  issueToken,\n  transfer,\n  ownerForSudt,\n};\n"],"mappings":"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"}