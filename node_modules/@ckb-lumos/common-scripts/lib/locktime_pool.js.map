{"version":3,"file":"locktime_pool.js","names":["ScriptValue","values","parseEpoch","maximumAbsoluteEpochSince","generateAbsoluteEpochSince","validateSince","sinceUtils","CellCollector","constructor","fromInfo","cellProvider","config","undefined","queryOptions","tipHeader","NodeRPC","RPC","Error","getConfig","result","parseFromInfo","fromScript","multisigScript","tipSinceValidationInfo","blockNumber","number","epoch","median_timestamp","rpc","uri","lock","cellCollectors","List","isSecp256k1Blake160MultisigScript","codeHash","hashType","args","slice","push","collector","argsLen","type","data","generateDaoScript","isSecp256k1Blake160Script","collect","cellCollector","inputCell","cellOutput","since","maximumCapacity","depositBlockHash","withdrawBlockHash","sinceValidationInfo","length","header","getHeader","blockHash","_parseMultisigArgsSinceCompatible","toString","isDaoScript","transactionWithStatus","getTransaction","outPoint","txHash","txStatus","transaction","depositOutPoint","inputs","index","previousOutput","depositBlockHeader","withdrawBlockHeader","daoSince","calculateDaoEarliestSinceCompatible","calculateMaximumWithdrawCompatible","dao","withdrawEpochValue","fourEpochsLater","multisigSince","parseSinceCompatible","relative","capacity","BI","from","transfer","txSkeleton","fromInfos","toAddress","amount","requireToAddress","assertAmountEnough","LocktimeCellCollector","transferCompatible","_txSkeleton","_amount","Array","BigInt","entries","value","_transferCompatible","eq","changeAddress","toScript","parseAddress","update","outputs","lastFreezedOutput","get","filter","field","maxBy","i","size","gt","output","validate","equals","cellCapacity","deductCapacity","gte","sub","minimalCellCapacityCompatible","clonedOutput","JSON","parse","stringify","changeLockScript","changeCell","changeCapacity","previousInputs","Set","input","add","cell","has","lockArgs","witness","template","SCRIPTS","DAO","addCellDep","depType","DEP_TYPE","TX_HASH","INDEX","headerDeps","depositHeaderDepIndex","witnessArgs","inputType","bytes","hexify","Uint64","pack","blockchain","WitnessArgs","collectInput","Object","assign","defaultWitness","inputCapacity","fixedEntries","injectCapacityWithoutChangeCompatible","minimalChangeCapacity","enableDeductCapacity","_minimalChangeCapacity","getInputKey","injectCapacityWithoutChange","toBigInt","payFee","prepareSigningEntries","_prepareSigningEntries","injectCapacity","outputIndex","setupInputCell","remove","inputLock","secp256k1Blake160","secp256k1Blake160Multisig","Uint64LE","unpack"],"sources":["../src/locktime_pool.ts"],"sourcesContent":["import {\n  parseAddress,\n  Options,\n  TransactionSkeletonType,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport { bytes, number } from \"@ckb-lumos/codec\";\nimport { FromInfo, parseFromInfo } from \"./from_info\";\nimport secp256k1Blake160 from \"./secp256k1_blake160\";\nimport {\n  calculateMaximumWithdrawCompatible,\n  calculateDaoEarliestSinceCompatible,\n} from \"./dao\";\nimport {\n  values,\n  since as sinceUtils,\n  CellProvider,\n  Script,\n  PackedSince,\n  Cell,\n  Hash,\n  HexString,\n  Address,\n  Header,\n  QueryOptions,\n  CellCollector as CellCollectorType,\n  SinceValidationInfo,\n  blockchain,\n} from \"@ckb-lumos/base\";\nconst { ScriptValue } = values;\nimport {\n  generateDaoScript,\n  isSecp256k1Blake160MultisigScript,\n  isSecp256k1Blake160Script,\n  isDaoScript,\n  prepareSigningEntries as _prepareSigningEntries,\n  addCellDep,\n} from \"./helper\";\nconst {\n  parseEpoch,\n  maximumAbsoluteEpochSince,\n  generateAbsoluteEpochSince,\n  validateSince,\n} = sinceUtils;\nimport { List, Set } from \"immutable\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nimport { secp256k1Blake160Multisig } from \".\";\nimport { parseSinceCompatible } from \"@ckb-lumos/base/lib/since\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { CellCollectorConstructor } from \"./type\";\nimport { RPC } from \"@ckb-lumos/rpc\";\n\nexport interface LocktimeCell extends Cell {\n  since: PackedSince;\n  depositBlockHash?: Hash;\n  withdrawBlockHash?: Hash;\n  sinceValidationInfo?: SinceValidationInfo;\n}\nexport const CellCollector: CellCollectorConstructor = class CellCollector\n  implements CellCollectorType\n{\n  private cellCollectors: List<CellCollectorType>;\n  private config: Config;\n  private rpc: RPC;\n  private tipHeader?: Header;\n  private tipSinceValidationInfo?: SinceValidationInfo;\n  public readonly fromScript: Script;\n  public readonly multisigScript?: HexString;\n  constructor(\n    fromInfo: FromInfo,\n    cellProvider: CellProvider,\n    {\n      config = undefined,\n      queryOptions = {},\n      tipHeader = undefined,\n      NodeRPC = RPC,\n    }: Options & {\n      queryOptions?: QueryOptions;\n      tipHeader?: Header;\n      NodeRPC?: typeof RPC;\n    } = {}\n  ) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || getConfig();\n    const result = parseFromInfo(fromInfo, { config });\n    const fromScript = result.fromScript;\n    this.multisigScript = result.multisigScript;\n    this.fromScript = fromScript;\n\n    this.config = config;\n    this.tipHeader = tipHeader;\n\n    if (tipHeader) {\n      // TODO: `median_timestamp` is not provided now!\n      this.tipSinceValidationInfo = {\n        blockNumber: tipHeader.number,\n        epoch: tipHeader.epoch,\n        median_timestamp: \"\",\n      };\n    }\n\n    this.rpc = new NodeRPC(cellProvider.uri!);\n\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n    };\n\n    let cellCollectors = List<CellCollectorType>([]);\n    if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n      const lock: Script = {\n        codeHash: fromScript.codeHash,\n        hashType: fromScript.hashType,\n        args: fromScript.args.slice(0, 42),\n      };\n      // multisig with locktime, not dao\n      cellCollectors = cellCollectors.push(\n        cellProvider.collector({\n          lock,\n          argsLen: queryOptions.argsLen || 28,\n          type: queryOptions.type || \"empty\",\n          data: queryOptions.data || \"0x\",\n        })\n      );\n      // multisig without locktime, dao\n      if (\n        !queryOptions.type &&\n        (!queryOptions.data || queryOptions.data === \"any\")\n      ) {\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n        // multisig with locktime, dao\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock,\n            argsLen: 28,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n      }\n    } else if (isSecp256k1Blake160Script(fromScript, config)) {\n      // secp256k1_blake160, dao\n      if (\n        !queryOptions.type &&\n        (!queryOptions.data || queryOptions.data === \"any\")\n      ) {\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock: fromScript,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n      }\n    }\n\n    this.cellCollectors = cellCollectors;\n  }\n\n  async *collect(): AsyncGenerator<LocktimeCell> {\n    for (const cellCollector of this.cellCollectors) {\n      for await (const inputCell of cellCollector.collect()) {\n        const lock = inputCell.cellOutput.lock;\n\n        let since: PackedSince | undefined;\n        let maximumCapacity: BI | undefined;\n        let depositBlockHash: Hash | undefined;\n        let withdrawBlockHash: Hash | undefined;\n        let sinceValidationInfo: SinceValidationInfo | undefined;\n\n        // multisig\n        if (lock.args.length === 58) {\n          const header = (await this.rpc.getHeader(inputCell.blockHash!))!;\n          since =\n            \"0x\" + _parseMultisigArgsSinceCompatible(lock.args).toString(16);\n          // TODO: `median_timestamp` not provided now!\n          sinceValidationInfo = {\n            epoch: header.epoch,\n            blockNumber: header.number,\n            median_timestamp: \"\",\n          };\n        }\n\n        // dao\n        if (isDaoScript(inputCell.cellOutput.type, this.config)) {\n          if (inputCell.data === \"0x0000000000000000\") {\n            continue;\n          }\n          const transactionWithStatus = (await this.rpc.getTransaction(\n            inputCell.outPoint!.txHash\n          ))!;\n          withdrawBlockHash = transactionWithStatus.txStatus.blockHash;\n          const transaction = transactionWithStatus.transaction;\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const depositOutPoint =\n            transaction.inputs[+inputCell.outPoint!.index].previousOutput;\n          depositBlockHash = (await this.rpc.getTransaction(\n            depositOutPoint!.txHash\n          ))!.txStatus.blockHash!;\n          const depositBlockHeader = await this.rpc.getHeader(depositBlockHash);\n          const withdrawBlockHeader = await this.rpc.getHeader(\n            withdrawBlockHash!\n          );\n          let daoSince: PackedSince =\n            \"0x\" +\n            calculateDaoEarliestSinceCompatible(\n              depositBlockHeader!.epoch,\n              withdrawBlockHeader!.epoch\n            ).toString(16);\n          maximumCapacity = calculateMaximumWithdrawCompatible(\n            inputCell,\n            depositBlockHeader!.dao,\n            withdrawBlockHeader!.dao\n          );\n          const withdrawEpochValue = parseEpoch(withdrawBlockHeader!.epoch);\n          const fourEpochsLater = {\n            number: withdrawEpochValue.number + 4,\n            length: withdrawEpochValue.length,\n            index: withdrawEpochValue.index,\n          };\n          daoSince = maximumAbsoluteEpochSince(\n            daoSince,\n            generateAbsoluteEpochSince(fourEpochsLater)\n          );\n\n          // if multisig with locktime\n          if (since) {\n            const multisigSince = parseSinceCompatible(since);\n            if (\n              !(\n                multisigSince.relative === false &&\n                multisigSince.type === \"epochNumber\"\n              )\n            ) {\n              // throw new Error(\n              //   \"Multisig since not an absolute-epoch-number since format!\"\n              // );\n              // skip multisig with locktime in non-absolute-epoch-number format, can't unlock it\n              continue;\n            }\n\n            try {\n              since = maximumAbsoluteEpochSince(daoSince, since);\n            } catch {\n              since = daoSince;\n            }\n          } else {\n            since = daoSince;\n          }\n        }\n\n        if (\n          parseSinceCompatible(since!).type === \"blockTimestamp\" ||\n          (this.tipHeader &&\n            !validateSince(\n              since!,\n              this.tipSinceValidationInfo!,\n              // TODO: modify the parameter type of `validateSince`\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              sinceValidationInfo!\n            ))\n        ) {\n          continue;\n        }\n\n        const result = {\n          ...inputCell,\n          since: since!,\n          depositBlockHash: depositBlockHash,\n          withdrawBlockHash: withdrawBlockHash,\n          sinceValidationInfo,\n        };\n        result.cellOutput.capacity =\n          \"0x\" +\n          (maximumCapacity || BI.from(inputCell.cellOutput.capacity)).toString(\n            16\n          );\n\n        yield result;\n      }\n    }\n  }\n};\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<[TransactionSkeletonType, bigint]>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {\n  const result = await transferCompatible(\n    txSkeleton,\n    fromInfos,\n    toAddress,\n    amount,\n    tipHeader,\n    {\n      config,\n      requireToAddress,\n      assertAmountEnough: assertAmountEnough as true | undefined,\n      LocktimeCellCollector,\n    }\n  );\n  let _txSkeleton: TransactionSkeletonType;\n  let _amount: bigint;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<[TransactionSkeletonType, BI]>;\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  let _amount = BI.from(amount);\n  for (const [index, fromInfo] of fromInfos.entries()) {\n    const value = (await _transferCompatible(\n      txSkeleton,\n      fromInfo,\n      index === 0 ? toAddress : undefined,\n      _amount,\n      tipHeader,\n      {\n        config,\n        requireToAddress: index === 0 ? requireToAddress : false,\n        assertAmountEnough: false,\n        LocktimeCellCollector,\n      }\n    )) as [TransactionSkeletonType, BI];\n    // [txSkeleton, amount] = value\n    txSkeleton = value[0];\n    _amount = value[1];\n\n    if (_amount.eq(0)) {\n      if (assertAmountEnough) {\n        return txSkeleton;\n      }\n      return [txSkeleton, BI.from(_amount)];\n    }\n  }\n\n  if (assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from addresses!\");\n  }\n  return [txSkeleton, BI.from(_amount)];\n}\n\nasync function _transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n    changeAddress = undefined,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector: CellCollectorConstructor;\n    changeAddress?: Address;\n  }\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  config = config || getConfig();\n  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig\n  const { fromScript } = parseFromInfo(fromInfo, { config });\n\n  // validate fromScript\n  if (\n    !isSecp256k1Blake160MultisigScript(fromScript, config) &&\n    !isSecp256k1Blake160Script(fromScript, config)\n  ) {\n    throw new Error(\"fromInfo not supported!\");\n  }\n\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n\n  let _amount = BI.from(amount || 0);\n  if (toAddress) {\n    const toScript = parseAddress(toAddress, { config });\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.push({\n        cellOutput: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined,\n        },\n        data: \"0x\",\n        outPoint: undefined,\n        blockHash: undefined,\n      });\n    });\n  }\n\n  const lastFreezedOutput = txSkeleton\n    .get(\"fixedEntries\")\n    .filter(({ field }) => field === \"outputs\")\n    .maxBy(({ index }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n    const output = txSkeleton.get(\"outputs\").get(i)!;\n    if (\n      new ScriptValue(output.cellOutput.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      const cellCapacity = BI.from(output.cellOutput.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub(\n          minimalCellCapacityCompatible(output)\n        );\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n\n      const clonedOutput = JSON.parse(JSON.stringify(output));\n      clonedOutput.cellOutput.capacity =\n        \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.update(i, () => clonedOutput);\n      });\n    }\n  }\n  // remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.filter(\n      (output) => !BI.from(output.cellOutput.capacity).eq(0)\n    );\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n\n    const changeLockScript: Script = changeAddress\n      ? parseAddress(changeAddress, { config })\n      : fromScript;\n    const changeCell: Cell = {\n      cellOutput: {\n        capacity: \"0x0\",\n        lock: changeLockScript,\n        type: undefined,\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined,\n    };\n    let changeCapacity = BI.from(0);\n\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(\n        `${input.outPoint!.txHash}_${input.outPoint!.index}`\n      );\n    }\n    const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {\n      config,\n      tipHeader,\n    });\n    for await (const cell of cellCollector.collect()) {\n      const inputCell = cell as LocktimeCell;\n      // skip inputs already exists in txSkeleton.inputs\n      if (\n        previousInputs.has(\n          `${inputCell.outPoint!.txHash}_${inputCell.outPoint!.index}`\n        )\n      ) {\n        continue;\n      }\n\n      let multisigSince: BI | undefined;\n      if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n        const lockArgs = inputCell.cellOutput.lock.args;\n        multisigSince =\n          lockArgs.length === 58\n            ? BI.from(_parseMultisigArgsSinceCompatible(lockArgs))\n            : undefined;\n      }\n      let witness: HexString = \"0x\";\n      if (isDaoScript(inputCell.cellOutput.type, config)) {\n        const template = config.SCRIPTS.DAO!;\n        txSkeleton = addCellDep(txSkeleton, {\n          depType: template.DEP_TYPE,\n          outPoint: {\n            txHash: template.TX_HASH,\n            index: template.INDEX,\n          },\n        });\n\n        txSkeleton = txSkeleton.update(\"headerDeps\", (headerDeps) => {\n          return headerDeps.push(\n            inputCell.depositBlockHash!,\n            inputCell.withdrawBlockHash!\n          );\n        });\n\n        const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n\n        const witnessArgs = {\n          inputType: bytes.hexify(number.Uint64.pack(depositHeaderDepIndex)),\n        };\n        witness = bytes.hexify(blockchain.WitnessArgs.pack(witnessArgs));\n      }\n\n      txSkeleton = await collectInput(\n        txSkeleton,\n        inputCell,\n        isSecp256k1Blake160MultisigScript(fromScript, config)\n          ? Object.assign({}, fromInfo, { since: multisigSince })\n          : fromInfo,\n        { config, defaultWitness: witness, since: inputCell.since }\n      );\n\n      const inputCapacity = BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n      if (isDaoScript(inputCell.cellOutput.type, config)) {\n        // fix inputs / outputs / witnesses\n        txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n          return fixedEntries.push(\n            {\n              field: \"inputs\",\n              index: txSkeleton.get(\"inputs\").size - 1,\n            },\n            {\n              field: \"witnesses\",\n              index: txSkeleton.get(\"witnesses\").size - 1,\n            },\n            {\n              field: \"headerDeps\",\n              index: txSkeleton.get(\"headerDeps\").size - 2,\n            }\n          );\n        });\n      }\n      if (\n        _amount.eq(0) &&\n        (changeCapacity.eq(0) ||\n          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))\n      ) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n        outputs.push(changeCell)\n      );\n    }\n  }\n\n  if (!assertAmountEnough) {\n    return [txSkeleton, _amount];\n  }\n\n  if (_amount.gt(0)) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n\n  return txSkeleton;\n}\n\nasync function injectCapacityWithoutChangeCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: BIish,\n  tipHeader: Header,\n  minimalChangeCapacity: BIish,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n    enableDeductCapacity = true,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n    enableDeductCapacity?: boolean;\n  }\n): Promise<{\n  txSkeleton: TransactionSkeletonType;\n  capacity: BI;\n  changeCapacity: BI;\n}> {\n  config = config || getConfig();\n  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig\n\n  let _amount = BI.from(amount);\n  const _minimalChangeCapacity = BI.from(minimalChangeCapacity);\n  if (enableDeductCapacity) {\n    for (const fromInfo of fromInfos) {\n      const fromScript: Script = parseFromInfo(fromInfo, { config }).fromScript;\n      // validate fromScript\n      if (\n        !isSecp256k1Blake160MultisigScript(fromScript, config) &&\n        !isSecp256k1Blake160Script(fromScript, config)\n      ) {\n        // Skip if not support.\n        continue;\n      }\n      const lastFreezedOutput = txSkeleton\n        .get(\"fixedEntries\")\n        .filter(({ field }) => field === \"outputs\")\n        .maxBy(({ index }) => index);\n      let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n      for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n        const output = txSkeleton.get(\"outputs\").get(i)!;\n        if (\n          new ScriptValue(output.cellOutput.lock, { validate: false }).equals(\n            new ScriptValue(fromScript, { validate: false })\n          )\n        ) {\n          const clonedOutput: Cell = JSON.parse(JSON.stringify(output));\n          const cellCapacity = BI.from(clonedOutput.cellOutput.capacity);\n          let deductCapacity;\n          if (_amount.gte(cellCapacity)) {\n            deductCapacity = cellCapacity;\n          } else {\n            deductCapacity = cellCapacity.sub(\n              minimalCellCapacityCompatible(clonedOutput)\n            );\n            if (deductCapacity.gt(_amount)) {\n              deductCapacity = _amount;\n            }\n          }\n          _amount = _amount.sub(deductCapacity);\n          clonedOutput.cellOutput.capacity =\n            \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n\n          txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n            return outputs.update(i, () => clonedOutput);\n          });\n        }\n      }\n      // remove all output cells with capacity equal to 0\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.filter(\n          (output) => !BI.from(output.cellOutput.capacity).eq(0)\n        );\n      });\n    }\n  }\n\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  let changeCapacity = BI.from(0);\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n\n    const getInputKey = (input: Cell) =>\n      `${input.outPoint!.txHash}_${input.outPoint!.index}`;\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(getInputKey(input));\n    }\n\n    for (const fromInfo of fromInfos) {\n      const fromScript: Script = parseFromInfo(fromInfo, { config }).fromScript;\n      const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {\n        config,\n        tipHeader,\n      });\n      for await (const cell of cellCollector.collect()) {\n        const inputCell = cell as LocktimeCell;\n        // skip inputs already exists in txSkeleton.inputs\n        if (previousInputs.has(getInputKey(inputCell))) {\n          continue;\n        }\n\n        let witness: HexString = \"0x\";\n        if (isDaoScript(inputCell.cellOutput.type, config)) {\n          const template = config.SCRIPTS.DAO!;\n          txSkeleton = addCellDep(txSkeleton, {\n            depType: template.DEP_TYPE,\n            outPoint: {\n              txHash: template.TX_HASH,\n              index: template.INDEX,\n            },\n          });\n\n          txSkeleton = txSkeleton.update(\"headerDeps\", (headerDeps) => {\n            return headerDeps.push(\n              inputCell.depositBlockHash!,\n              inputCell.withdrawBlockHash!\n            );\n          });\n\n          const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n          const witnessArgs = {\n            inputType: bytes.hexify(number.Uint64.pack(depositHeaderDepIndex)),\n          };\n          witness = bytes.hexify(blockchain.WitnessArgs.pack(witnessArgs));\n        }\n        let multisigSince: BI | undefined;\n        if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n          // multisig\n          const lockArgs = inputCell.cellOutput.lock.args;\n          multisigSince =\n            lockArgs.length === 58\n              ? BI.from(_parseMultisigArgsSinceCompatible(lockArgs))\n              : undefined;\n        }\n        txSkeleton = await collectInput(\n          txSkeleton,\n          inputCell,\n          Object.assign({}, fromInfo, { since: multisigSince }),\n          {\n            config,\n            defaultWitness: witness,\n            since: inputCell.since,\n          }\n        );\n\n        const inputCapacity = BI.from(inputCell.cellOutput.capacity);\n        let deductCapacity = inputCapacity;\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n        _amount = _amount.sub(deductCapacity);\n        changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n\n        if (isDaoScript(inputCell.cellOutput.type, config)) {\n          // fix inputs / outputs / witnesses\n          txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n            return fixedEntries.push(\n              {\n                field: \"inputs\",\n                index: txSkeleton.get(\"inputs\").size - 1,\n              },\n              {\n                field: \"witnesses\",\n                index: txSkeleton.get(\"witnesses\").size - 1,\n              },\n              {\n                field: \"headerDeps\",\n                index: txSkeleton.get(\"headerDeps\").size - 2,\n              }\n            );\n          });\n        }\n\n        if (\n          _amount.eq(0) &&\n          (changeCapacity.eq(0) || changeCapacity.gt(_minimalChangeCapacity))\n        ) {\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    txSkeleton,\n    capacity: BI.from(_amount.toString()),\n    changeCapacity: BI.from(changeCapacity.toString()),\n  };\n}\n\nasync function injectCapacityWithoutChange(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: bigint,\n  tipHeader: Header,\n  minimalChangeCapacity: bigint,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n    enableDeductCapacity = true,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n    enableDeductCapacity?: boolean;\n  }\n): Promise<{\n  txSkeleton: TransactionSkeletonType;\n  capacity: bigint;\n  changeCapacity: bigint;\n}> {\n  const result = await injectCapacityWithoutChangeCompatible(\n    txSkeleton,\n    fromInfos,\n    amount,\n    tipHeader,\n    minimalChangeCapacity,\n    {\n      config,\n      LocktimeCellCollector,\n      enableDeductCapacity,\n    }\n  );\n\n  return {\n    txSkeleton: result.txSkeleton,\n    capacity: result.capacity.toBigInt(),\n    changeCapacity: result.changeCapacity.toBigInt(),\n  };\n}\n\nexport async function payFee(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  return transferCompatible(\n    txSkeleton,\n    fromInfos,\n    undefined,\n    amount,\n    tipHeader,\n    {\n      config,\n      requireToAddress: false,\n      LocktimeCellCollector,\n    }\n  );\n}\n\nexport function prepareSigningEntries(\n  txSkeleton: TransactionSkeletonType,\n  { config = undefined }: Options = {}\n): TransactionSkeletonType {\n  config = config || getConfig();\n  txSkeleton = _prepareSigningEntries(txSkeleton, config, \"SECP256K1_BLAKE160\");\n  txSkeleton = _prepareSigningEntries(\n    txSkeleton,\n    config,\n    \"SECP256K1_BLAKE160_MULTISIG\"\n  );\n  return txSkeleton;\n}\n\nexport async function injectCapacity(\n  txSkeleton: TransactionSkeletonType,\n  outputIndex: number,\n  fromInfos: FromInfo[],\n  tipHeader: Header,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n  }: Options & {\n    // eslint-disable-next-line\n    cellCollector?: (...params: any[]) => AsyncIterable<LocktimeCell>;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = BI.from(\n    txSkeleton.get(\"outputs\").get(outputIndex)!.cellOutput.capacity\n  );\n  return transferCompatible(\n    txSkeleton,\n    fromInfos,\n    undefined,\n    BI.from(capacity),\n    tipHeader,\n    {\n      config,\n      requireToAddress: false,\n      LocktimeCellCollector,\n    }\n  );\n}\n\nasync function collectInput(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    since = undefined,\n    defaultWitness = \"0x\",\n  }: Options & { defaultWitness?: HexString; since?: PackedSince } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n\n  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {\n    config,\n    since,\n    defaultWitness,\n  });\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.remove(outputs.size - 1);\n  });\n\n  return txSkeleton;\n}\n\nexport async function setupInputCell(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    since = undefined,\n    defaultWitness = \"0x\",\n  }: Options & { defaultWitness?: HexString; since?: PackedSince } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  const inputLock = inputCell.cellOutput.lock;\n\n  if (isSecp256k1Blake160Script(inputLock, config)) {\n    return secp256k1Blake160.setupInputCell(txSkeleton, inputCell, fromInfo, {\n      config,\n      defaultWitness,\n      since,\n    });\n  } else if (isSecp256k1Blake160MultisigScript(inputLock, config)) {\n    return secp256k1Blake160Multisig.setupInputCell(\n      txSkeleton,\n      inputCell,\n      fromInfo,\n      {\n        config,\n        defaultWitness,\n        since,\n      }\n    );\n  } else {\n    throw new Error(`Not supported input lock!`);\n  }\n}\n\nfunction _parseMultisigArgsSinceCompatible(args: HexString): BI {\n  if (args.length !== 58) {\n    throw new Error(\"Invalid multisig with since args!\");\n  }\n  return number.Uint64LE.unpack(\"0x\" + args.slice(42));\n}\n\nexport default {\n  CellCollector,\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  injectCapacity,\n  setupInputCell,\n  injectCapacityWithoutChange,\n  injectCapacityWithoutChangeCompatible,\n};\n"],"mappings":";;;;;;;;;;;;;AAAA;;AAMA;;AACA;;AACA;;AACA;;AAIA;;AAiBA;;AAcA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;AArBA,MAAM;EAAEA;AAAF,IAAkBC,YAAxB;AASA,MAAM;EACJC,UADI;EAEJC,yBAFI;EAGJC,0BAHI;EAIJC;AAJI,IAKFC,WALJ;AAoBO,MAAMC,aAAuC,GAAG,MAAMA,aAAN,CAEvD;EAQEC,WAAW,CACTC,QADS,EAETC,YAFS,EAGT;IACEC,MAAM,GAAGC,SADX;IAEEC,YAAY,GAAG,EAFjB;IAGEC,SAAS,GAAGF,SAHd;IAIEG,OAAO,GAAGC;EAJZ,IASI,EAZK,EAaT;IACA,IAAI,CAACN,YAAL,EAAmB;MACjB,MAAM,IAAIO,KAAJ,CAAW,2BAAX,CAAN;IACD;;IACDN,MAAM,GAAGA,MAAM,IAAI,IAAAO,wBAAA,GAAnB;IACA,MAAMC,MAAM,GAAG,IAAAC,wBAAA,EAAcX,QAAd,EAAwB;MAAEE;IAAF,CAAxB,CAAf;IACA,MAAMU,UAAU,GAAGF,MAAM,CAACE,UAA1B;IACA,KAAKC,cAAL,GAAsBH,MAAM,CAACG,cAA7B;IACA,KAAKD,UAAL,GAAkBA,UAAlB;IAEA,KAAKV,MAAL,GAAcA,MAAd;IACA,KAAKG,SAAL,GAAiBA,SAAjB;;IAEA,IAAIA,SAAJ,EAAe;MACb;MACA,KAAKS,sBAAL,GAA8B;QAC5BC,WAAW,EAAEV,SAAS,CAACW,MADK;QAE5BC,KAAK,EAAEZ,SAAS,CAACY,KAFW;QAG5BC,gBAAgB,EAAE;MAHU,CAA9B;IAKD;;IAED,KAAKC,GAAL,GAAW,IAAIb,OAAJ,CAAYL,YAAY,CAACmB,GAAzB,CAAX;IAEAhB,YAAY,GAAG,EACb,GAAGA,YADU;MAEbiB,IAAI,EAAE,KAAKT;IAFE,CAAf;IAKA,IAAIU,cAAc,GAAG,IAAAC,eAAA,EAAwB,EAAxB,CAArB;;IACA,IAAI,IAAAC,yCAAA,EAAkCZ,UAAlC,EAA8CV,MAA9C,CAAJ,EAA2D;MACzD,MAAMmB,IAAY,GAAG;QACnBI,QAAQ,EAAEb,UAAU,CAACa,QADF;QAEnBC,QAAQ,EAAEd,UAAU,CAACc,QAFF;QAGnBC,IAAI,EAAEf,UAAU,CAACe,IAAX,CAAgBC,KAAhB,CAAsB,CAAtB,EAAyB,EAAzB;MAHa,CAArB,CADyD,CAMzD;;MACAN,cAAc,GAAGA,cAAc,CAACO,IAAf,CACf5B,YAAY,CAAC6B,SAAb,CAAuB;QACrBT,IADqB;QAErBU,OAAO,EAAE3B,YAAY,CAAC2B,OAAb,IAAwB,EAFZ;QAGrBC,IAAI,EAAE5B,YAAY,CAAC4B,IAAb,IAAqB,OAHN;QAIrBC,IAAI,EAAE7B,YAAY,CAAC6B,IAAb,IAAqB;MAJN,CAAvB,CADe,CAAjB,CAPyD,CAezD;;MACA,IACE,CAAC7B,YAAY,CAAC4B,IAAd,KACC,CAAC5B,YAAY,CAAC6B,IAAd,IAAsB7B,YAAY,CAAC6B,IAAb,KAAsB,KAD7C,CADF,EAGE;QACAX,cAAc,GAAGA,cAAc,CAACO,IAAf,CACf5B,YAAY,CAAC6B,SAAb,CAAuB;UACrBT,IADqB;UAErBW,IAAI,EAAE,IAAAE,yBAAA,EAAkBhC,MAAlB,CAFe;UAGrB+B,IAAI,EAAE;QAHe,CAAvB,CADe,CAAjB,CADA,CAQA;;QACAX,cAAc,GAAGA,cAAc,CAACO,IAAf,CACf5B,YAAY,CAAC6B,SAAb,CAAuB;UACrBT,IADqB;UAErBU,OAAO,EAAE,EAFY;UAGrBC,IAAI,EAAE,IAAAE,yBAAA,EAAkBhC,MAAlB,CAHe;UAIrB+B,IAAI,EAAE;QAJe,CAAvB,CADe,CAAjB;MAQD;IACF,CArCD,MAqCO,IAAI,IAAAE,iCAAA,EAA0BvB,UAA1B,EAAsCV,MAAtC,CAAJ,EAAmD;MACxD;MACA,IACE,CAACE,YAAY,CAAC4B,IAAd,KACC,CAAC5B,YAAY,CAAC6B,IAAd,IAAsB7B,YAAY,CAAC6B,IAAb,KAAsB,KAD7C,CADF,EAGE;QACAX,cAAc,GAAGA,cAAc,CAACO,IAAf,CACf5B,YAAY,CAAC6B,SAAb,CAAuB;UACrBT,IAAI,EAAET,UADe;UAErBoB,IAAI,EAAE,IAAAE,yBAAA,EAAkBhC,MAAlB,CAFe;UAGrB+B,IAAI,EAAE;QAHe,CAAvB,CADe,CAAjB;MAOD;IACF;;IAED,KAAKX,cAAL,GAAsBA,cAAtB;EACD;;EAEa,OAAPc,OAAO,GAAiC;IAC7C,KAAK,MAAMC,aAAX,IAA4B,KAAKf,cAAjC,EAAiD;MAC/C,WAAW,MAAMgB,SAAjB,IAA8BD,aAAa,CAACD,OAAd,EAA9B,EAAuD;QACrD,MAAMf,IAAI,GAAGiB,SAAS,CAACC,UAAV,CAAqBlB,IAAlC;QAEA,IAAImB,KAAJ;QACA,IAAIC,eAAJ;QACA,IAAIC,gBAAJ;QACA,IAAIC,iBAAJ;QACA,IAAIC,mBAAJ,CAPqD,CASrD;;QACA,IAAIvB,IAAI,CAACM,IAAL,CAAUkB,MAAV,KAAqB,EAAzB,EAA6B;UAC3B,MAAMC,MAAM,GAAI,MAAM,KAAK3B,GAAL,CAAS4B,SAAT,CAAmBT,SAAS,CAACU,SAA7B,CAAtB;UACAR,KAAK,GACH,OAAOS,iCAAiC,CAAC5B,IAAI,CAACM,IAAN,CAAjC,CAA6CuB,QAA7C,CAAsD,EAAtD,CADT,CAF2B,CAI3B;;UACAN,mBAAmB,GAAG;YACpB3B,KAAK,EAAE6B,MAAM,CAAC7B,KADM;YAEpBF,WAAW,EAAE+B,MAAM,CAAC9B,MAFA;YAGpBE,gBAAgB,EAAE;UAHE,CAAtB;QAKD,CApBoD,CAsBrD;;;QACA,IAAI,IAAAiC,mBAAA,EAAYb,SAAS,CAACC,UAAV,CAAqBP,IAAjC,EAAuC,KAAK9B,MAA5C,CAAJ,EAAyD;UACvD,IAAIoC,SAAS,CAACL,IAAV,KAAmB,oBAAvB,EAA6C;YAC3C;UACD;;UACD,MAAMmB,qBAAqB,GAAI,MAAM,KAAKjC,GAAL,CAASkC,cAAT,CACnCf,SAAS,CAACgB,QAAV,CAAoBC,MADe,CAArC;UAGAZ,iBAAiB,GAAGS,qBAAqB,CAACI,QAAtB,CAA+BR,SAAnD;UACA,MAAMS,WAAW,GAAGL,qBAAqB,CAACK,WAA1C,CARuD,CASvD;;UACA,MAAMC,eAAe,GACnBD,WAAW,CAACE,MAAZ,CAAmB,CAACrB,SAAS,CAACgB,QAAV,CAAoBM,KAAxC,EAA+CC,cADjD;UAEAnB,gBAAgB,GAAG,CAAC,MAAM,KAAKvB,GAAL,CAASkC,cAAT,CACxBK,eAAe,CAAEH,MADO,CAAP,EAEfC,QAFe,CAENR,SAFb;UAGA,MAAMc,kBAAkB,GAAG,MAAM,KAAK3C,GAAL,CAAS4B,SAAT,CAAmBL,gBAAnB,CAAjC;UACA,MAAMqB,mBAAmB,GAAG,MAAM,KAAK5C,GAAL,CAAS4B,SAAT,CAChCJ,iBADgC,CAAlC;UAGA,IAAIqB,QAAqB,GACvB,OACA,IAAAC,wCAAA,EACEH,kBAAkB,CAAE7C,KADtB,EAEE8C,mBAAmB,CAAE9C,KAFvB,EAGEiC,QAHF,CAGW,EAHX,CAFF;UAMAT,eAAe,GAAG,IAAAyB,uCAAA,EAChB5B,SADgB,EAEhBwB,kBAAkB,CAAEK,GAFJ,EAGhBJ,mBAAmB,CAAEI,GAHL,CAAlB;UAKA,MAAMC,kBAAkB,GAAG3E,UAAU,CAACsE,mBAAmB,CAAE9C,KAAtB,CAArC;UACA,MAAMoD,eAAe,GAAG;YACtBrD,MAAM,EAAEoD,kBAAkB,CAACpD,MAAnB,GAA4B,CADd;YAEtB6B,MAAM,EAAEuB,kBAAkB,CAACvB,MAFL;YAGtBe,KAAK,EAAEQ,kBAAkB,CAACR;UAHJ,CAAxB;UAKAI,QAAQ,GAAGtE,yBAAyB,CAClCsE,QADkC,EAElCrE,0BAA0B,CAAC0E,eAAD,CAFQ,CAApC,CApCuD,CAyCvD;;UACA,IAAI7B,KAAJ,EAAW;YACT,MAAM8B,aAAa,GAAG,IAAAC,2BAAA,EAAqB/B,KAArB,CAAtB;;YACA,IACE,EACE8B,aAAa,CAACE,QAAd,KAA2B,KAA3B,IACAF,aAAa,CAACtC,IAAd,KAAuB,aAFzB,CADF,EAKE;cACA;cACA;cACA;cACA;cACA;YACD;;YAED,IAAI;cACFQ,KAAK,GAAG9C,yBAAyB,CAACsE,QAAD,EAAWxB,KAAX,CAAjC;YACD,CAFD,CAEE,MAAM;cACNA,KAAK,GAAGwB,QAAR;YACD;UACF,CApBD,MAoBO;YACLxB,KAAK,GAAGwB,QAAR;UACD;QACF;;QAED,IACE,IAAAO,2BAAA,EAAqB/B,KAArB,EAA6BR,IAA7B,KAAsC,gBAAtC,IACC,KAAK3B,SAAL,IACC,CAACT,aAAa,CACZ4C,KADY,EAEZ,KAAK1B,sBAFO,EAGZ;QACA;QACA8B,mBALY,CAHlB,EAUE;UACA;QACD;;QAED,MAAMlC,MAAM,GAAG,EACb,GAAG4B,SADU;UAEbE,KAAK,EAAEA,KAFM;UAGbE,gBAAgB,EAAEA,gBAHL;UAIbC,iBAAiB,EAAEA,iBAJN;UAKbC;QALa,CAAf;QAOAlC,MAAM,CAAC6B,UAAP,CAAkBkC,QAAlB,GACE,OACA,CAAChC,eAAe,IAAIiC,MAAA,CAAGC,IAAH,CAAQrC,SAAS,CAACC,UAAV,CAAqBkC,QAA7B,CAApB,EAA4DvB,QAA5D,CACE,EADF,CAFF;QAMA,MAAMxC,MAAN;MACD;IACF;EACF;;AArOH,CAFO;;;AAgRA,eAAekE,QAAf,CACLC,UADK,EAELC,SAFK,EAGLC,SAHK,EAILC,MAJK,EAKL3E,SALK,EAML;EACEH,MAAM,GAAGC,SADX;EAEE8E,gBAAgB,GAAG,IAFrB;EAGEC,kBAAkB,GAAG,IAHvB;EAIEC,qBAAqB,GAAGrF;AAJ1B,IAUI,EAhBC,EAiBiE;EACtE,MAAMY,MAAM,GAAG,MAAM0E,kBAAkB,CACrCP,UADqC,EAErCC,SAFqC,EAGrCC,SAHqC,EAIrCC,MAJqC,EAKrC3E,SALqC,EAMrC;IACEH,MADF;IAEE+E,gBAFF;IAGEC,kBAAkB,EAAEA,kBAHtB;IAIEC;EAJF,CANqC,CAAvC;;EAaA,IAAIE,WAAJ;;EACA,IAAIC,OAAJ;;EACA,IAAI5E,MAAM,YAAY6E,KAAtB,EAA6B;IAC3BF,WAAW,GAAG3E,MAAM,CAAC,CAAD,CAApB;IACA4E,OAAO,GAAGE,MAAM,CAAC9E,MAAM,CAAC,CAAD,CAAN,CAAUwC,QAAV,EAAD,CAAhB;IACA,OAAO,CAACmC,WAAD,EAAcC,OAAd,CAAP;EACD,CAJD,MAIO;IACLD,WAAW,GAAG3E,MAAd;IACA,OAAO2E,WAAP;EACD;AACF;;AAuCM,eAAeD,kBAAf,CACLP,UADK,EAELC,SAFK,EAGLC,SAHK,EAILC,MAJK,EAKL3E,SALK,EAML;EACEH,MAAM,GAAGC,SADX;EAEE8E,gBAAgB,GAAG,IAFrB;EAGEC,kBAAkB,GAAG,IAHvB;EAIEC,qBAAqB,GAAGrF;AAJ1B,IAUI,EAhBC,EAiB6D;EAClE,IAAIwF,OAAO,GAAGZ,MAAA,CAAGC,IAAH,CAAQK,MAAR,CAAd;;EACA,KAAK,MAAM,CAACpB,KAAD,EAAQ5D,QAAR,CAAX,IAAgC8E,SAAS,CAACW,OAAV,EAAhC,EAAqD;IACnD,MAAMC,KAAK,GAAI,MAAMC,mBAAmB,CACtCd,UADsC,EAEtC7E,QAFsC,EAGtC4D,KAAK,KAAK,CAAV,GAAcmB,SAAd,GAA0B5E,SAHY,EAItCmF,OAJsC,EAKtCjF,SALsC,EAMtC;MACEH,MADF;MAEE+E,gBAAgB,EAAErB,KAAK,KAAK,CAAV,GAAcqB,gBAAd,GAAiC,KAFrD;MAGEC,kBAAkB,EAAE,KAHtB;MAIEC;IAJF,CANsC,CAAxC,CADmD,CAcnD;;IACAN,UAAU,GAAGa,KAAK,CAAC,CAAD,CAAlB;IACAJ,OAAO,GAAGI,KAAK,CAAC,CAAD,CAAf;;IAEA,IAAIJ,OAAO,CAACM,EAAR,CAAW,CAAX,CAAJ,EAAmB;MACjB,IAAIV,kBAAJ,EAAwB;QACtB,OAAOL,UAAP;MACD;;MACD,OAAO,CAACA,UAAD,EAAaH,MAAA,CAAGC,IAAH,CAAQW,OAAR,CAAb,CAAP;IACD;EACF;;EAED,IAAIJ,kBAAJ,EAAwB;IACtB,MAAM,IAAI1E,KAAJ,CAAU,wCAAV,CAAN;EACD;;EACD,OAAO,CAACqE,UAAD,EAAaH,MAAA,CAAGC,IAAH,CAAQW,OAAR,CAAb,CAAP;AACD;;AAED,eAAeK,mBAAf,CACEd,UADF,EAEE7E,QAFF,EAGE+E,SAHF,EAIEC,MAJF,EAKE3E,SALF,EAME;EACEH,MAAM,GAAGC,SADX;EAEE8E,gBAAgB,GAAG,IAFrB;EAGEC,kBAAkB,GAAG,IAHvB;EAIEC,qBAAqB,GAAGrF,aAJ1B;EAKE+F,aAAa,GAAG1F;AALlB,CANF,EAmBoE;EAClED,MAAM,GAAGA,MAAM,IAAI,IAAAO,wBAAA,GAAnB,CADkE,CAElE;;EACA,MAAM;IAAEG;EAAF,IAAiB,IAAAD,wBAAA,EAAcX,QAAd,EAAwB;IAAEE;EAAF,CAAxB,CAAvB,CAHkE,CAKlE;;EACA,IACE,CAAC,IAAAsB,yCAAA,EAAkCZ,UAAlC,EAA8CV,MAA9C,CAAD,IACA,CAAC,IAAAiC,iCAAA,EAA0BvB,UAA1B,EAAsCV,MAAtC,CAFH,EAGE;IACA,MAAM,IAAIM,KAAJ,CAAU,yBAAV,CAAN;EACD;;EAED,IAAIyE,gBAAgB,IAAI,CAACF,SAAzB,EAAoC;IAClC,MAAM,IAAIvE,KAAJ,CAAU,gCAAV,CAAN;EACD;;EAED,IAAI8E,OAAO,GAAGZ,MAAA,CAAGC,IAAH,CAAQK,MAAM,IAAI,CAAlB,CAAd;;EACA,IAAID,SAAJ,EAAe;IACb,MAAMe,QAAQ,GAAG,IAAAC,qBAAA,EAAahB,SAAb,EAAwB;MAAE7E;IAAF,CAAxB,CAAjB;IAEA2E,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;MACrD,OAAOA,OAAO,CAACpE,IAAR,CAAa;QAClBU,UAAU,EAAE;UACVkC,QAAQ,EAAE,OAAOa,OAAO,CAACpC,QAAR,CAAiB,EAAjB,CADP;UAEV7B,IAAI,EAAEyE,QAFI;UAGV9D,IAAI,EAAE7B;QAHI,CADM;QAMlB8B,IAAI,EAAE,IANY;QAOlBqB,QAAQ,EAAEnD,SAPQ;QAQlB6C,SAAS,EAAE7C;MARO,CAAb,CAAP;IAUD,CAXY,CAAb;EAYD;;EAED,MAAM+F,iBAAiB,GAAGrB,UAAU,CACjCsB,GADuB,CACnB,cADmB,EAEvBC,MAFuB,CAEhB,CAAC;IAAEC;EAAF,CAAD,KAAeA,KAAK,KAAK,SAFT,EAGvBC,KAHuB,CAGjB,CAAC;IAAE1C;EAAF,CAAD,KAAeA,KAHE,CAA1B;EAIA,IAAI2C,CAAC,GAAGL,iBAAiB,GAAGA,iBAAiB,CAACtC,KAAlB,GAA0B,CAA7B,GAAiC,CAA1D;;EACA,OAAO2C,CAAC,GAAG1B,UAAU,CAACsB,GAAX,CAAe,SAAf,EAA0BK,IAA9B,IAAsClB,OAAO,CAACmB,EAAR,CAAW,CAAX,CAA7C,EAA4D,EAAEF,CAA9D,EAAiE;IAC/D,MAAMG,MAAM,GAAG7B,UAAU,CAACsB,GAAX,CAAe,SAAf,EAA0BA,GAA1B,CAA8BI,CAA9B,CAAf;;IACA,IACE,IAAIhH,WAAJ,CAAgBmH,MAAM,CAACnE,UAAP,CAAkBlB,IAAlC,EAAwC;MAAEsF,QAAQ,EAAE;IAAZ,CAAxC,EAA6DC,MAA7D,CACE,IAAIrH,WAAJ,CAAgBqB,UAAhB,EAA4B;MAAE+F,QAAQ,EAAE;IAAZ,CAA5B,CADF,CADF,EAIE;MACA,MAAME,YAAY,GAAGnC,MAAA,CAAGC,IAAH,CAAQ+B,MAAM,CAACnE,UAAP,CAAkBkC,QAA1B,CAArB;;MACA,IAAIqC,cAAJ;;MACA,IAAIxB,OAAO,CAACyB,GAAR,CAAYF,YAAZ,CAAJ,EAA+B;QAC7BC,cAAc,GAAGD,YAAjB;MACD,CAFD,MAEO;QACLC,cAAc,GAAGD,YAAY,CAACG,GAAb,CACf,IAAAC,sCAAA,EAA8BP,MAA9B,CADe,CAAjB;;QAGA,IAAII,cAAc,CAACL,EAAf,CAAkBnB,OAAlB,CAAJ,EAAgC;UAC9BwB,cAAc,GAAGxB,OAAjB;QACD;MACF;;MACDA,OAAO,GAAGA,OAAO,CAAC0B,GAAR,CAAYF,cAAZ,CAAV;MAEA,MAAMI,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeX,MAAf,CAAX,CAArB;MACAQ,YAAY,CAAC3E,UAAb,CAAwBkC,QAAxB,GACE,OAAOoC,YAAY,CAACG,GAAb,CAAiBF,cAAjB,EAAiC5D,QAAjC,CAA0C,EAA1C,CADT;MAEA2B,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;QACrD,OAAOA,OAAO,CAACD,MAAR,CAAeO,CAAf,EAAkB,MAAMW,YAAxB,CAAP;MACD,CAFY,CAAb;IAGD;EACF,CApEiE,CAqElE;;;EACArC,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;IACrD,OAAOA,OAAO,CAACG,MAAR,CACJM,MAAD,IAAY,CAAChC,MAAA,CAAGC,IAAH,CAAQ+B,MAAM,CAACnE,UAAP,CAAkBkC,QAA1B,EAAoCmB,EAApC,CAAuC,CAAvC,CADR,CAAP;EAGD,CAJY,CAAb;EAKA;AACF;AACA;;EACE,IAAIN,OAAO,CAACmB,EAAR,CAAW,CAAX,CAAJ,EAAmB;IACjB,MAAMxG,YAAY,GAAG4E,UAAU,CAACsB,GAAX,CAAe,cAAf,CAArB;;IACA,IAAI,CAAClG,YAAL,EAAmB;MACjB,MAAM,IAAIO,KAAJ,CAAU,2BAAV,CAAN;IACD;;IAED,MAAM8G,gBAAwB,GAAGzB,aAAa,GAC1C,IAAAE,qBAAA,EAAaF,aAAb,EAA4B;MAAE3F;IAAF,CAA5B,CAD0C,GAE1CU,UAFJ;IAGA,MAAM2G,UAAgB,GAAG;MACvBhF,UAAU,EAAE;QACVkC,QAAQ,EAAE,KADA;QAEVpD,IAAI,EAAEiG,gBAFI;QAGVtF,IAAI,EAAE7B;MAHI,CADW;MAMvB8B,IAAI,EAAE,IANiB;MAOvBqB,QAAQ,EAAEnD,SAPa;MAQvB6C,SAAS,EAAE7C;IARY,CAAzB;;IAUA,IAAIqH,cAAc,GAAG9C,MAAA,CAAGC,IAAH,CAAQ,CAAR,CAArB;;IAEA,IAAI8C,cAAc,GAAG,IAAAC,cAAA,GAArB;;IACA,KAAK,MAAMC,KAAX,IAAoB9C,UAAU,CAACsB,GAAX,CAAe,QAAf,CAApB,EAA8C;MAC5CsB,cAAc,GAAGA,cAAc,CAACG,GAAf,CACd,GAAED,KAAK,CAACrE,QAAN,CAAgBC,MAAO,IAAGoE,KAAK,CAACrE,QAAN,CAAgBM,KAAM,EADpC,CAAjB;IAGD;;IACD,MAAMvB,aAAa,GAAG,IAAI8C,qBAAJ,CAA0BnF,QAA1B,EAAoCC,YAApC,EAAkD;MACtEC,MADsE;MAEtEG;IAFsE,CAAlD,CAAtB;;IAIA,WAAW,MAAMwH,IAAjB,IAAyBxF,aAAa,CAACD,OAAd,EAAzB,EAAkD;MAChD,MAAME,SAAS,GAAGuF,IAAlB,CADgD,CAEhD;;MACA,IACEJ,cAAc,CAACK,GAAf,CACG,GAAExF,SAAS,CAACgB,QAAV,CAAoBC,MAAO,IAAGjB,SAAS,CAACgB,QAAV,CAAoBM,KAAM,EAD7D,CADF,EAIE;QACA;MACD;;MAED,IAAIU,aAAJ;;MACA,IAAI,IAAA9C,yCAAA,EAAkCZ,UAAlC,EAA8CV,MAA9C,CAAJ,EAA2D;QACzD,MAAM6H,QAAQ,GAAGzF,SAAS,CAACC,UAAV,CAAqBlB,IAArB,CAA0BM,IAA3C;QACA2C,aAAa,GACXyD,QAAQ,CAAClF,MAAT,KAAoB,EAApB,GACI6B,MAAA,CAAGC,IAAH,CAAQ1B,iCAAiC,CAAC8E,QAAD,CAAzC,CADJ,GAEI5H,SAHN;MAID;;MACD,IAAI6H,OAAkB,GAAG,IAAzB;;MACA,IAAI,IAAA7E,mBAAA,EAAYb,SAAS,CAACC,UAAV,CAAqBP,IAAjC,EAAuC9B,MAAvC,CAAJ,EAAoD;QAClD,MAAM+H,QAAQ,GAAG/H,MAAM,CAACgI,OAAP,CAAeC,GAAhC;QACAtD,UAAU,GAAG,IAAAuD,kBAAA,EAAWvD,UAAX,EAAuB;UAClCwD,OAAO,EAAEJ,QAAQ,CAACK,QADgB;UAElChF,QAAQ,EAAE;YACRC,MAAM,EAAE0E,QAAQ,CAACM,OADT;YAER3E,KAAK,EAAEqE,QAAQ,CAACO;UAFR;QAFwB,CAAvB,CAAb;QAQA3D,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,YAAlB,EAAiCyC,UAAD,IAAgB;UAC3D,OAAOA,UAAU,CAAC5G,IAAX,CACLS,SAAS,CAACI,gBADL,EAELJ,SAAS,CAACK,iBAFL,CAAP;QAID,CALY,CAAb;QAOA,MAAM+F,qBAAqB,GAAG7D,UAAU,CAACsB,GAAX,CAAe,YAAf,EAA6BK,IAA7B,GAAoC,CAAlE;QAEA,MAAMmC,WAAW,GAAG;UAClBC,SAAS,EAAEC,YAAA,CAAMC,MAAN,CAAa9H,aAAA,CAAO+H,MAAP,CAAcC,IAAd,CAAmBN,qBAAnB,CAAb;QADO,CAApB;QAGAV,OAAO,GAAGa,YAAA,CAAMC,MAAN,CAAaG,gBAAA,CAAWC,WAAX,CAAuBF,IAAvB,CAA4BL,WAA5B,CAAb,CAAV;MACD;;MAED9D,UAAU,GAAG,MAAMsE,YAAY,CAC7BtE,UAD6B,EAE7BvC,SAF6B,EAG7B,IAAAd,yCAAA,EAAkCZ,UAAlC,EAA8CV,MAA9C,IACIkJ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBrJ,QAAlB,EAA4B;QAAEwC,KAAK,EAAE8B;MAAT,CAA5B,CADJ,GAEItE,QALyB,EAM7B;QAAEE,MAAF;QAAUoJ,cAAc,EAAEtB,OAA1B;QAAmCxF,KAAK,EAAEF,SAAS,CAACE;MAApD,CAN6B,CAA/B;;MASA,MAAM+G,aAAa,GAAG7E,MAAA,CAAGC,IAAH,CAAQrC,SAAS,CAACC,UAAV,CAAqBkC,QAA7B,CAAtB;;MACA,IAAIqC,cAAc,GAAGyC,aAArB;;MACA,IAAIzC,cAAc,CAACL,EAAf,CAAkBnB,OAAlB,CAAJ,EAAgC;QAC9BwB,cAAc,GAAGxB,OAAjB;MACD;;MACDA,OAAO,GAAGA,OAAO,CAAC0B,GAAR,CAAYF,cAAZ,CAAV;MACAU,cAAc,GAAGA,cAAc,CAACI,GAAf,CAAmB2B,aAAnB,EAAkCvC,GAAlC,CAAsCF,cAAtC,CAAjB;;MACA,IAAI,IAAA3D,mBAAA,EAAYb,SAAS,CAACC,UAAV,CAAqBP,IAAjC,EAAuC9B,MAAvC,CAAJ,EAAoD;QAClD;QACA2E,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,cAAlB,EAAmCwD,YAAD,IAAkB;UAC/D,OAAOA,YAAY,CAAC3H,IAAb,CACL;YACEwE,KAAK,EAAE,QADT;YAEEzC,KAAK,EAAEiB,UAAU,CAACsB,GAAX,CAAe,QAAf,EAAyBK,IAAzB,GAAgC;UAFzC,CADK,EAKL;YACEH,KAAK,EAAE,WADT;YAEEzC,KAAK,EAAEiB,UAAU,CAACsB,GAAX,CAAe,WAAf,EAA4BK,IAA5B,GAAmC;UAF5C,CALK,EASL;YACEH,KAAK,EAAE,YADT;YAEEzC,KAAK,EAAEiB,UAAU,CAACsB,GAAX,CAAe,YAAf,EAA6BK,IAA7B,GAAoC;UAF7C,CATK,CAAP;QAcD,CAfY,CAAb;MAgBD;;MACD,IACElB,OAAO,CAACM,EAAR,CAAW,CAAX,MACC4B,cAAc,CAAC5B,EAAf,CAAkB,CAAlB,KACC4B,cAAc,CAACf,EAAf,CAAkB,IAAAQ,sCAAA,EAA8BM,UAA9B,CAAlB,CAFF,CADF,EAIE;QACA;MACD;IACF;;IACD,IAAIC,cAAc,CAACf,EAAf,CAAkB,CAAlB,CAAJ,EAA0B;MACxBc,UAAU,CAAChF,UAAX,CAAsBkC,QAAtB,GAAiC,OAAO+C,cAAc,CAACtE,QAAf,CAAwB,EAAxB,CAAxC;MACA2B,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IACxCA,OAAO,CAACpE,IAAR,CAAa0F,UAAb,CADW,CAAb;IAGD;EACF;;EAED,IAAI,CAACrC,kBAAL,EAAyB;IACvB,OAAO,CAACL,UAAD,EAAaS,OAAb,CAAP;EACD;;EAED,IAAIA,OAAO,CAACmB,EAAR,CAAW,CAAX,CAAJ,EAAmB;IACjB,MAAM,IAAIjG,KAAJ,CAAU,sCAAV,CAAN;EACD;;EAED,OAAOqE,UAAP;AACD;;AAED,eAAe4E,qCAAf,CACE5E,UADF,EAEEC,SAFF,EAGEE,MAHF,EAIE3E,SAJF,EAKEqJ,qBALF,EAME;EACExJ,MAAM,GAAGC,SADX;EAEEgF,qBAAqB,GAAGrF,aAF1B;EAGE6J,oBAAoB,GAAG;AAHzB,CANF,EAmBG;EACDzJ,MAAM,GAAGA,MAAM,IAAI,IAAAO,wBAAA,GAAnB,CADC,CAED;;EAEA,IAAI6E,OAAO,GAAGZ,MAAA,CAAGC,IAAH,CAAQK,MAAR,CAAd;;EACA,MAAM4E,sBAAsB,GAAGlF,MAAA,CAAGC,IAAH,CAAQ+E,qBAAR,CAA/B;;EACA,IAAIC,oBAAJ,EAA0B;IACxB,KAAK,MAAM3J,QAAX,IAAuB8E,SAAvB,EAAkC;MAChC,MAAMlE,UAAkB,GAAG,IAAAD,wBAAA,EAAcX,QAAd,EAAwB;QAAEE;MAAF,CAAxB,EAAoCU,UAA/D,CADgC,CAEhC;;MACA,IACE,CAAC,IAAAY,yCAAA,EAAkCZ,UAAlC,EAA8CV,MAA9C,CAAD,IACA,CAAC,IAAAiC,iCAAA,EAA0BvB,UAA1B,EAAsCV,MAAtC,CAFH,EAGE;QACA;QACA;MACD;;MACD,MAAMgG,iBAAiB,GAAGrB,UAAU,CACjCsB,GADuB,CACnB,cADmB,EAEvBC,MAFuB,CAEhB,CAAC;QAAEC;MAAF,CAAD,KAAeA,KAAK,KAAK,SAFT,EAGvBC,KAHuB,CAGjB,CAAC;QAAE1C;MAAF,CAAD,KAAeA,KAHE,CAA1B;MAIA,IAAI2C,CAAC,GAAGL,iBAAiB,GAAGA,iBAAiB,CAACtC,KAAlB,GAA0B,CAA7B,GAAiC,CAA1D;;MACA,OAAO2C,CAAC,GAAG1B,UAAU,CAACsB,GAAX,CAAe,SAAf,EAA0BK,IAA9B,IAAsClB,OAAO,CAACmB,EAAR,CAAW,CAAX,CAA7C,EAA4D,EAAEF,CAA9D,EAAiE;QAC/D,MAAMG,MAAM,GAAG7B,UAAU,CAACsB,GAAX,CAAe,SAAf,EAA0BA,GAA1B,CAA8BI,CAA9B,CAAf;;QACA,IACE,IAAIhH,WAAJ,CAAgBmH,MAAM,CAACnE,UAAP,CAAkBlB,IAAlC,EAAwC;UAAEsF,QAAQ,EAAE;QAAZ,CAAxC,EAA6DC,MAA7D,CACE,IAAIrH,WAAJ,CAAgBqB,UAAhB,EAA4B;UAAE+F,QAAQ,EAAE;QAAZ,CAA5B,CADF,CADF,EAIE;UACA,MAAMO,YAAkB,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeX,MAAf,CAAX,CAA3B;;UACA,MAAMG,YAAY,GAAGnC,MAAA,CAAGC,IAAH,CAAQuC,YAAY,CAAC3E,UAAb,CAAwBkC,QAAhC,CAArB;;UACA,IAAIqC,cAAJ;;UACA,IAAIxB,OAAO,CAACyB,GAAR,CAAYF,YAAZ,CAAJ,EAA+B;YAC7BC,cAAc,GAAGD,YAAjB;UACD,CAFD,MAEO;YACLC,cAAc,GAAGD,YAAY,CAACG,GAAb,CACf,IAAAC,sCAAA,EAA8BC,YAA9B,CADe,CAAjB;;YAGA,IAAIJ,cAAc,CAACL,EAAf,CAAkBnB,OAAlB,CAAJ,EAAgC;cAC9BwB,cAAc,GAAGxB,OAAjB;YACD;UACF;;UACDA,OAAO,GAAGA,OAAO,CAAC0B,GAAR,CAAYF,cAAZ,CAAV;UACAI,YAAY,CAAC3E,UAAb,CAAwBkC,QAAxB,GACE,OAAOoC,YAAY,CAACG,GAAb,CAAiBF,cAAjB,EAAiC5D,QAAjC,CAA0C,EAA1C,CADT;UAGA2B,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;YACrD,OAAOA,OAAO,CAACD,MAAR,CAAeO,CAAf,EAAkB,MAAMW,YAAxB,CAAP;UACD,CAFY,CAAb;QAGD;MACF,CA3C+B,CA4ChC;;;MACArC,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;QACrD,OAAOA,OAAO,CAACG,MAAR,CACJM,MAAD,IAAY,CAAChC,MAAA,CAAGC,IAAH,CAAQ+B,MAAM,CAACnE,UAAP,CAAkBkC,QAA1B,EAAoCmB,EAApC,CAAuC,CAAvC,CADR,CAAP;MAGD,CAJY,CAAb;IAKD;EACF;EAED;AACF;AACA;;;EACE,IAAI4B,cAAc,GAAG9C,MAAA,CAAGC,IAAH,CAAQ,CAAR,CAArB;;EACA,IAAIW,OAAO,CAACmB,EAAR,CAAW,CAAX,CAAJ,EAAmB;IACjB,MAAMxG,YAAY,GAAG4E,UAAU,CAACsB,GAAX,CAAe,cAAf,CAArB;;IACA,IAAI,CAAClG,YAAL,EAAmB;MACjB,MAAM,IAAIO,KAAJ,CAAU,2BAAV,CAAN;IACD;;IAED,MAAMqJ,WAAW,GAAIlC,KAAD,IACjB,GAAEA,KAAK,CAACrE,QAAN,CAAgBC,MAAO,IAAGoE,KAAK,CAACrE,QAAN,CAAgBM,KAAM,EADrD;;IAEA,IAAI6D,cAAc,GAAG,IAAAC,cAAA,GAArB;;IACA,KAAK,MAAMC,KAAX,IAAoB9C,UAAU,CAACsB,GAAX,CAAe,QAAf,CAApB,EAA8C;MAC5CsB,cAAc,GAAGA,cAAc,CAACG,GAAf,CAAmBiC,WAAW,CAAClC,KAAD,CAA9B,CAAjB;IACD;;IAED,KAAK,MAAM3H,QAAX,IAAuB8E,SAAvB,EAAkC;MAChC,MAAMlE,UAAkB,GAAG,IAAAD,wBAAA,EAAcX,QAAd,EAAwB;QAAEE;MAAF,CAAxB,EAAoCU,UAA/D;MACA,MAAMyB,aAAa,GAAG,IAAI8C,qBAAJ,CAA0BnF,QAA1B,EAAoCC,YAApC,EAAkD;QACtEC,MADsE;QAEtEG;MAFsE,CAAlD,CAAtB;;MAIA,WAAW,MAAMwH,IAAjB,IAAyBxF,aAAa,CAACD,OAAd,EAAzB,EAAkD;QAChD,MAAME,SAAS,GAAGuF,IAAlB,CADgD,CAEhD;;QACA,IAAIJ,cAAc,CAACK,GAAf,CAAmB+B,WAAW,CAACvH,SAAD,CAA9B,CAAJ,EAAgD;UAC9C;QACD;;QAED,IAAI0F,OAAkB,GAAG,IAAzB;;QACA,IAAI,IAAA7E,mBAAA,EAAYb,SAAS,CAACC,UAAV,CAAqBP,IAAjC,EAAuC9B,MAAvC,CAAJ,EAAoD;UAClD,MAAM+H,QAAQ,GAAG/H,MAAM,CAACgI,OAAP,CAAeC,GAAhC;UACAtD,UAAU,GAAG,IAAAuD,kBAAA,EAAWvD,UAAX,EAAuB;YAClCwD,OAAO,EAAEJ,QAAQ,CAACK,QADgB;YAElChF,QAAQ,EAAE;cACRC,MAAM,EAAE0E,QAAQ,CAACM,OADT;cAER3E,KAAK,EAAEqE,QAAQ,CAACO;YAFR;UAFwB,CAAvB,CAAb;UAQA3D,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,YAAlB,EAAiCyC,UAAD,IAAgB;YAC3D,OAAOA,UAAU,CAAC5G,IAAX,CACLS,SAAS,CAACI,gBADL,EAELJ,SAAS,CAACK,iBAFL,CAAP;UAID,CALY,CAAb;UAOA,MAAM+F,qBAAqB,GAAG7D,UAAU,CAACsB,GAAX,CAAe,YAAf,EAA6BK,IAA7B,GAAoC,CAAlE;UACA,MAAMmC,WAAW,GAAG;YAClBC,SAAS,EAAEC,YAAA,CAAMC,MAAN,CAAa9H,aAAA,CAAO+H,MAAP,CAAcC,IAAd,CAAmBN,qBAAnB,CAAb;UADO,CAApB;UAGAV,OAAO,GAAGa,YAAA,CAAMC,MAAN,CAAaG,gBAAA,CAAWC,WAAX,CAAuBF,IAAvB,CAA4BL,WAA5B,CAAb,CAAV;QACD;;QACD,IAAIrE,aAAJ;;QACA,IAAI,IAAA9C,yCAAA,EAAkCZ,UAAlC,EAA8CV,MAA9C,CAAJ,EAA2D;UACzD;UACA,MAAM6H,QAAQ,GAAGzF,SAAS,CAACC,UAAV,CAAqBlB,IAArB,CAA0BM,IAA3C;UACA2C,aAAa,GACXyD,QAAQ,CAAClF,MAAT,KAAoB,EAApB,GACI6B,MAAA,CAAGC,IAAH,CAAQ1B,iCAAiC,CAAC8E,QAAD,CAAzC,CADJ,GAEI5H,SAHN;QAID;;QACD0E,UAAU,GAAG,MAAMsE,YAAY,CAC7BtE,UAD6B,EAE7BvC,SAF6B,EAG7B8G,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBrJ,QAAlB,EAA4B;UAAEwC,KAAK,EAAE8B;QAAT,CAA5B,CAH6B,EAI7B;UACEpE,MADF;UAEEoJ,cAAc,EAAEtB,OAFlB;UAGExF,KAAK,EAAEF,SAAS,CAACE;QAHnB,CAJ6B,CAA/B;;QAWA,MAAM+G,aAAa,GAAG7E,MAAA,CAAGC,IAAH,CAAQrC,SAAS,CAACC,UAAV,CAAqBkC,QAA7B,CAAtB;;QACA,IAAIqC,cAAc,GAAGyC,aAArB;;QACA,IAAIzC,cAAc,CAACL,EAAf,CAAkBnB,OAAlB,CAAJ,EAAgC;UAC9BwB,cAAc,GAAGxB,OAAjB;QACD;;QACDA,OAAO,GAAGA,OAAO,CAAC0B,GAAR,CAAYF,cAAZ,CAAV;QACAU,cAAc,GAAGA,cAAc,CAACI,GAAf,CAAmB2B,aAAnB,EAAkCvC,GAAlC,CAAsCF,cAAtC,CAAjB;;QAEA,IAAI,IAAA3D,mBAAA,EAAYb,SAAS,CAACC,UAAV,CAAqBP,IAAjC,EAAuC9B,MAAvC,CAAJ,EAAoD;UAClD;UACA2E,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,cAAlB,EAAmCwD,YAAD,IAAkB;YAC/D,OAAOA,YAAY,CAAC3H,IAAb,CACL;cACEwE,KAAK,EAAE,QADT;cAEEzC,KAAK,EAAEiB,UAAU,CAACsB,GAAX,CAAe,QAAf,EAAyBK,IAAzB,GAAgC;YAFzC,CADK,EAKL;cACEH,KAAK,EAAE,WADT;cAEEzC,KAAK,EAAEiB,UAAU,CAACsB,GAAX,CAAe,WAAf,EAA4BK,IAA5B,GAAmC;YAF5C,CALK,EASL;cACEH,KAAK,EAAE,YADT;cAEEzC,KAAK,EAAEiB,UAAU,CAACsB,GAAX,CAAe,YAAf,EAA6BK,IAA7B,GAAoC;YAF7C,CATK,CAAP;UAcD,CAfY,CAAb;QAgBD;;QAED,IACElB,OAAO,CAACM,EAAR,CAAW,CAAX,MACC4B,cAAc,CAAC5B,EAAf,CAAkB,CAAlB,KAAwB4B,cAAc,CAACf,EAAf,CAAkBmD,sBAAlB,CADzB,CADF,EAGE;UACA;QACD;MACF;IACF;EACF;;EAED,OAAO;IACL/E,UADK;IAELJ,QAAQ,EAAEC,MAAA,CAAGC,IAAH,CAAQW,OAAO,CAACpC,QAAR,EAAR,CAFL;IAGLsE,cAAc,EAAE9C,MAAA,CAAGC,IAAH,CAAQ6C,cAAc,CAACtE,QAAf,EAAR;EAHX,CAAP;AAKD;;AAED,eAAe4G,2BAAf,CACEjF,UADF,EAEEC,SAFF,EAGEE,MAHF,EAIE3E,SAJF,EAKEqJ,qBALF,EAME;EACExJ,MAAM,GAAGC,SADX;EAEEgF,qBAAqB,GAAGrF,aAF1B;EAGE6J,oBAAoB,GAAG;AAHzB,CANF,EAmBG;EACD,MAAMjJ,MAAM,GAAG,MAAM+I,qCAAqC,CACxD5E,UADwD,EAExDC,SAFwD,EAGxDE,MAHwD,EAIxD3E,SAJwD,EAKxDqJ,qBALwD,EAMxD;IACExJ,MADF;IAEEiF,qBAFF;IAGEwE;EAHF,CANwD,CAA1D;EAaA,OAAO;IACL9E,UAAU,EAAEnE,MAAM,CAACmE,UADd;IAELJ,QAAQ,EAAE/D,MAAM,CAAC+D,QAAP,CAAgBsF,QAAhB,EAFL;IAGLvC,cAAc,EAAE9G,MAAM,CAAC8G,cAAP,CAAsBuC,QAAtB;EAHX,CAAP;AAKD;;AAEM,eAAeC,MAAf,CACLnF,UADK,EAELC,SAFK,EAGLE,MAHK,EAIL3E,SAJK,EAKL;EACEH,MAAM,GAAGC,SADX;EAEEgF,qBAAqB,GAAGrF;AAF1B,IAMI,EAXC,EAY6B;EAClC,OAAOsF,kBAAkB,CACvBP,UADuB,EAEvBC,SAFuB,EAGvB3E,SAHuB,EAIvB6E,MAJuB,EAKvB3E,SALuB,EAMvB;IACEH,MADF;IAEE+E,gBAAgB,EAAE,KAFpB;IAGEE;EAHF,CANuB,CAAzB;AAYD;;AAEM,SAAS8E,qBAAT,CACLpF,UADK,EAEL;EAAE3E,MAAM,GAAGC;AAAX,IAAkC,EAF7B,EAGoB;EACzBD,MAAM,GAAGA,MAAM,IAAI,IAAAO,wBAAA,GAAnB;EACAoE,UAAU,GAAG,IAAAqF,6BAAA,EAAuBrF,UAAvB,EAAmC3E,MAAnC,EAA2C,oBAA3C,CAAb;EACA2E,UAAU,GAAG,IAAAqF,6BAAA,EACXrF,UADW,EAEX3E,MAFW,EAGX,6BAHW,CAAb;EAKA,OAAO2E,UAAP;AACD;;AAEM,eAAesF,cAAf,CACLtF,UADK,EAELuF,WAFK,EAGLtF,SAHK,EAILzE,SAJK,EAKL;EACEH,MAAM,GAAGC,SADX;EAEEgF,qBAAqB,GAAGrF;AAF1B,IAOI,EAZC,EAa6B;EAClCI,MAAM,GAAGA,MAAM,IAAI,IAAAO,wBAAA,GAAnB;;EACA,IAAI2J,WAAW,IAAIvF,UAAU,CAACsB,GAAX,CAAe,SAAf,EAA0BK,IAA7C,EAAmD;IACjD,MAAM,IAAIhG,KAAJ,CAAU,uBAAV,CAAN;EACD;;EACD,MAAMiE,QAAQ,GAAGC,MAAA,CAAGC,IAAH,CACfE,UAAU,CAACsB,GAAX,CAAe,SAAf,EAA0BA,GAA1B,CAA8BiE,WAA9B,EAA4C7H,UAA5C,CAAuDkC,QADxC,CAAjB;;EAGA,OAAOW,kBAAkB,CACvBP,UADuB,EAEvBC,SAFuB,EAGvB3E,SAHuB,EAIvBuE,MAAA,CAAGC,IAAH,CAAQF,QAAR,CAJuB,EAKvBpE,SALuB,EAMvB;IACEH,MADF;IAEE+E,gBAAgB,EAAE,KAFpB;IAGEE;EAHF,CANuB,CAAzB;AAYD;;AAED,eAAegE,YAAf,CACEtE,UADF,EAEEvC,SAFF,EAGEtC,QAHF,EAIE;EACEE,MAAM,GAAGC,SADX;EAEEqC,KAAK,GAAGrC,SAFV;EAGEmJ,cAAc,GAAG;AAHnB,IAImE,EARrE,EASoC;EAClCpJ,MAAM,GAAGA,MAAM,IAAI,IAAAO,wBAAA,GAAnB;EAEAoE,UAAU,GAAG,MAAMwF,cAAc,CAACxF,UAAD,EAAavC,SAAb,EAAwBtC,QAAxB,EAAkC;IACjEE,MADiE;IAEjEsC,KAFiE;IAGjE8G;EAHiE,CAAlC,CAAjC;EAMAzE,UAAU,GAAGA,UAAU,CAACmB,MAAX,CAAkB,SAAlB,EAA8BC,OAAD,IAAa;IACrD,OAAOA,OAAO,CAACqE,MAAR,CAAerE,OAAO,CAACO,IAAR,GAAe,CAA9B,CAAP;EACD,CAFY,CAAb;EAIA,OAAO3B,UAAP;AACD;;AAEM,eAAewF,cAAf,CACLxF,UADK,EAELvC,SAFK,EAGLtC,QAHK,EAIL;EACEE,MAAM,GAAGC,SADX;EAEEqC,KAAK,GAAGrC,SAFV;EAGEmJ,cAAc,GAAG;AAHnB,IAImE,EAR9D,EAS6B;EAClCpJ,MAAM,GAAGA,MAAM,IAAI,IAAAO,wBAAA,GAAnB;EACA,MAAM8J,SAAS,GAAGjI,SAAS,CAACC,UAAV,CAAqBlB,IAAvC;;EAEA,IAAI,IAAAc,iCAAA,EAA0BoI,SAA1B,EAAqCrK,MAArC,CAAJ,EAAkD;IAChD,OAAOsK,wBAAA,CAAkBH,cAAlB,CAAiCxF,UAAjC,EAA6CvC,SAA7C,EAAwDtC,QAAxD,EAAkE;MACvEE,MADuE;MAEvEoJ,cAFuE;MAGvE9G;IAHuE,CAAlE,CAAP;EAKD,CAND,MAMO,IAAI,IAAAhB,yCAAA,EAAkC+I,SAAlC,EAA6CrK,MAA7C,CAAJ,EAA0D;IAC/D,OAAOuK,2BAAA,CAA0BJ,cAA1B,CACLxF,UADK,EAELvC,SAFK,EAGLtC,QAHK,EAIL;MACEE,MADF;MAEEoJ,cAFF;MAGE9G;IAHF,CAJK,CAAP;EAUD,CAXM,MAWA;IACL,MAAM,IAAIhC,KAAJ,CAAW,2BAAX,CAAN;EACD;AACF;;AAED,SAASyC,iCAAT,CAA2CtB,IAA3C,EAAgE;EAC9D,IAAIA,IAAI,CAACkB,MAAL,KAAgB,EAApB,EAAwB;IACtB,MAAM,IAAIrC,KAAJ,CAAU,mCAAV,CAAN;EACD;;EACD,OAAOQ,aAAA,CAAO0J,QAAP,CAAgBC,MAAhB,CAAuB,OAAOhJ,IAAI,CAACC,KAAL,CAAW,EAAX,CAA9B,CAAP;AACD;;eAEc;EACb9B,aADa;EAEb8E,QAFa;EAGbQ,kBAHa;EAIb4E,MAJa;EAKbC,qBALa;EAMbE,cANa;EAObE,cAPa;EAQbP,2BARa;EASbL;AATa,C"}