import { TransactionSkeletonType, Options } from "@ckb-lumos/helpers";
import { BytesLike } from "@ckb-lumos/codec";
import { Cell, Script, HexString, PackedSince } from "@ckb-lumos/base";
import { FromInfo } from ".";
import { CellCollectorConstructor } from "./type";
export declare type OmnilockInfo = {
    auth: {
        flag: "ETHEREUM" | "SECP256K1_BLAKE160";
        /**
         * if auth flag is SECP256K1_BLAKE160, content is publicKeyToBlake160(secp256k1Pubkey)
         * if auth flag is ETHEREUM, content is Ethereum address
         */
        content: BytesLike;
    };
};
/**
 * only support ETHEREUM and SECP256K1_BLAKE160 mode currently
 * refer to: @link https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md omnilock
 * @param omnilockInfo
 * @param options
 * @returns
 */
export declare function createOmnilockScript(omnilockInfo: OmnilockInfo, options?: Options): Script;
export declare const OmnilockWitnessLock: import("@ckb-lumos/codec/lib/base").BytesCodec<Partial<Pick<{
    signature: string | undefined;
    omni_identity: (Partial<Pick<{
        identity: string;
        proofs: (Partial<Pick<{
            mask: string;
            proof: string;
        }, never>> & Pick<{
            mask: string;
            proof: string;
        }, "mask" | "proof">)[];
    }, never>> & Pick<{
        identity: string;
        proofs: (Partial<Pick<{
            mask: string;
            proof: string;
        }, never>> & Pick<{
            mask: string;
            proof: string;
        }, "mask" | "proof">)[];
    }, "identity" | "proofs">) | undefined;
    preimage: string | undefined;
}, "signature" | "omni_identity" | "preimage">> & Pick<{
    signature: string | undefined;
    omni_identity: (Partial<Pick<{
        identity: string;
        proofs: (Partial<Pick<{
            mask: string;
            proof: string;
        }, never>> & Pick<{
            mask: string;
            proof: string;
        }, "mask" | "proof">)[];
    }, never>> & Pick<{
        identity: string;
        proofs: (Partial<Pick<{
            mask: string;
            proof: string;
        }, never>> & Pick<{
            mask: string;
            proof: string;
        }, "mask" | "proof">)[];
    }, "identity" | "proofs">) | undefined;
    preimage: string | undefined;
}, never>, Partial<Pick<{
    signature: string | ArrayBuffer | ArrayLike<number> | undefined;
    omni_identity: (Partial<Pick<{
        identity: BytesLike;
        proofs: (Partial<Pick<{
            mask: BytesLike;
            proof: BytesLike;
        }, never>> & Pick<{
            mask: BytesLike;
            proof: BytesLike;
        }, "mask" | "proof">)[];
    }, never>> & Pick<{
        identity: BytesLike;
        proofs: (Partial<Pick<{
            mask: BytesLike;
            proof: BytesLike;
        }, never>> & Pick<{
            mask: BytesLike;
            proof: BytesLike;
        }, "mask" | "proof">)[];
    }, "identity" | "proofs">) | undefined;
    preimage: string | ArrayBuffer | ArrayLike<number> | undefined;
}, "signature" | "omni_identity" | "preimage">> & Pick<{
    signature: string | ArrayBuffer | ArrayLike<number> | undefined;
    omni_identity: (Partial<Pick<{
        identity: BytesLike;
        proofs: (Partial<Pick<{
            mask: BytesLike;
            proof: BytesLike;
        }, never>> & Pick<{
            mask: BytesLike;
            proof: BytesLike;
        }, "mask" | "proof">)[];
    }, never>> & Pick<{
        identity: BytesLike;
        proofs: (Partial<Pick<{
            mask: BytesLike;
            proof: BytesLike;
        }, never>> & Pick<{
            mask: BytesLike;
            proof: BytesLike;
        }, "mask" | "proof">)[];
    }, "identity" | "proofs">) | undefined;
    preimage: string | ArrayBuffer | ArrayLike<number> | undefined;
}, never>>;
export declare const CellCollector: CellCollectorConstructor;
/**
 * Setup input cell infos, such as cell deps and witnesses.
 *
 * @param txSkeleton
 * @param inputCell
 * @param _fromInfo
 * @param options
 */
export declare function setupInputCell(txSkeleton: TransactionSkeletonType, inputCell: Cell, _fromInfo?: FromInfo, { config, defaultWitness, since, }?: Options & {
    defaultWitness?: HexString;
    since?: PackedSince;
}): Promise<TransactionSkeletonType>;
/**
 * prepare for txSkeleton signingEntries, will update txSkeleton.get("signingEntries")
 *
 * @param txSkeleton
 * @param options
 */
export declare function prepareSigningEntries(txSkeleton: TransactionSkeletonType, { config }?: Options): TransactionSkeletonType;
declare const _default: {
    prepareSigningEntries: typeof prepareSigningEntries;
    setupInputCell: typeof setupInputCell;
    CellCollector: CellCollectorConstructor;
    OmnilockWitnessLock: import("@ckb-lumos/codec/lib/base").BytesCodec<Partial<Pick<{
        signature: string | undefined;
        omni_identity: (Partial<Pick<{
            identity: string;
            proofs: (Partial<Pick<{
                mask: string;
                proof: string;
            }, never>> & Pick<{
                mask: string;
                proof: string;
            }, "mask" | "proof">)[];
        }, never>> & Pick<{
            identity: string;
            proofs: (Partial<Pick<{
                mask: string;
                proof: string;
            }, never>> & Pick<{
                mask: string;
                proof: string;
            }, "mask" | "proof">)[];
        }, "identity" | "proofs">) | undefined;
        preimage: string | undefined;
    }, "signature" | "omni_identity" | "preimage">> & Pick<{
        signature: string | undefined;
        omni_identity: (Partial<Pick<{
            identity: string;
            proofs: (Partial<Pick<{
                mask: string;
                proof: string;
            }, never>> & Pick<{
                mask: string;
                proof: string;
            }, "mask" | "proof">)[];
        }, never>> & Pick<{
            identity: string;
            proofs: (Partial<Pick<{
                mask: string;
                proof: string;
            }, never>> & Pick<{
                mask: string;
                proof: string;
            }, "mask" | "proof">)[];
        }, "identity" | "proofs">) | undefined;
        preimage: string | undefined;
    }, never>, Partial<Pick<{
        signature: string | ArrayBuffer | ArrayLike<number> | undefined;
        omni_identity: (Partial<Pick<{
            identity: BytesLike;
            proofs: (Partial<Pick<{
                mask: BytesLike;
                proof: BytesLike;
            }, never>> & Pick<{
                mask: BytesLike;
                proof: BytesLike;
            }, "mask" | "proof">)[];
        }, never>> & Pick<{
            identity: BytesLike;
            proofs: (Partial<Pick<{
                mask: BytesLike;
                proof: BytesLike;
            }, never>> & Pick<{
                mask: BytesLike;
                proof: BytesLike;
            }, "mask" | "proof">)[];
        }, "identity" | "proofs">) | undefined;
        preimage: string | ArrayBuffer | ArrayLike<number> | undefined;
    }, "signature" | "omni_identity" | "preimage">> & Pick<{
        signature: string | ArrayBuffer | ArrayLike<number> | undefined;
        omni_identity: (Partial<Pick<{
            identity: BytesLike;
            proofs: (Partial<Pick<{
                mask: BytesLike;
                proof: BytesLike;
            }, never>> & Pick<{
                mask: BytesLike;
                proof: BytesLike;
            }, "mask" | "proof">)[];
        }, never>> & Pick<{
            identity: BytesLike;
            proofs: (Partial<Pick<{
                mask: BytesLike;
                proof: BytesLike;
            }, never>> & Pick<{
                mask: BytesLike;
                proof: BytesLike;
            }, "mask" | "proof">)[];
        }, "identity" | "proofs">) | undefined;
        preimage: string | ArrayBuffer | ArrayLike<number> | undefined;
    }, never>>;
    createOmnilockScript: typeof createOmnilockScript;
};
export default _default;
//# sourceMappingURL=omnilock.d.ts.map