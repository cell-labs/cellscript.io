"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OmnilockWitnessLock = exports.CellCollector = void 0;
exports.createOmnilockScript = createOmnilockScript;
exports.default = void 0;
exports.prepareSigningEntries = prepareSigningEntries;
exports.setupInputCell = setupInputCell;

var _codec = require("@ckb-lumos/codec");

var _base = require("@ckb-lumos/base");

var _configManager = require("@ckb-lumos/config-manager");

var _helper = require("./helper");

var _from_info = require("./from_info");

var _molecule = require("@ckb-lumos/codec/lib/molecule");

var _blockchain = require("@ckb-lumos/codec/lib/blockchain");

var _bytes = require("@ckb-lumos/codec/lib/bytes");

const {
  ScriptValue
} = _base.values;

/**
 * only support ETHEREUM and SECP256K1_BLAKE160 mode currently
 * refer to: @link https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md omnilock
 * @param omnilockInfo
 * @param options
 * @returns
 */
function createOmnilockScript(omnilockInfo, options) {
  const config = (options === null || options === void 0 ? void 0 : options.config) || (0, _configManager.getConfig)();
  const omnilockConfig = config.SCRIPTS.OMNILOCK;

  if (!omnilockConfig) {
    throw new Error("OMNILOCK script config not found.");
  }

  const args = (() => {
    // omni flag       pubkey hash   omni lock flags
    // chain identity   eth addr      function flag()
    // 00: Nervos       ðŸ‘‡            00: owner
    // 01: Ethereum     ðŸ‘‡            01: administrator
    if (omnilockInfo.auth.flag === "ETHEREUM") {
      return `0x01${_codec.bytes.hexify(omnilockInfo.auth.content).slice(2)}00`;
    }

    if (omnilockInfo.auth.flag === "SECP256K1_BLAKE160") {
      return `0x00${_codec.bytes.hexify(omnilockInfo.auth.content).slice(2)}00`;
    }

    throw new Error(`Not supported flag: ${omnilockInfo.auth.flag}.`);
  })();

  const script = {
    codeHash: omnilockConfig.CODE_HASH,
    hashType: omnilockConfig.HASH_TYPE,
    args
  };
  return script;
}

const Hexify = {
  pack: _bytes.bytify,
  unpack: _bytes.hexify
};
const Identity = (0, _blockchain.createFixedHexBytesCodec)(21);
const SmtProof = (0, _molecule.byteVecOf)(Hexify);
const SmtProofEntry = (0, _molecule.table)({
  mask: (0, _molecule.byteOf)(Hexify),
  proof: SmtProof
}, ["mask", "proof"]);
const SmtProofEntryVec = (0, _molecule.vector)(SmtProofEntry);
const OmniIdentity = (0, _molecule.table)({
  identity: Identity,
  proofs: SmtProofEntryVec
}, ["identity", "proofs"]);
const OmniIdentityOpt = (0, _molecule.option)(OmniIdentity);
const OmnilockWitnessLock = (0, _molecule.table)({
  signature: _blockchain.BytesOpt,
  omni_identity: OmniIdentityOpt,
  preimage: _blockchain.BytesOpt
}, ["signature", "omni_identity", "preimage"]);
exports.OmnilockWitnessLock = OmnilockWitnessLock;
const CellCollector = class CellCollector {
  constructor(fromInfo, cellProvider, {
    config = undefined,
    queryOptions = {}
  } = {}) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }

    config = config || (0, _configManager.getConfig)();
    this.fromScript = (0, _from_info.parseFromInfo)(fromInfo, {
      config
    }).fromScript;
    this.config = config;
    queryOptions = { ...queryOptions,
      lock: this.fromScript,
      type: queryOptions.type || "empty"
    };
    this.cellCollector = cellProvider.collector(queryOptions);
  }

  async *collect() {
    if (!(0, _helper.isOmnilockScript)(this.fromScript, this.config)) {
      return;
    }

    for await (const inputCell of this.cellCollector.collect()) {
      yield inputCell;
    }
  }

};
/**
 * Setup input cell infos, such as cell deps and witnesses.
 *
 * @param txSkeleton
 * @param inputCell
 * @param _fromInfo
 * @param options
 */

exports.CellCollector = CellCollector;

async function setupInputCell(txSkeleton, inputCell, _fromInfo, {
  config = undefined,
  defaultWitness = "0x",
  since = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const fromScript = inputCell.cellOutput.lock;

  if (!(0, _helper.isOmnilockScript)(fromScript, config)) {
    throw new Error(`Not OMNILOCK input!`);
  } // add inputCell to txSkeleton


  txSkeleton = txSkeleton.update("inputs", inputs => {
    return inputs.push(inputCell);
  });
  const output = {
    cellOutput: {
      capacity: inputCell.cellOutput.capacity,
      lock: inputCell.cellOutput.lock,
      type: inputCell.cellOutput.type
    },
    data: inputCell.data
  };
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push(output);
  });

  if (since) {
    txSkeleton = txSkeleton.update("inputSinces", inputSinces => {
      return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
    });
  }

  txSkeleton = txSkeleton.update("witnesses", witnesses => {
    return witnesses.push(defaultWitness);
  });
  const template = config.SCRIPTS.OMNILOCK;
  const secp256k1Template = config.SCRIPTS.SECP256K1_BLAKE160;

  if (!template) {
    throw new Error(`OMNILOCK script not defined in config!`);
  }

  if (!secp256k1Template) {
    throw new Error(`SECP256K1_BLAKE160 script not defined in config!`);
  }

  const omnilockOutPoint = {
    txHash: template.TX_HASH,
    index: template.INDEX
  };
  const secp256k1OutPoint = {
    txHash: secp256k1Template.TX_HASH,
    index: secp256k1Template.INDEX
  }; // add cell dep

  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
    outPoint: omnilockOutPoint,
    depType: template.DEP_TYPE
  });
  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
    outPoint: secp256k1OutPoint,
    depType: secp256k1Template.DEP_TYPE
  }); // add witness

  /*
   * Modify the skeleton, so the first witness of the fromAddress script group
   * has a WitnessArgs construct with 85-byte zero filled values. While this
   * is not required, it helps in transaction fee estimation.
   */

  const firstIndex = txSkeleton.get("inputs").findIndex(input => new ScriptValue(input.cellOutput.lock, {
    validate: false
  }).equals(new ScriptValue(fromScript, {
    validate: false
  })));

  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", witnesses => witnesses.push("0x"));
    }

    let witness = txSkeleton.get("witnesses").get(firstIndex);
    const newWitnessArgs = {
      /* 85-byte zeros in hex */
      lock: _helper.OMNILOCK_SIGNATURE_PLACEHOLDER
    };
    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));
    txSkeleton = txSkeleton.update("witnesses", witnesses => witnesses.set(firstIndex, witness));
  }

  return txSkeleton;
}
/**
 * prepare for txSkeleton signingEntries, will update txSkeleton.get("signingEntries")
 *
 * @param txSkeleton
 * @param options
 */


function prepareSigningEntries(txSkeleton, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  return (0, _helper.prepareSigningEntries)(txSkeleton, config, "OMNILOCK");
}

var _default = {
  prepareSigningEntries,
  setupInputCell,
  CellCollector,
  OmnilockWitnessLock,
  createOmnilockScript
};
exports.default = _default;
//# sourceMappingURL=omnilock.js.map