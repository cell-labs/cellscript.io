"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.injectCapacity = injectCapacity;
exports.payFee = payFee;
exports.payFeeByFeeRate = payFeeByFeeRate;
exports.prepareSigningEntries = prepareSigningEntries;
exports.registerCustomLockScriptInfos = registerCustomLockScriptInfos;
exports.setupInputCell = setupInputCell;
exports.transfer = transfer;

var _helpers = require("@ckb-lumos/helpers");

var _secp256k1_blake160_multisig = _interopRequireDefault(require("./secp256k1_blake160_multisig"));

var _from_info = require("./from_info");

var _secp256k1_blake = _interopRequireDefault(require("./secp256k1_blake160"));

var _configManager = require("@ckb-lumos/config-manager");

var _locktime_pool = _interopRequireWildcard(require("./locktime_pool"));

var _base = require("@ckb-lumos/base");

var _anyone_can_pay = _interopRequireDefault(require("./anyone_can_pay"));

var _immutable = require("immutable");

var _helper = require("./helper");

var _bi = require("@ckb-lumos/bi");

var _omnilock = _interopRequireDefault(require("./omnilock"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  ScriptValue
} = _base.values;

function defaultLogger(level, message) {
  console.log(`[${level}] ${message}`);
}
/**
 * CellCollector should be a class which implement CellCollectorInterface.
 * If you want to work well with `transfer`, `injectCapacity`, `payFee`, `payFeeByFeeRate`,
 *  please add the `output` at the end of `txSkeleton.get("outputs")`
 */


/**
 * `infos` includes predefined and customized.
 */
const lockScriptInfos = {
  configHashCode: 0,
  _predefinedInfos: [],
  _customInfos: [],

  get infos() {
    return [...this._predefinedInfos, ...this._customInfos];
  }

};

function resetLockScriptInfos() {
  lockScriptInfos.configHashCode = 0;
  lockScriptInfos._predefinedInfos = [];
  lockScriptInfos._customInfos = [];
}

function getLockScriptInfos() {
  return lockScriptInfos;
}

function registerCustomLockScriptInfos(infos) {
  lockScriptInfos._customInfos = infos;
}

function generateLockScriptInfos({
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)(); // lazy load

  const getPredefinedInfos = () => {
    var _config, _config2, _config3, _config4;

    const secpTemplate = (_config = config) === null || _config === void 0 ? void 0 : _config.SCRIPTS.SECP256K1_BLAKE160;
    const multisigTemplate = (_config2 = config) === null || _config2 === void 0 ? void 0 : _config2.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
    const acpTemplate = (_config3 = config) === null || _config3 === void 0 ? void 0 : _config3.SCRIPTS.ANYONE_CAN_PAY;
    const omnilockTemplate = (_config4 = config) === null || _config4 === void 0 ? void 0 : _config4.SCRIPTS.OMNILOCK;
    const predefinedInfos = [];

    if (secpTemplate) {
      predefinedInfos.push({
        codeHash: secpTemplate.CODE_HASH,
        hashType: secpTemplate.HASH_TYPE,
        lockScriptInfo: _secp256k1_blake.default
      });
    } else {
      defaultLogger("warn", "SECP256K1_BLAKE160 script info not found in config!");
    }

    if (multisigTemplate) {
      predefinedInfos.push({
        codeHash: multisigTemplate.CODE_HASH,
        hashType: multisigTemplate.HASH_TYPE,
        lockScriptInfo: _secp256k1_blake160_multisig.default
      });
    } else {
      defaultLogger("warn", "SECP256K1_BLAKE160_MULTISIG script info not found in config!");
    }

    if (acpTemplate) {
      predefinedInfos.push({
        codeHash: acpTemplate.CODE_HASH,
        hashType: acpTemplate.HASH_TYPE,
        lockScriptInfo: _anyone_can_pay.default
      });
    } else {
      defaultLogger("warn", "ANYONE_CAN_PAY script info not found in config!");
    }

    if (omnilockTemplate) {
      predefinedInfos.push({
        codeHash: omnilockTemplate.CODE_HASH,
        hashType: omnilockTemplate.HASH_TYPE,
        lockScriptInfo: _omnilock.default
      });
    } else {
      defaultLogger("warn", "OMNILOCK script info not found in config!");
    }

    return predefinedInfos;
  };

  const configHashCode = _base.utils.hashCode(Buffer.from(JSON.stringify(config)));

  if (lockScriptInfos.infos.length === 0) {
    lockScriptInfos._predefinedInfos = getPredefinedInfos();
    lockScriptInfos.configHashCode = configHashCode;
  } else {
    if (configHashCode !== lockScriptInfos.configHashCode) {
      defaultLogger(`warn`, "`config` changed, regenerate lockScriptInfos!");
      lockScriptInfos._predefinedInfos = getPredefinedInfos();
      lockScriptInfos.configHashCode = configHashCode;
    }
  }
}
/**
 *
 * @param txSkeleton
 * @param fromInfos
 * @param toAddress
 * @param changeAddress
 * @param amount
 * @param tipHeader will not use locktime cells if tipHeader not provided
 * @param options
 */


async function transfer(txSkeleton, fromInfos, toAddress, amount, changeAddress, tipHeader, {
  config = undefined,
  useLocktimeCellsFirst = true,
  LocktimePoolCellCollector = _locktime_pool.CellCollector
} = {}) {
  var _targetLockScriptInfo;

  config = config || (0, _configManager.getConfig)();

  const _amount = _bi.BI.from(amount);

  if (!toAddress) {
    throw new Error("You must provide a to address!");
  }

  const toScript = (0, _helpers.parseAddress)(toAddress, {
    config
  });
  const targetOutput = {
    cellOutput: {
      capacity: "0x" + _amount.toString(16),
      lock: toScript,
      type: undefined
    },
    data: "0x"
  };
  generateLockScriptInfos({
    config
  });
  const targetLockScriptInfo = lockScriptInfos.infos.find(lockScriptInfo => {
    return lockScriptInfo.codeHash === toScript.codeHash && lockScriptInfo.hashType === toScript.hashType;
  });

  if (targetLockScriptInfo && (_targetLockScriptInfo = targetLockScriptInfo.lockScriptInfo) !== null && _targetLockScriptInfo !== void 0 && _targetLockScriptInfo.setupOutputCell) {
    txSkeleton = await targetLockScriptInfo.lockScriptInfo.setupOutputCell(txSkeleton, targetOutput, {
      config
    });
  } else {
    txSkeleton = txSkeleton.update("outputs", outputs => {
      return outputs.push(targetOutput);
    });
  }

  txSkeleton = await injectCapacity(txSkeleton, fromInfos, _amount.toString(), changeAddress, tipHeader, {
    config,
    useLocktimeCellsFirst,
    LocktimePoolCellCollector
  });
  return txSkeleton;
}

async function injectCapacity(txSkeleton, fromInfos, amount, changeAddress, tipHeader, {
  config = undefined,
  useLocktimeCellsFirst = true,
  LocktimePoolCellCollector = _locktime_pool.CellCollector,
  enableDeductCapacity = true
} = {}) {
  config = config || (0, _configManager.getConfig)();

  const _amount = _bi.BI.from(amount);

  let deductAmount = _amount;

  if (fromInfos.length === 0) {
    throw new Error("No from info provided!");
  }

  const changeLockScript = (0, _from_info.parseFromInfo)(changeAddress || fromInfos[0], {
    config
  }).fromScript;
  const changeCell = {
    cellOutput: {
      capacity: "0x0",
      lock: changeLockScript,
      type: undefined
    },
    data: "0x"
  };

  const minimalChangeCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(changeCell));

  let changeCapacity = _bi.BI.from(0);

  if (useLocktimeCellsFirst) {
    if (tipHeader) {
      const result = await _locktime_pool.default.injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, deductAmount.toString(), tipHeader, minimalChangeCapacity.toString(), {
        config,
        LocktimeCellCollector: LocktimePoolCellCollector,
        enableDeductCapacity
      });
      txSkeleton = result.txSkeleton;
      deductAmount = _bi.BI.from(result.capacity); // if deductAmount > 0, changeCapacity must be 0

      changeCapacity = _bi.BI.from(result.changeCapacity);
    }

    if (deductAmount.gt(0)) {
      const result = await _commonTransferCompatible(txSkeleton, fromInfos, deductAmount, minimalChangeCapacity, {
        config,
        enableDeductCapacity
      });
      txSkeleton = result.txSkeleton;
      deductAmount = result.capacity;
      changeCapacity = result.changeCapacity;
    } else if (deductAmount.eq(0) && changeCapacity.gt(0) && changeCapacity.lt(minimalChangeCapacity)) {
      const result = await _commonTransferCompatible(txSkeleton, fromInfos, minimalChangeCapacity.sub(changeCapacity), _bi.BI.from(0), {
        config,
        enableDeductCapacity
      });
      txSkeleton = result.txSkeleton;
      deductAmount = result.capacity;
      changeCapacity = result.changeCapacity;
    }
  } else {
    const result = await _commonTransferCompatible(txSkeleton, fromInfos, deductAmount, minimalChangeCapacity, {
      config,
      enableDeductCapacity
    });
    txSkeleton = result.txSkeleton;
    deductAmount = result.capacity;
    changeCapacity = result.changeCapacity;

    if (tipHeader) {
      if (deductAmount.gt(0)) {
        const result = await _locktime_pool.default.injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, deductAmount.toString(), tipHeader, minimalChangeCapacity.toString(), {
          config,
          LocktimeCellCollector: LocktimePoolCellCollector,
          enableDeductCapacity
        });
        txSkeleton = result.txSkeleton;
        deductAmount = _bi.BI.from(result.capacity);
        changeCapacity = _bi.BI.from(result.changeCapacity);
      } else if (deductAmount.eq(0) && changeCapacity.gt(0) && changeCapacity.lt(minimalChangeCapacity)) {
        const result = await _locktime_pool.default.injectCapacityWithoutChangeCompatible(txSkeleton, fromInfos, minimalChangeCapacity.sub(changeCapacity).toString(), tipHeader, 0, {
          config,
          LocktimeCellCollector: LocktimePoolCellCollector,
          enableDeductCapacity
        });
        txSkeleton = result.txSkeleton;
        deductAmount = _bi.BI.from(result.capacity);
        changeCapacity = _bi.BI.from(result.changeCapacity);
      }
    }
  }

  if (deductAmount.gt(0)) {
    throw new Error("Not enough capacity in from infos!");
  }

  if (changeCapacity.gt(0) && changeCapacity.lt(minimalChangeCapacity)) {
    throw new Error("Not enough capacity in from infos for change!");
  }

  if (changeCapacity.gt(0)) {
    changeCell.cellOutput.capacity = "0x" + changeCapacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", outputs => {
      return outputs.push(changeCell);
    });
  }

  return txSkeleton;
}

async function payFee(txSkeleton, fromInfos, amount, tipHeader, {
  config = undefined,
  useLocktimeCellsFirst = true,
  enableDeductCapacity = true
} = {}) {
  return injectCapacity(txSkeleton, fromInfos, amount, undefined, tipHeader, {
    config,
    useLocktimeCellsFirst,
    enableDeductCapacity
  });
}

function prepareSigningEntries(txSkeleton, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  generateLockScriptInfos({
    config
  });

  for (const lockScriptInfo of lockScriptInfos.infos) {
    txSkeleton = lockScriptInfo.lockScriptInfo.prepareSigningEntries(txSkeleton, {
      config
    });
  }

  return txSkeleton;
}

async function _commonTransfer(txSkeleton, fromInfos, amount, minimalChangeCapacity, {
  config = undefined,
  enableDeductCapacity = true
} = {}) {
  const result = await _commonTransferCompatible(txSkeleton, fromInfos, amount, minimalChangeCapacity, {
    config,
    enableDeductCapacity
  });
  return {
    txSkeleton: result.txSkeleton,
    capacity: BigInt(result.capacity.toString()),
    changeCapacity: BigInt(result.changeCapacity.toString())
  };
}

async function _commonTransferCompatible(txSkeleton, fromInfos, amount, minimalChangeCapacity, {
  config = undefined,
  enableDeductCapacity = true
} = {}) {
  config = config || (0, _configManager.getConfig)();

  let _amount = _bi.BI.from(amount);

  const cellProvider = txSkeleton.get("cellProvider");

  if (!cellProvider) {
    throw new Error("Cell Provider is missing!");
  }

  const getInputKey = input => {
    var _input$outPoint, _input$outPoint2;

    return `${(_input$outPoint = input.outPoint) === null || _input$outPoint === void 0 ? void 0 : _input$outPoint.txHash}_${(_input$outPoint2 = input.outPoint) === null || _input$outPoint2 === void 0 ? void 0 : _input$outPoint2.index}`;
  };

  let previousInputs = (0, _immutable.Set)();

  for (const input of txSkeleton.get("inputs")) {
    previousInputs = previousInputs.add(getInputKey(input));
  }

  const fromScripts = fromInfos.map(fromInfo => {
    return (0, _from_info.parseFromInfo)(fromInfo, {
      config
    }).fromScript;
  });

  for (const fromScript of fromScripts) {
    if (enableDeductCapacity && _amount.gt(0)) {
      [txSkeleton, _amount] = _deductCapacityCompatible(txSkeleton, fromScript, _amount);
    }
  }

  generateLockScriptInfos({
    config
  });

  let changeCapacity = _bi.BI.from(0);

  if (_amount.gt(0)) {
    // collect cells
    loop1: for (const fromInfo of fromInfos) {
      const cellCollectors = lockScriptInfos.infos.map(lockScriptInfo => {
        return new lockScriptInfo.lockScriptInfo.CellCollector(fromInfo, cellProvider, {
          config
        });
      });

      for (const cellCollector of cellCollectors) {
        for await (const inputCell of cellCollector.collect()) {
          const inputKey = getInputKey(inputCell);

          if (previousInputs.has(inputKey)) {
            continue;
          }

          previousInputs = previousInputs.add(inputKey);
          const result = await collectInputCompatible(txSkeleton, inputCell, fromInfo, {
            config,
            needCapacity: _amount
          });
          txSkeleton = result.txSkeleton;

          const inputCapacity = _bi.BI.from(result.availableCapacity);

          let deductCapacity = inputCapacity;

          if (deductCapacity.gt(_amount)) {
            deductCapacity = _amount;
          }

          _amount = _amount.sub(deductCapacity);
          changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));

          if (_amount.eq(0) && (changeCapacity.eq(0) || changeCapacity.gt(minimalChangeCapacity))) {
            break loop1;
          }
        }
      }
    }
  }

  return {
    txSkeleton,
    capacity: _amount,
    changeCapacity
  };
}

function _deductCapacityCompatible(txSkeleton, fromScript, capacity) {
  /*
   * First, check if there is any output cells that contains enough capacity
   * for us to tinker with.
   *
   * TODO: the solution right now won't cover all cases, some outputs before the
   * last output might still be tinkerable, right now we are working on the
   * simple solution, later we can change this for more optimizations.
   */
  let _capacity = _bi.BI.from(capacity);

  const lastFreezedOutput = txSkeleton.get("fixedEntries").filter(({
    field
  }) => field === "outputs").maxBy(({
    index
  }) => index);
  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;

  for (; i < txSkeleton.get("outputs").size && _capacity.gt(0); i++) {
    const output = txSkeleton.get("outputs").get(i);

    if (output && new ScriptValue(output.cellOutput.lock, {
      validate: false
    }).equals(new ScriptValue(fromScript, {
      validate: false
    }))) {
      const clonedOutput = JSON.parse(JSON.stringify(output));

      const cellCapacity = _bi.BI.from(clonedOutput.cellOutput.capacity);

      const availableCapacity = cellCapacity;
      let deductCapacity;

      if (_capacity.gte(availableCapacity)) {
        deductCapacity = availableCapacity;
      } else {
        deductCapacity = cellCapacity.sub((0, _helpers.minimalCellCapacityCompatible)(clonedOutput));

        if (deductCapacity.gt(capacity)) {
          deductCapacity = capacity;
        }
      }

      _capacity = _capacity.sub(deductCapacity);
      clonedOutput.cellOutput.capacity = "0x" + cellCapacity.sub(deductCapacity).toString(16);
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.update(i, () => clonedOutput);
      });
    }
  } // Remove all output cells with capacity equal to 0


  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.filter(output => _bi.BI.from(output.cellOutput.capacity).toString() !== _bi.BI.from(0).toString());
  });
  return [txSkeleton, _capacity];
} // Alter output generated by `setupInputCell`


async function collectInputCompatible(txSkeleton, inputCell, fromInfo, {
  config = undefined,
  since = undefined,
  defaultWitness = "0x",
  needCapacity = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {
    config,
    since,
    defaultWitness
  });
  const lastOutputIndex = txSkeleton.get("outputs").size - 1;
  const lastOutput = txSkeleton.get("outputs").get(lastOutputIndex);
  /* c8 ignore next 3 */

  if (!lastOutput) {
    throw new Error("Impossible: can not find last output");
  }

  const lastOutputCapacity = _bi.BI.from(lastOutput.cellOutput.capacity);

  const lastOutputFixedEntryIndex = txSkeleton.get("fixedEntries").findIndex(fixedEntry => {
    return fixedEntry.field === "outputs" && fixedEntry.index === lastOutputIndex;
  });
  const fromScript = inputCell.cellOutput.lock;

  let availableCapacity = _bi.BI.from(0);

  if (config.SCRIPTS.ANYONE_CAN_PAY && (0, _helper.isAcpScript)(fromScript, config)) {
    const destroyable = !!(fromInfo && typeof fromInfo === "object" && "destroyable" in fromInfo && fromInfo.destroyable);

    const _needCapacity = needCapacity ? _bi.BI.from(needCapacity) : lastOutputCapacity;

    if (destroyable) {
      availableCapacity = lastOutputCapacity; // remove output & fixedEntry added by `setupInputCell`

      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.remove(lastOutputIndex);
      });

      if (lastOutputFixedEntryIndex >= 0) {
        txSkeleton = txSkeleton.update("fixedEntries", fixedEntries => {
          return fixedEntries.remove(lastOutputFixedEntryIndex);
        });
      }
    } else {
      // Ignore `fixedEntries` and update capacity of output which generated by `setupInputCell`
      const minimalOutputCapacity = _bi.BI.from((0, _helpers.minimalCellCapacityCompatible)(lastOutput));

      const canUseCapacity = lastOutputCapacity.sub(minimalOutputCapacity);
      const clonedLastOutput = JSON.parse(JSON.stringify(lastOutput));
      let outputCapacity = minimalOutputCapacity;
      availableCapacity = canUseCapacity;

      if (_needCapacity.lt(canUseCapacity)) {
        outputCapacity = lastOutputCapacity.sub(_needCapacity);
        availableCapacity = _needCapacity;
      }

      clonedLastOutput.cellOutput.capacity = "0x" + outputCapacity.toString(16);
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.update(lastOutputIndex, () => clonedLastOutput);
      });
    }
  } else {
    // Ignore if last output is fixed.
    if (lastOutputFixedEntryIndex < 0) {
      var _txSkeleton$get$get;

      // Remove last output
      availableCapacity = _bi.BI.from((_txSkeleton$get$get = txSkeleton.get("outputs").get(lastOutputIndex)) === null || _txSkeleton$get$get === void 0 ? void 0 : _txSkeleton$get$get.cellOutput.capacity);
      txSkeleton = txSkeleton.update("outputs", outputs => {
        return outputs.remove(lastOutputIndex);
      });
    }
  }

  return {
    txSkeleton,
    availableCapacity
  };
}
/**
 * A function to transfer input to output, and add input & output to txSkeleton.
 * And it will deal with cell deps and witnesses too. (Add the input required cell deps and witnesses.)
 * It should be noted that the output must be added to the end of txSkeleton.get("outputs").
 *
 * @param txSkeleton
 * @param inputCell
 * @param fromInfo
 * @param options
 */


async function setupInputCell(txSkeleton, inputCell, fromInfo, {
  config = undefined,
  since = undefined,
  defaultWitness = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  generateLockScriptInfos({
    config
  });
  const inputLock = inputCell.cellOutput.lock;
  const targetLockScriptInfo = lockScriptInfos.infos.find(lockScriptInfo => {
    return lockScriptInfo.codeHash === inputLock.codeHash && lockScriptInfo.hashType === inputLock.hashType;
  });

  if (!targetLockScriptInfo) {
    throw new Error(`No LockScriptInfo found for setupInputCell!`);
  }

  return targetLockScriptInfo.lockScriptInfo.setupInputCell(txSkeleton, inputCell, fromInfo, {
    config,
    since,
    defaultWitness
  });
}

async function payFeeByFeeRate(txSkeleton, fromInfos, feeRate, tipHeader, {
  config = undefined,
  useLocktimeCellsFirst = true,
  enableDeductCapacity = true
} = {}) {
  let size = 0;
  let newTxSkeleton = txSkeleton;
  /**
   * Only one case `currentTransactionSize < size` :
   * change output capacity equals current fee (feeA), so one output reduced,
   * and if reduce the fee, change output will add again, fee will increase to feeA.
   */

  let currentTransactionSize = getTransactionSize(newTxSkeleton);

  while (currentTransactionSize > size) {
    size = currentTransactionSize;
    const fee = calculateFeeCompatible(size, feeRate);
    newTxSkeleton = await payFee(txSkeleton, fromInfos, fee, tipHeader, {
      config,
      useLocktimeCellsFirst,
      enableDeductCapacity
    });
    currentTransactionSize = getTransactionSize(newTxSkeleton);
  }

  return newTxSkeleton;
}

function calculateFee(size, feeRate) {
  const result = calculateFeeCompatible(size, feeRate);
  return BigInt(result.toString());
}

function calculateFeeCompatible(size, feeRate) {
  const ratio = _bi.BI.from(1000);

  const base = _bi.BI.from(size).mul(feeRate);

  const fee = base.div(ratio);

  if (fee.mul(ratio).lt(base)) {
    return fee.add(1);
  }

  return _bi.BI.from(fee);
}

function getTransactionSize(txSkeleton) {
  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);
  return getTransactionSizeByTx(tx);
}

function getTransactionSizeByTx(tx) {
  const serializedTx = _base.blockchain.Transaction.pack(tx); // 4 is serialized offset bytesize


  const size = serializedTx.byteLength + 4;
  return size;
}

var _default = {
  transfer,
  payFee,
  prepareSigningEntries,
  injectCapacity,
  setupInputCell,
  registerCustomLockScriptInfos,
  payFeeByFeeRate,
  __tests__: {
    _commonTransfer,
    resetLockScriptInfos,
    getLockScriptInfos,
    generateLockScriptInfos,
    getTransactionSizeByTx,
    getTransactionSize,
    calculateFee,
    calculateFeeCompatible
  }
};
exports.default = _default;
//# sourceMappingURL=common.js.map