import { BIish, BI } from "@ckb-lumos/bi";
import { HexNumber, PackedSince, HexString } from "./primitive";
export declare type SinceType = "epochNumber" | "blockNumber" | "blockTimestamp";
export interface EpochSinceValue {
    length: number;
    index: number;
    number: number;
}
export interface SinceValidationInfo {
    blockNumber: HexNumber;
    epoch: HexNumber;
    median_timestamp: HexNumber;
}
/**
 * Parse since and get relative or not, type, and value of since
 *
 * @param since
 */
declare function parseSince(since: PackedSince): {
    relative: boolean;
    type: "epochNumber";
    value: EpochSinceValue;
} | {
    relative: boolean;
    type: "blockNumber" | "blockTimestamp";
    value: bigint;
};
declare type SinceParseResult = {
    relative: boolean;
    type: "epochNumber";
    value: EpochSinceValue;
} | {
    relative: boolean;
    type: "blockNumber" | "blockTimestamp";
    value: BI;
};
declare function parseSinceCompatible(since: PackedSince): SinceParseResult;
declare function generateSince({ relative, type, value, }: {
    relative: boolean;
    type: SinceType;
    value: BIish;
} | {
    relative: boolean;
    type: "epochNumber";
    value: EpochSinceValue;
}): string;
/**
 * parse epoch from blockHeader.epoch
 *
 * @param epoch
 */
declare function parseEpoch(epoch: BIish): EpochSinceValue;
/**
 * return maximum since of args
 *
 * @param args sinces in absolute-epoch-number format
 */
declare function maximumAbsoluteEpochSince(...args: PackedSince[]): string;
/**
 * generate absolute-epoch-number format since
 *
 * @param params
 */
declare function generateAbsoluteEpochSince({ length, index, number, }: EpochSinceValue): PackedSince;
/**
 * generate header epoch from epoch since value
 *
 * @param params
 */
declare function generateHeaderEpoch({ length, index, number, }: EpochSinceValue): HexString;
/**
 * Will throw an error if since not in absolute-epoch-number format
 *
 * @param since
 */
declare function parseAbsoluteEpochSince(since: PackedSince): EpochSinceValue;
/**
 * Will throw an error if since not in absolute-epoch-number format
 *
 * @param since
 * @param tipHeaderEpoch
 */
declare function validateAbsoluteEpochSince(since: PackedSince, tipHeaderEpoch: HexString): boolean;
/**
 * Compare since with tipHeader, check since is valid or not.
 *
 * @param since
 * @param tipHeader
 * @param sinceHeader can left empty if absolute since
 */
declare function validateSince(since: PackedSince, tipSinceValidationInfo: SinceValidationInfo, cellSinceValidationInfo: SinceValidationInfo): boolean;
export { parseSince, parseSinceCompatible, parseEpoch, maximumAbsoluteEpochSince, generateAbsoluteEpochSince, parseAbsoluteEpochSince, validateAbsoluteEpochSince, validateSince, generateSince, generateHeaderEpoch, };
//# sourceMappingURL=since.d.ts.map