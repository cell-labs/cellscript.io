/// <reference types="node" />
import { Cell, Script, Transaction, TransactionWithStatus } from "./api";
import { Hexadecimal, HexString } from "./primitive";
import { Logger } from "./logger";
/**
 * argsLen: if argsLen = 20, it means collected cells cell.cellOutput.lock.args should be 20-byte length, and prefix match to lock.args.
 * And if argsLen = -1 (default), means cell.cellOutput.lock.args should equals to lock.args.
 */
export interface QueryOptions {
    lock?: Script | ScriptWrapper;
    type?: Script | ScriptWrapper | "empty";
    data?: string | "any";
    argsLen?: number | "any";
    /** `fromBlock` itself is included in range query. */
    fromBlock?: Hexadecimal;
    /** `toBlock` itself is included in range query. */
    toBlock?: Hexadecimal;
    skip?: number;
    order?: "asc" | "desc";
}
export interface ScriptWrapper {
    script: Script;
    ioType?: "input" | "output" | "both";
    argsLen?: number | "any";
}
export interface CellCollectorResults {
    [Symbol.asyncIterator](): AsyncIterator<Cell>;
}
export interface CellCollector {
    collect(): CellCollectorResults;
}
export interface CellProvider {
    uri?: string;
    collector(queryOptions: QueryOptions): CellCollector;
}
export interface Tip {
    blockNumber: string;
    blockHash: string;
}
export interface IndexerOptions {
    pollIntervalSeconds?: number;
    livenessCheckIntervalSeconds?: number;
    logger?: Logger;
    keepNum?: number;
    pruneInterval?: number;
    rpcOptions?: object;
}
/**
 * @deprecated please use CellProvider
 */
export declare abstract class Indexer {
    abstract uri: string;
    abstract running(): boolean;
    abstract startForever(): void;
    abstract start(): void;
    abstract stop(): void;
    abstract tip(): Promise<Tip>;
    abstract collector(queries: QueryOptions): CellCollector;
    abstract subscribe(queries: QueryOptions): NodeJS.EventEmitter;
    abstract subscribeMedianTime(): NodeJS.EventEmitter;
    abstract waitForSync(blockDifference?: number): Promise<void>;
}
export declare interface BaseCellCollector extends CellCollector {
    count(): Promise<number>;
    collect(): CellCollectorResults;
}
export interface TransactionCollectorOptions {
    skipMissing?: boolean;
    includeStatus?: boolean;
}
export interface TransactionCollectorResults {
    [Symbol.asyncIterator](): AsyncIterator<Transaction | TransactionWithStatus>;
}
declare class TransactionCollector {
    rpc: any;
    lock: ScriptWrapper | undefined;
    type: "empty" | ScriptWrapper | Script | undefined;
    indexer: Indexer;
    skipMissing: boolean;
    includeStatus: boolean;
    fromBlock: Hexadecimal | undefined;
    toBlock: Hexadecimal | undefined;
    order: "asc" | "desc";
    skip: number | undefined;
    constructor(indexer: Indexer, { lock, type, argsLen, fromBlock, toBlock, order, skip, }?: QueryOptions, { skipMissing, includeStatus, }?: TransactionCollectorOptions);
    getTransactionHashes(): Promise<HexString[]>;
    count(): Promise<number>;
    collect(): TransactionCollectorResults;
}
declare const indexer: {
    TransactionCollector: typeof TransactionCollector;
};
export default indexer;
export { TransactionCollector };
//# sourceMappingURL=indexer.d.ts.map