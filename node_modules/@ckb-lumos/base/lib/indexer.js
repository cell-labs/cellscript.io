"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TransactionCollector = exports.Indexer = void 0;

var _toolkit = require("@ckb-lumos/toolkit");

var _utils = require("./utils");

var _helpers = require("./helpers");

/**
 * @deprecated please use CellProvider
 */
class Indexer {} // CellCollector


exports.Indexer = Indexer;

// Notice this TransactionCollector implementation only uses indexer
// here. Since the indexer we use doesn't store full transaction data,
// we will have to run CKB RPC queries on each tx hash to fetch transaction
// data. In some cases this might slow your app down. An ideal solution would
// be combining this with some cacher to accelerate this process.
class TransactionCollector {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(indexer, {
    lock,
    type,
    argsLen = -1,
    fromBlock,
    toBlock,
    order = "asc",
    skip
  } = {}, {
    skipMissing = false,
    includeStatus = true
  } = {}) {
    if (!lock && (!type || type === "empty")) {
      throw new Error("Either lock or type script must be provided!");
    } // Wrap the plain `Script` into `ScriptWrapper`.


    if (lock && !(0, _helpers.isScriptWrapper)(lock)) {
      _toolkit.validators.ValidateScript(lock);

      this.lock = {
        script: lock,
        ioType: "both",
        argsLen: argsLen
      };
    } else if (lock && lock.script) {
      _toolkit.validators.ValidateScript(lock.script);

      this.lock = lock; // check ioType, argsLen

      if (!lock.argsLen) {
        this.lock.argsLen = argsLen;
      }

      if (!lock.ioType) {
        this.lock.ioType = "both";
      }
    }

    if (type === "empty") {
      this.type = type;
    } else if (type && !(0, _helpers.isScriptWrapper)(type)) {
      _toolkit.validators.ValidateScript(type);

      this.type = {
        script: type,
        ioType: "both",
        argsLen: argsLen
      };
    } else if (type && type.script) {
      _toolkit.validators.ValidateScript(type.script);

      this.type = type; // check ioType, argsLen

      if (!type.argsLen) {
        this.type.argsLen = argsLen;
      }

      if (!type.ioType) {
        this.type.ioType = "both";
      }
    }

    if (fromBlock) {
      (0, _utils.assertHexadecimal)("fromBlock", fromBlock);
    }

    if (toBlock) {
      (0, _utils.assertHexadecimal)("toBlock", toBlock);
    }

    if (order !== "asc" && order !== "desc") {
      throw new Error("Order must be either asc or desc!");
    }

    this.indexer = indexer;
    this.skipMissing = skipMissing;
    this.includeStatus = includeStatus;
    this.fromBlock = fromBlock;
    this.toBlock = toBlock;
    this.order = order;
    this.skip = skip; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    this.rpc = indexer.rpc;
  }

  async getTransactionHashes() {
    throw new Error("Not implement!");
  }

  async count() {
    const hashes = await this.getTransactionHashes();
    return hashes.length;
  }

  async *collect() {
    const hashes = await this.getTransactionHashes();

    for (const hash of hashes) {
      const tx = await this.rpc.get_transaction(hash);

      if (!this.skipMissing && !tx) {
        throw new Error(`Transaction ${hash} is missing!`);
      }

      if (this.includeStatus) {
        yield tx;
      } else {
        yield tx.transaction;
      }
    }
  }

}

exports.TransactionCollector = TransactionCollector;
const indexer = {
  TransactionCollector
};
var _default = indexer;
exports.default = _default;
//# sourceMappingURL=indexer.js.map