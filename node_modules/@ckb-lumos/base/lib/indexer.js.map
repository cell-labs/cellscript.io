{"version":3,"file":"indexer.js","names":["Indexer","TransactionCollector","constructor","indexer","lock","type","argsLen","fromBlock","toBlock","order","skip","skipMissing","includeStatus","Error","isScriptWrapper","validators","ValidateScript","script","ioType","assertHexadecimal","rpc","getTransactionHashes","count","hashes","length","collect","hash","tx","get_transaction","transaction"],"sources":["../src/indexer.ts"],"sourcesContent":["import { validators } from \"@ckb-lumos/toolkit\";\nimport { assertHexadecimal } from \"./utils\";\n\nimport { Cell, Script, Transaction, TransactionWithStatus } from \"./api\";\nimport { Hexadecimal, HexString } from \"./primitive\";\nimport { Logger } from \"./logger\";\nimport { isScriptWrapper } from \"./helpers\";\n\n/**\n * argsLen: if argsLen = 20, it means collected cells cell.cellOutput.lock.args should be 20-byte length, and prefix match to lock.args.\n * And if argsLen = -1 (default), means cell.cellOutput.lock.args should equals to lock.args.\n */\nexport interface QueryOptions {\n  lock?: Script | ScriptWrapper;\n  type?: Script | ScriptWrapper | \"empty\";\n  // data = any means any data content is ok\n  data?: string | \"any\";\n  argsLen?: number | \"any\";\n  /** `fromBlock` itself is included in range query. */\n  fromBlock?: Hexadecimal;\n  /** `toBlock` itself is included in range query. */\n  toBlock?: Hexadecimal;\n  skip?: number;\n  order?: \"asc\" | \"desc\";\n}\n\nexport interface ScriptWrapper {\n  script: Script;\n  ioType?: \"input\" | \"output\" | \"both\";\n  argsLen?: number | \"any\";\n}\n\nexport interface CellCollectorResults {\n  [Symbol.asyncIterator](): AsyncIterator<Cell>;\n}\n\nexport interface CellCollector {\n  collect(): CellCollectorResults;\n}\n\nexport interface CellProvider {\n  uri?: string;\n  collector(queryOptions: QueryOptions): CellCollector;\n}\n\nexport interface Tip {\n  blockNumber: string;\n  blockHash: string;\n}\n\nexport interface IndexerOptions {\n  pollIntervalSeconds?: number;\n  livenessCheckIntervalSeconds?: number;\n  logger?: Logger;\n  keepNum?: number;\n  pruneInterval?: number;\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  rpcOptions?: object;\n}\n\n/**\n * @deprecated please use CellProvider\n */\nexport abstract class Indexer {\n  abstract uri: string;\n\n  abstract running(): boolean;\n  abstract startForever(): void;\n  abstract start(): void;\n  abstract stop(): void;\n  abstract tip(): Promise<Tip>;\n\n  abstract collector(queries: QueryOptions): CellCollector;\n  abstract subscribe(queries: QueryOptions): NodeJS.EventEmitter;\n  abstract subscribeMedianTime(): NodeJS.EventEmitter;\n  abstract waitForSync(blockDifference?: number): Promise<void>;\n}\n\n// CellCollector\nexport declare interface BaseCellCollector extends CellCollector {\n  count(): Promise<number>;\n\n  collect(): CellCollectorResults;\n}\n\n// TransactionCollector\nexport interface TransactionCollectorOptions {\n  skipMissing?: boolean;\n  includeStatus?: boolean;\n}\n\nexport interface TransactionCollectorResults {\n  [Symbol.asyncIterator](): AsyncIterator<Transaction | TransactionWithStatus>;\n}\n\n// Notice this TransactionCollector implementation only uses indexer\n// here. Since the indexer we use doesn't store full transaction data,\n// we will have to run CKB RPC queries on each tx hash to fetch transaction\n// data. In some cases this might slow your app down. An ideal solution would\n// be combining this with some cacher to accelerate this process.\nclass TransactionCollector {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rpc: any;\n  lock: ScriptWrapper | undefined;\n  type: \"empty\" | ScriptWrapper | Script | undefined;\n  indexer: Indexer;\n  skipMissing: boolean;\n  includeStatus: boolean;\n  fromBlock: Hexadecimal | undefined;\n  toBlock: Hexadecimal | undefined;\n  order: \"asc\" | \"desc\";\n  skip: number | undefined;\n\n  constructor(\n    indexer: Indexer,\n    {\n      lock,\n      type,\n      argsLen = -1,\n      fromBlock,\n      toBlock,\n      order = \"asc\",\n      skip,\n    }: QueryOptions = {},\n    {\n      skipMissing = false,\n      includeStatus = true,\n    }: TransactionCollectorOptions = {}\n  ) {\n    if (!lock && (!type || type === \"empty\")) {\n      throw new Error(\"Either lock or type script must be provided!\");\n    }\n    // Wrap the plain `Script` into `ScriptWrapper`.\n    if (lock && !isScriptWrapper(lock)) {\n      validators.ValidateScript(lock);\n      this.lock = { script: lock, ioType: \"both\", argsLen: argsLen };\n    } else if (lock && lock.script) {\n      validators.ValidateScript(lock.script);\n      this.lock = lock;\n      // check ioType, argsLen\n      if (!lock.argsLen) {\n        this.lock.argsLen = argsLen;\n      }\n      if (!lock.ioType) {\n        this.lock.ioType = \"both\";\n      }\n    }\n    if (type === \"empty\") {\n      this.type = type;\n    } else if (type && !isScriptWrapper(type)) {\n      validators.ValidateScript(type);\n      this.type = { script: type, ioType: \"both\", argsLen: argsLen };\n    } else if (type && type.script) {\n      validators.ValidateScript(type.script);\n      this.type = type;\n      // check ioType, argsLen\n      if (!type.argsLen) {\n        this.type.argsLen = argsLen;\n      }\n      if (!type.ioType) {\n        this.type.ioType = \"both\";\n      }\n    }\n    if (fromBlock) {\n      assertHexadecimal(\"fromBlock\", fromBlock);\n    }\n    if (toBlock) {\n      assertHexadecimal(\"toBlock\", toBlock);\n    }\n    if (order !== \"asc\" && order !== \"desc\") {\n      throw new Error(\"Order must be either asc or desc!\");\n    }\n    this.indexer = indexer;\n    this.skipMissing = skipMissing;\n    this.includeStatus = includeStatus;\n    this.fromBlock = fromBlock;\n    this.toBlock = toBlock;\n    this.order = order;\n    this.skip = skip;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.rpc = (indexer as any).rpc;\n  }\n\n  async getTransactionHashes(): Promise<HexString[]> {\n    throw new Error(\"Not implement!\");\n  }\n\n  async count(): Promise<number> {\n    const hashes = await this.getTransactionHashes();\n    return hashes.length;\n  }\n\n  async *collect(): TransactionCollectorResults {\n    const hashes = await this.getTransactionHashes();\n    for (const hash of hashes) {\n      const tx = await this.rpc.get_transaction(hash);\n      if (!this.skipMissing && !tx) {\n        throw new Error(`Transaction ${hash} is missing!`);\n      }\n      if (this.includeStatus) {\n        yield tx;\n      } else {\n        yield tx.transaction;\n      }\n    }\n  }\n}\n\nconst indexer = {\n  TransactionCollector,\n};\n\nexport default indexer;\nexport { TransactionCollector };\n"],"mappings":"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"}