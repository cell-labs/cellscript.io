"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CKBHasher = void 0;
exports.assertHexString = assertHexString;
exports.assertHexadecimal = assertHexadecimal;
exports.ckbHash = ckbHash;
exports.computeScriptHash = computeScriptHash;
exports.deepCamel = deepCamel;
exports.deepCamelizeTransaction = deepCamelizeTransaction;
exports.generateTypeIdScript = generateTypeIdScript;
exports.hashCode = hashCode;
exports.isDeepEqual = isDeepEqual;
exports.readBigUInt128LE = readBigUInt128LE;
exports.readBigUInt128LECompatible = readBigUInt128LECompatible;
exports.readBigUInt64LE = readBigUInt64LE;
exports.readBigUInt64LECompatible = readBigUInt64LECompatible;
exports.toBigUInt128LE = toBigUInt128LE;
exports.toBigUInt128LECompatible = toBigUInt128LECompatible;
exports.toBigUInt64LE = toBigUInt64LE;
exports.toBigUInt64LECompatible = toBigUInt64LECompatible;

var _blake2b = _interopRequireDefault(require("blake2b"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _jsXxhash = require("js-xxhash");

var _codec = require("@ckb-lumos/codec");

var _bi = require("@ckb-lumos/bi");

var blockchain = _interopRequireWildcard(require("./blockchain"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  bytify,
  hexify,
  bytifyRawString
} = _codec.bytes;

class CKBHasher {
  constructor(options = {}) {
    const {
      outLength = 32
    } = options;
    this.outLength = outLength;
    this.hasher = (0, _blake2b.default)(outLength, undefined, undefined, bytifyRawString("ckb-default-hash"));
  }

  update(data) {
    this.hasher.update(bytify(data));
    return this;
  }

  digestHex() {
    const out = new Uint8Array(this.outLength);
    this.hasher.digest(out);
    return hexify(out.buffer);
  }

}

exports.CKBHasher = CKBHasher;

function ckbHash(data) {
  const hasher = new CKBHasher();
  hasher.update(_codec.bytes.bytify(data));
  return hasher.digestHex();
}
/**
 * compute lock/type hash
 *
 * @param script
 * @param _options @deprecated this option has no effect
 */


function computeScriptHash(script, _options) {
  return ckbHash(blockchain.Script.pack(script));
}

function hashCode(buffer) {
  return (0, _jsXxhash.xxHash32)(buffer, 0);
}
/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 * convert bigint to BigUInt64 little-endian hex string
 * @param num
 */


function toBigUInt64LE(num) {
  return toBigUInt64LECompatible(num);
}

function toBigUInt64LECompatible(num) {
  num = _bi.BI.from(num);
  const buf = Buffer.alloc(8);
  buf.writeUInt32LE(num.and("0xffffffff").toNumber(), 0);
  num = num.shr(32);
  buf.writeUInt32LE(num.and("0xffffffff").toNumber(), 4);
  return `0x${buf.toString("hex")}`;
}
/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 * convert BigUInt64 little-endian hex string to bigint
 *
 * @param hex BigUInt64 little-endian hex string
 */


function readBigUInt64LE(hex) {
  return readBigUInt64LECompatible(hex).toBigInt();
}
/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 */


function readBigUInt64LECompatible(hex) {
  const buf = Buffer.from(hex.slice(2), "hex");
  return _bi.BI.from(buf.readUInt32LE()).add(_bi.BI.from(buf.readUInt32LE(4)).shl(32));
} // const U128_MIN = BigInt(0);
// const U128_MAX = BigInt("340282366920938463463374607431768211455");

/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 * convert bigint to BigUInt128 little-endian hex string
 *
 * @param u128
 */


function toBigUInt128LE(u128) {
  return toBigUInt128LECompatible(u128);
}

const U128_MIN_COMPATIBLE = _bi.BI.from(0);

const U128_MAX_COMPATIBLE = _bi.BI.from("340282366920938463463374607431768211455");

function toBigUInt128LECompatible(num) {
  num = _bi.BI.from(num);

  if (num.lt(U128_MIN_COMPATIBLE)) {
    throw new Error(`u128 ${num} too small`);
  }

  if (num.gt(U128_MAX_COMPATIBLE)) {
    throw new Error(`u128 ${num} too large`);
  }

  const buf = Buffer.alloc(16);
  buf.writeUInt32LE(num.and(0xffffffff).toNumber(), 0);
  num = num.shr(32);
  buf.writeUInt32LE(num.and(0xffffffff).toNumber(), 4);
  num = num.shr(32);
  buf.writeUInt32LE(num.and(0xffffffff).toNumber(), 8);
  num = num.shr(32);
  buf.writeUInt32LE(num.and(0xffffffff).toNumber(), 12);
  return `0x${buf.toString("hex")}`;
}
/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 * convert BigUInt64 little-endian hex string to bigint
 *
 * @param leHex BigUInt128 little-endian hex string
 */


function readBigUInt128LE(leHex) {
  return readBigUInt128LECompatible(leHex).toBigInt();
}
/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 */


function readBigUInt128LECompatible(leHex) {
  if (leHex.length < 34 || !leHex.startsWith("0x")) {
    throw new Error(`leHex format error`);
  }

  const buf = Buffer.from(leHex.slice(2, 34), "hex");
  return _bi.BI.from(buf.readUInt32LE(0)).shl(0).add(_bi.BI.from(buf.readUInt32LE(4)).shl(32)).add(_bi.BI.from(buf.readUInt32LE(8)).shl(64)).add(_bi.BI.from(buf.readUInt32LE(12)).shl(96));
}

function assertHexString(debugPath, str) {
  if (!/^0x([0-9a-fA-F][0-9a-fA-F])*$/.test(str)) {
    throw new Error(`${debugPath} must be a hex string!`);
  }
}

function assertHexadecimal(debugPath, str) {
  if (!/^0x(0|[0-9a-fA-F]+)$/.test(str)) {
    throw new Error(`${debugPath} must be a hexadecimal!`);
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


function isDeepEqual(a, b) {
  return (0, _lodash.default)(a, b);
} // Buffer.from('TYPE_ID')


const TYPE_ID_CODE_HASH = "0x00000000000000000000000000000000000000000000000000545950455f4944";

function generateTypeIdArgs(input, outputIndex) {
  const outPointBuf = blockchain.CellInput.pack(input);

  const outputIndexBuf = _codec.bytes.hexify(_codec.number.Uint64LE.pack(outputIndex));

  const ckbHasher = new CKBHasher();
  ckbHasher.update(outPointBuf);
  ckbHasher.update(outputIndexBuf);
  return ckbHasher.digestHex();
}

function generateTypeIdScript(input, outputIndex = "0x0") {
  blockchain.CellInput.pack(input);
  assertHexadecimal("outputIndex", outputIndex);
  const args = generateTypeIdArgs(input, outputIndex);
  return {
    codeHash: TYPE_ID_CODE_HASH,
    hashType: "type",
    args
  };
}

function toCamel(s) {
  return s.replace(/([-_][a-z])/gi, $1 => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
} // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


function deepCamel(data) {
  if (Object.prototype.toString.call(data) === "[object Array]") {
    if (data.length === 0) {
      return data;
    } else {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return data.map(item => deepCamel(item));
    }
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  const result = {};

  if (Object.prototype.toString.call(data) === "[object Object]") {
    for (const key in data) {
      const value = data[key];

      if (Object.prototype.toString.call(value) === "[object Object]" || Object.prototype.toString.call(value) === "[object Array]") {
        result[toCamel(key)] = deepCamel(value);
      } else {
        result[toCamel(key)] = value;
      }
    }

    return result;
  }

  return data;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


function deepCamelizeDepGroup(data) {
  if (Object.prototype.toString.call(data) === "[object Array]") {
    if (data.length === 0) {
      return data;
    } else {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return data.map(item => deepCamelizeDepGroup(item));
    }
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  const result = {};

  if (Object.prototype.toString.call(data) === "[object Object]") {
    for (const key in data) {
      const value = data[key];

      if (Object.prototype.toString.call(value) === "[object Object]" || Object.prototype.toString.call(value) === "[object Array]") {
        result[key] = deepCamelizeDepGroup(value);
      } else {
        result[key] = value === "dep_group" ? "depGroup" : value;
      }
    }

    return result;
  }

  return data;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


function deepCamelizeTransaction(data) {
  return deepCamelizeDepGroup(deepCamel(data));
}
//# sourceMappingURL=utils.js.map