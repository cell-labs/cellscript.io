"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateAbsoluteEpochSince = generateAbsoluteEpochSince;
exports.generateHeaderEpoch = generateHeaderEpoch;
exports.generateSince = generateSince;
exports.maximumAbsoluteEpochSince = maximumAbsoluteEpochSince;
exports.parseAbsoluteEpochSince = parseAbsoluteEpochSince;
exports.parseEpoch = parseEpoch;
exports.parseSince = parseSince;
exports.parseSinceCompatible = parseSinceCompatible;
exports.validateAbsoluteEpochSince = validateAbsoluteEpochSince;
exports.validateSince = validateSince;

var _bi = require("@ckb-lumos/bi");

/**
 * Parse since and get relative or not, type, and value of since
 *
 * @param since
 */
function parseSince(since) {
  const result = parseSinceCompatible(since);
  if (result.type === "epochNumber") return result;
  return { ...result,
    value: result.value.toBigInt()
  };
}

function parseSinceCompatible(since) {
  const sinceBI = _bi.BI.from(since);

  const flag = sinceBI.shr(56);
  const metricFlag = flag.shr(5).and("0b11");
  let type;
  let value;

  if (metricFlag.eq(0b00)) {
    type = "blockNumber";
    value = sinceBI.and("0xFFFFFFFFFFFFFF");
  } else if (metricFlag.eq(0b01)) {
    type = "epochNumber";
    value = {
      length: sinceBI.shr(40).and(0xffff).toNumber(),
      index: sinceBI.shr(24).and(0xffff).toNumber(),
      number: sinceBI.and(0xffffff).toNumber()
    };
  } else if (metricFlag.eq(0b10)) {
    type = "blockTimestamp";
    value = sinceBI.and("0xFFFFFFFFFFFFFF");
  } else {
    throw new Error("Invalid metric flag!");
  }

  return {
    relative: !flag.and("0x80").eq(0),
    type,
    value
  };
}

function generateSince({
  relative,
  type,
  value
}) {
  let flag = _bi.BI.from(0);

  if (relative) {
    flag = flag.add(0b10000000);
  }

  if (type === "epochNumber") {
    flag = flag.add(0b00100000);
  } else if (type === "blockTimestamp") {
    flag = flag.add(0b01000000);
  }

  let v;

  if ((0, _bi.isBIish)(value)) {
    v = _bi.BI.from(value);
  } else if (typeof value === "object") {
    v = generateHeaderEpoch(value);
  } else {
    v = _bi.BI.from(value);
  }

  return _toHex(flag.shl(56).add(v));
}
/**
 * parse epoch from blockHeader.epoch
 *
 * @param epoch
 */


function parseEpoch(epoch) {
  const epochBI = _bi.BI.from(epoch);

  return {
    length: epochBI.shr(40).and(0xffff).toNumber(),
    index: epochBI.shr(24).and(0xffff).toNumber(),
    number: epochBI.and(0xffffff).toNumber()
  };
}
/**
 * return maximum since of args
 *
 * @param args sinces in absolute-epoch-number format
 */


function maximumAbsoluteEpochSince(...args) {
  const parsedArgs = args.map(arg => parseAbsoluteEpochSince(arg));
  const maxNumber = Math.max(...parsedArgs.map(arg => arg.number));
  const maxArgs = parsedArgs.filter(arg => arg.number === maxNumber);
  let max = maxArgs[0];

  for (let i = 1; i < maxArgs.length; ++i) {
    const current = maxArgs[i];

    if (_bi.BI.from(current.index).mul(max.length).gte(_bi.BI.from(max.index).mul(current.length))) {
      max = current;
    }
  }

  return generateAbsoluteEpochSince(max);
}
/**
 * generate absolute-epoch-number format since
 *
 * @param params
 */


function generateAbsoluteEpochSince({
  length,
  index,
  number
}) {
  return generateSince({
    relative: false,
    type: "epochNumber",
    value: {
      length,
      index,
      number
    }
  });
}
/**
 * generate header epoch from epoch since value
 *
 * @param params
 */


function generateHeaderEpoch({
  length,
  index,
  number
}) {
  return _toHex(_bi.BI.from(length).shl(40).add(_bi.BI.from(index).shl(24)).add(number));
}
/**
 * Will throw an error if since not in absolute-epoch-number format
 *
 * @param since
 */


function parseAbsoluteEpochSince(since) {
  const {
    relative,
    type,
    value
  } = parseSinceCompatible(since);

  if (!(relative === false && type === "epochNumber")) {
    throw new Error("Since format error!");
  }

  return value;
}
/**
 * Will throw an error if since not in absolute-epoch-number format
 *
 * @param since
 * @param tipHeaderEpoch
 */


function validateAbsoluteEpochSince(since, tipHeaderEpoch) {
  const value = parseSinceCompatible(since).value;
  const headerEpochParams = parseEpoch(tipHeaderEpoch);
  return _bi.BI.from(value.number).lt(headerEpochParams.number) || _bi.BI.from(value.number).eq(headerEpochParams.number) && _bi.BI.from(value.index).mul(headerEpochParams.length).lte(_bi.BI.from(headerEpochParams.index).mul(value.length));
}
/**
 * Compare since with tipHeader, check since is valid or not.
 *
 * @param since
 * @param tipHeader
 * @param sinceHeader can left empty if absolute since
 */


function validateSince(since, tipSinceValidationInfo, cellSinceValidationInfo) {
  const {
    relative,
    type,
    value
  } = parseSinceCompatible(since);

  if (!relative) {
    if (type === "epochNumber") {
      return validateAbsoluteEpochSince(since, tipSinceValidationInfo.epoch);
    }

    if (type === "blockNumber") {
      return _bi.BI.from(value).lte(tipSinceValidationInfo.blockNumber);
    }

    if (type === "blockTimestamp") {
      if (!tipSinceValidationInfo.median_timestamp) {
        throw new Error(`Must provide tip median_timestamp!`);
      }

      return _bi.BI.from(value).mul(1000).lte(tipSinceValidationInfo.median_timestamp);
    }
  } else {
    if (type === "epochNumber") {
      const tipHeaderEpoch = parseEpoch(tipSinceValidationInfo.epoch);
      const sinceHeaderEpoch = parseEpoch(cellSinceValidationInfo.epoch);
      const added = {
        number: _bi.BI.from(value.number).add(sinceHeaderEpoch.number),
        index: _bi.BI.from(value.index).mul(sinceHeaderEpoch.length).add(_bi.BI.from(sinceHeaderEpoch.index).mul(value.length)),
        length: _bi.BI.from(value.length).mul(sinceHeaderEpoch.length)
      };

      if (value.length === 0 && sinceHeaderEpoch.length !== 0) {
        added.index = _bi.BI.from(sinceHeaderEpoch.index);
        added.length = _bi.BI.from(sinceHeaderEpoch.length);
      } else if (sinceHeaderEpoch.length === 0 && value.length !== 0) {
        added.index = _bi.BI.from(value.index);
        added.length = _bi.BI.from(value.length);
      }

      if (!_bi.BI.from(added.length).eq(0) && _bi.BI.from(added.index).gte(added.length)) {
        added.number = added.index.div(added.length).add(added.number);
        added.index = added.index.mod(added.length);
      }

      return _bi.BI.from(added.number).lt(tipHeaderEpoch.number) || _bi.BI.from(added.number).eq(tipHeaderEpoch.number) && _bi.BI.from(added.index).mul(tipHeaderEpoch.length).lte(_bi.BI.from(tipHeaderEpoch.index).mul(added.length));
    }

    if (type === "blockNumber") {
      return _bi.BI.from(value).add(cellSinceValidationInfo.blockNumber).lte(tipSinceValidationInfo.blockNumber);
    }

    if (type === "blockTimestamp") {
      if (!tipSinceValidationInfo.median_timestamp || !cellSinceValidationInfo.median_timestamp) {
        throw new Error(`Must provide median_timestamp!`);
      }

      return _bi.BI.from(value).mul(1000).add(cellSinceValidationInfo.median_timestamp).lte(tipSinceValidationInfo.median_timestamp);
    }
  }

  return false;
}

function _toHex(num) {
  return "0x" + num.toString(16);
}
//# sourceMappingURL=since.js.map