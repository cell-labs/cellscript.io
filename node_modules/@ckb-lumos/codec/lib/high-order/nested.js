"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createArrayCodec = createArrayCodec;
exports.createNullableCodec = createNullableCodec;
exports.createObjectCodec = createObjectCodec;
exports.enhancePack = enhancePack;

var _utils = require("../utils");

var _error = require("../error");

function createNullableCodec(codec) {
  return {
    pack: packable => {
      if (packable == null) return packable;
      return (0, _utils.trackCodeExecuteError)(_error.CODEC_OPTIONAL_PATH, () => codec.pack(packable));
    },
    unpack: unpackable => {
      if (unpackable == null) return unpackable;
      return codec.unpack(unpackable);
    }
  };
}

/**
 * a high-order codec that helps to organize multiple codecs together into a single object
 * @param codecShape
 * @example
 * ```ts
 * const codec = createObjectCodec({
 *   r: Uint8,
 *   g: Uint8,
 *   b: Uint8,
 * });
 *
 * // { r: ArrayBuffer([0xff]), g: ArrayBuffer([0x00]), b: ArrayBuffer([0x00]) }
 * codec.pack({ r: 255, g: 0, b: 0 });
 * ```
 */
function createObjectCodec(codecShape) {
  const codecEntries = Object.entries(codecShape);
  return {
    pack: packableObj => {
      const result = {};
      codecEntries.forEach(([key, itemCodec]) => {
        Object.assign(result, {
          [key]: (0, _utils.trackCodeExecuteError)(key, () => itemCodec.pack(packableObj[key]))
        });
      });
      return result;
    },
    unpack: unpackableObj => {
      const result = {};
      codecEntries.forEach(([key, itemCodec]) => {
        Object.assign(result, {
          [key]: itemCodec.unpack(unpackableObj[key])
        });
      });
      return result;
    }
  };
}

function createArrayCodec(codec) {
  return {
    pack: items => items.map((item, index) => (0, _utils.trackCodeExecuteError)(index, () => codec.pack(item))),
    unpack: items => items.map(item => codec.unpack(item))
  };
}
/**
 * @param codec
 * @param afterCodecPack
 * @param beforeCodecUnpack
 */


function enhancePack(codec, afterCodecPack, beforeCodecUnpack) {
  return {
    pack: packable => afterCodecPack(codec.pack(packable)),
    unpack: unpackable => codec.unpack(beforeCodecUnpack(unpackable))
  };
}
//# sourceMappingURL=nested.js.map