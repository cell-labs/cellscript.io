"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bytify = bytify;
exports.bytifyRawString = bytifyRawString;
exports.concat = concat;
exports.equal = equal;
exports.hexify = hexify;

var _utils = require("./utils");

function bytifyRawString(rawString) {
  (0, _utils.assertUtf8String)(rawString);
  const buffer = new ArrayBuffer(rawString.length);
  const view = new DataView(buffer);

  for (let i = 0; i < rawString.length; i++) {
    const c = rawString.charCodeAt(i);
    view.setUint8(i, c);
  }

  return new Uint8Array(buffer);
}

function bytifyHex(hex) {
  (0, _utils.assertHexString)(hex);
  hex = hex.slice(2);
  const uint8s = [];

  for (let i = 0; i < hex.length; i += 2) {
    uint8s.push(parseInt(hex.substr(i, 2), 16));
  }

  return Uint8Array.from(uint8s);
}

function bytifyArrayLike(xs) {
  const isValidU8Vec = Array.from(xs).every(v => v >= 0 && v <= 255);

  if (!isValidU8Vec) {
    throw new Error("invalid ArrayLike, all elements must be 0-255");
  }

  return Uint8Array.from(xs);
}
/**
 * convert a {@link BytesLike} to an Uint8Array
 * @param bytesLike
 */


function bytify(bytesLike) {
  if (bytesLike instanceof ArrayBuffer) return new Uint8Array(bytesLike);
  if (bytesLike instanceof Uint8Array) return Uint8Array.from(bytesLike);
  if (typeof bytesLike === "string") return bytifyHex(bytesLike);
  if (Array.isArray(bytesLike)) return bytifyArrayLike(bytesLike);
  throw new Error(`Cannot convert ${bytesLike}`);
}

function equal(a, b) {
  const aUint8Array = bytify(a);
  const bUint8Array = bytify(b);
  return equalUint8Array(aUint8Array, bUint8Array);
}

function equalUint8Array(a, b) {
  if (a.length !== b.length) return false;

  for (let i = a.length; -1 < i; i -= 1) {
    if (a[i] !== b[i]) return false;
  }

  return true;
}
/**
 * convert a {@link BytesLike} to an even length hex string prefixed with "0x"
 * @param buf
 * @example
 * hexify([0,1,2,3]) // "0x010203"
 * hexify(Buffer.from([1, 2, 3])) // "0x010203"
 */


function hexify(buf) {
  const hex = Array.from(bytify(buf)).map(b => b.toString(16).padStart(2, "0")).join("");
  return "0x" + hex;
}

function concat(...bytesLikes) {
  const unmerged = bytesLikes.map(bytify);
  const totalSize = unmerged.reduce((size, item) => size + item.length, 0);
  const merged = new Uint8Array(totalSize);
  let offset = 0;
  unmerged.forEach(item => {
    merged.set(item, offset);
    offset += item.length;
  });
  return merged;
} // export function split(bytes: BytesLike, points: number[]): Uint8Array[] {
//   const u8vec = bytify(bytes);
//   const result: Uint8Array[] = [];
//   let offset = 0;
//   for (const point of points) {
//     result.push(u8vec.slice(offset, offset + point));
//     offset += point;
//   }
//   result.push(u8vec.slice(offset));
//   return result;
// }
//# sourceMappingURL=bytes.js.map