"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uint8 = exports.Uint64LE = exports.Uint64BE = exports.Uint64 = exports.Uint512LE = exports.Uint512BE = exports.Uint512 = exports.Uint32LE = exports.Uint32BE = exports.Uint32 = exports.Uint256LE = exports.Uint256BE = exports.Uint256 = exports.Uint16LE = exports.Uint16BE = exports.Uint16 = exports.Uint128LE = exports.Uint128BE = exports.Uint128 = void 0;

var _bi = require("@ckb-lumos/bi");

var _base = require("../base");

var _error = require("../error");

function assertNumberRange(value, min, max, typeName) {
  value = _bi.BI.from(value);

  if (value.lt(min) || value.gt(max)) {
    throw new _error.CodecBaseParseError(`Value must be between ${min.toString()} and ${max.toString()}, but got ${value.toString()}`, typeName);
  }
}

function createUintNumberCodec(byteLength, littleEndian = false) {
  const codec = createUintBICodec(byteLength, littleEndian);
  return {
    __isFixedCodec__: true,
    byteLength,
    pack: packable => codec.pack(packable),
    unpack: unpackable => codec.unpack(unpackable).toNumber()
  };
}

const createUintBICodec = (byteLength, littleEndian = false) => {
  const max = _bi.BI.from(1).shl(byteLength * 8).sub(1);

  return (0, _base.createFixedBytesCodec)({
    byteLength,

    pack(biIsh) {
      let endianType = littleEndian ? "LE" : "BE";

      if (byteLength <= 1) {
        endianType = "";
      }

      const typeName = `Uint${byteLength * 8}${endianType}`;

      if (typeof biIsh === "number" && !Number.isSafeInteger(biIsh)) {
        throw new _error.CodecBaseParseError(`${biIsh} is not a safe integer`, typeName);
      }

      let num = _bi.BI.from(biIsh);

      assertNumberRange(num, 0, max, typeName);
      const result = new DataView(new ArrayBuffer(byteLength));

      for (let i = 0; i < byteLength; i++) {
        if (littleEndian) {
          result.setUint8(i, num.and(0xff).toNumber());
        } else {
          result.setUint8(byteLength - i - 1, num.and(0xff).toNumber());
        }

        num = num.shr(8);
      }

      return new Uint8Array(result.buffer);
    },

    unpack: buf => {
      const view = new DataView(Uint8Array.from(buf).buffer);

      let result = _bi.BI.from(0);

      for (let i = 0; i < byteLength; i++) {
        if (littleEndian) {
          result = result.or(_bi.BI.from(view.getUint8(i)).shl(i * 8));
        } else {
          result = result.shl(8).or(view.getUint8(i));
        }
      }

      return result;
    }
  });
};

const Uint8 = createUintNumberCodec(1);
exports.Uint8 = Uint8;
const Uint16LE = createUintNumberCodec(2, true);
exports.Uint16LE = Uint16LE;
const Uint16BE = createUintNumberCodec(2);
/**
 * @alias Uint16LE
 */

exports.Uint16BE = Uint16BE;
const Uint16 = Uint16LE;
exports.Uint16 = Uint16;
const Uint32LE = createUintNumberCodec(4, true);
exports.Uint32LE = Uint32LE;
const Uint32BE = createUintNumberCodec(4);
/**
 * @alias Uint32LE
 */

exports.Uint32BE = Uint32BE;
const Uint32 = Uint32LE;
exports.Uint32 = Uint32;
const Uint64LE = createUintBICodec(8, true);
exports.Uint64LE = Uint64LE;
const Uint64BE = createUintBICodec(8);
/**
 * @alias Uint64LE
 */

exports.Uint64BE = Uint64BE;
const Uint64 = Uint64LE;
exports.Uint64 = Uint64;
const Uint128LE = createUintBICodec(16, true);
exports.Uint128LE = Uint128LE;
const Uint128BE = createUintBICodec(16);
/**
 * @alias Uint128LE
 */

exports.Uint128BE = Uint128BE;
const Uint128 = Uint128LE;
exports.Uint128 = Uint128;
const Uint256LE = createUintBICodec(32, true);
exports.Uint256LE = Uint256LE;
const Uint256BE = createUintBICodec(32);
/**
 * @alias Uint256LE
 */

exports.Uint256BE = Uint256BE;
const Uint256 = Uint256LE;
exports.Uint256 = Uint256;
const Uint512LE = createUintBICodec(64, true);
exports.Uint512LE = Uint512LE;
const Uint512BE = createUintBICodec(64);
/**
 * @alias Uint512LE
 */

exports.Uint512BE = Uint512BE;
const Uint512 = Uint512LE;
exports.Uint512 = Uint512;
//# sourceMappingURL=uint.js.map