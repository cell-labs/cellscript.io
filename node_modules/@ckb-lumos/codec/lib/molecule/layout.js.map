{"version":3,"file":"layout.js","names":["array","itemCodec","itemCount","enhancedArrayCodec","createArrayCodec","createFixedBytesCodec","byteLength","pack","items","itemsBuf","concat","unpack","buf","result","itemLength","offset","push","slice","diff","x1","x2","filter","x","includes","checkShape","shape","fields","shapeKeys","Object","keys","missingFields","missingShape","length","Error","join","struct","objectCodec","createObjectCodec","reduce","sum","field","obj","packed","Uint8Array","from","forEach","itemBuf","assign","fixvec","createBytesCodec","arrayCodec","Uint32LE","item","ArrayBuffer","dynvec","packedHeader","header","body","packedTotalSize","totalSize","offset0","offsets","Array","fill","map","_","index","start","end","vector","isFixedCodec","table","headerLength","packedObj","packedItem","packedOffset","union","type","typeName","CodecBaseParseError","fieldIndex","indexOf","String","packedFieldIndex","packedBody","value","typeIndex","option","nullableCodec","createNullableCodec","undefined"],"sources":["../../src/molecule/layout.ts"],"sourcesContent":["/**\n * |  Type  |                      Header                      |               Body                |\n * |--------+--------------------------------------------------+-----------------------------------|\n * | array  |                                                  |  item-0 |  item-1 | ... |  item-N |\n * | struct |                                                  | field-0 | field-1 | ... | field-N |\n * | fixvec | items-count                                      |  item-0 |  item-1 | ... |  item-N |\n * | dynvec | full-size | offset-0 | offset-1 | ... | offset-N |  item-0 |  item-1 | ... |  item-N |\n * | table  | full-size | offset-0 | offset-1 | ... | offset-N | filed-0 | field-1 | ... | field-N |\n * | option |                                                  | item or none (zero bytes)         |\n * | union  | item-type-id                                     | item                              |\n */\n\nimport {\n  BytesCodec,\n  Fixed,\n  FixedBytesCodec,\n  PackParam,\n  UnpackResult,\n  createBytesCodec,\n  createFixedBytesCodec,\n  isFixedCodec,\n} from \"../base\";\nimport { Uint32LE } from \"../number\";\nimport { concat } from \"../bytes\";\nimport { CodecBaseParseError } from \"../error\";\nimport {\n  createObjectCodec,\n  createArrayCodec,\n  createNullableCodec,\n} from \"../high-order\";\n\ntype NullableKeys<O extends Record<string, unknown>> = {\n  [K in keyof O]-?: [O[K] & (undefined | null)] extends [never] ? never : K;\n}[keyof O];\ntype NonNullableKeys<O extends Record<string, unknown>> = {\n  [K in keyof O]-?: [O[K] & (undefined | null)] extends [never] ? K : never;\n}[keyof O];\n\n// prettier-ignore\ntype PartialNullable<O extends Record<string, unknown>> =\n  & Partial<Pick<O, NullableKeys<O>>>\n  & Pick<O, NonNullableKeys<O>>;\n\nexport type ObjectCodec<T extends Record<string, BytesCodec>> = BytesCodec<\n  PartialNullable<{ [key in keyof T]: UnpackResult<T[key]> }>,\n  PartialNullable<{ [key in keyof T]: PackParam<T[key]> }>\n>;\n\nexport interface OptionCodec<T extends BytesCodec>\n  extends BytesCodec<UnpackResult<T> | undefined> {\n  pack: (packable?: PackParam<T>) => Uint8Array;\n}\n\nexport type ArrayCodec<T extends BytesCodec> = BytesCodec<\n  Array<UnpackResult<T>>,\n  Array<PackParam<T>>\n>;\n\nexport type UnionCodec<T extends Record<string, BytesCodec>> = BytesCodec<\n  { [key in keyof T]: { type: key; value: UnpackResult<T[key]> } }[keyof T],\n  { [key in keyof T]: { type: key; value: PackParam<T[key]> } }[keyof T]\n>;\n\n/**\n * The array is a fixed-size type: it has a fixed-size inner type and a fixed length.\n * The size of an array is the size of inner type times the length.\n * @param itemCodec the fixed-size array item codec\n * @param itemCount\n */\nexport function array<T extends FixedBytesCodec>(\n  itemCodec: T,\n  itemCount: number\n): ArrayCodec<T> & Fixed {\n  const enhancedArrayCodec = createArrayCodec(itemCodec);\n  return createFixedBytesCodec({\n    byteLength: itemCodec.byteLength * itemCount,\n    pack(items) {\n      const itemsBuf = enhancedArrayCodec.pack(items);\n      return concat(...itemsBuf);\n    },\n    unpack(buf) {\n      const result: UnpackResult<T>[] = [];\n      const itemLength = itemCodec.byteLength;\n      for (let offset = 0; offset < buf.byteLength; offset += itemLength) {\n        result.push(itemCodec.unpack(buf.slice(offset, offset + itemLength)));\n      }\n      return result;\n    },\n  });\n}\n\nfunction diff(x1: unknown[], x2: unknown[]) {\n  return x1.filter((x) => !x2.includes(x));\n}\n\nfunction checkShape<T>(shape: T, fields: (keyof T)[]) {\n  const shapeKeys = Object.keys(shape) as (keyof T)[];\n\n  const missingFields = diff(shapeKeys, fields);\n  const missingShape = diff(fields, shapeKeys);\n\n  if (missingFields.length > 0 || missingShape.length > 0) {\n    throw new Error(\n      `Invalid shape: missing fields ${missingFields.join(\n        \", \"\n      )} or shape ${missingShape.join(\", \")}`\n    );\n  }\n}\n\n/**\n * Struct is a fixed-size type: all fields in struct are fixed-size and it has a fixed quantity of fields.\n * The size of a struct is the sum of all fields' size.\n * @param shape a object contains all fields' codec\n * @param fields the shape's keys. It provide an order for serialization/deserialization.\n */\nexport function struct<T extends Record<string, FixedBytesCodec>>(\n  shape: T,\n  fields: (keyof T)[]\n): ObjectCodec<T> & Fixed {\n  checkShape(shape, fields);\n  const objectCodec = createObjectCodec(shape);\n  return createFixedBytesCodec({\n    byteLength: fields.reduce((sum, field) => sum + shape[field].byteLength, 0),\n    pack(obj) {\n      const packed = objectCodec.pack(\n        obj as { [K in keyof T]: PackParam<T[K]> }\n      );\n      return fields.reduce((result, field) => {\n        return concat(result, packed[field]);\n      }, Uint8Array.from([]));\n    },\n    unpack(buf) {\n      const result = {} as PartialNullable<{\n        [key in keyof T]: UnpackResult<T[key]>;\n      }>;\n      let offset = 0;\n\n      fields.forEach((field) => {\n        const itemCodec = shape[field];\n        const itemBuf = buf.slice(offset, offset + itemCodec.byteLength);\n        Object.assign(result, { [field]: itemCodec.unpack(itemBuf) });\n\n        offset = offset + itemCodec.byteLength;\n      });\n\n      return result;\n    },\n  });\n}\n\n/**\n * Vector with fixed size item codec\n * @param itemCodec fixed-size vector item codec\n */\nexport function fixvec<T extends FixedBytesCodec>(itemCodec: T): ArrayCodec<T> {\n  return createBytesCodec({\n    pack(items) {\n      const arrayCodec = createArrayCodec(itemCodec);\n      return concat(\n        Uint32LE.pack(items.length),\n        arrayCodec\n          .pack(items)\n          .reduce((buf, item) => concat(buf, item), new ArrayBuffer(0))\n      );\n    },\n    unpack(buf) {\n      if (buf.byteLength < 4) {\n        throw new Error(\n          `fixvec: buffer is too short, expected at least 4 bytes, got ${buf.byteLength}`\n        );\n      }\n      const itemCount = Uint32LE.unpack(buf.slice(0, 4));\n      return array(itemCodec, itemCount).unpack(buf.slice(4));\n    },\n  });\n}\n\n/**\n * Vector with dynamic size item codec\n * @param itemCodec the vector item codec. It can be fixed-size or dynamic-size.\n * For example, you can create a recursive vector with this.\n */\nexport function dynvec<T extends BytesCodec>(itemCodec: T): ArrayCodec<T> {\n  return createBytesCodec({\n    pack(obj) {\n      const arrayCodec = createArrayCodec(itemCodec);\n      const packed = arrayCodec.pack(obj).reduce(\n        (result, item) => {\n          const packedHeader = Uint32LE.pack(result.offset);\n          return {\n            header: concat(result.header, packedHeader),\n            body: concat(result.body, item),\n            offset: result.offset + item.byteLength,\n          };\n        },\n        {\n          header: new ArrayBuffer(0),\n          body: new ArrayBuffer(0),\n          offset: 4 + obj.length * 4,\n        }\n      );\n      const packedTotalSize = Uint32LE.pack(\n        packed.header.byteLength + packed.body.byteLength + 4\n      );\n      return concat(packedTotalSize, packed.header, packed.body);\n    },\n    unpack(buf) {\n      const totalSize = Uint32LE.unpack(buf.slice(0, 4));\n      if (totalSize !== buf.byteLength) {\n        throw new Error(\n          `Invalid buffer size, read from header: ${totalSize}, actual: ${buf.byteLength}`\n        );\n      }\n      const result: UnpackResult<T>[] = [];\n      if (totalSize <= 4) {\n        return result;\n      } else {\n        const offset0 = Uint32LE.unpack(buf.slice(4, 8));\n        const itemCount = (offset0 - 4) / 4;\n        const offsets = new Array(itemCount)\n          .fill(1)\n          .map((_, index) =>\n            Uint32LE.unpack(buf.slice(4 + index * 4, 8 + index * 4))\n          );\n        offsets.push(totalSize);\n        const result: UnpackResult<T>[] = [];\n        for (let index = 0; index < offsets.length - 1; index++) {\n          const start = offsets[index];\n          const end = offsets[index + 1];\n          const itemBuf = buf.slice(start, end);\n          result.push(itemCodec.unpack(itemBuf));\n        }\n        return result;\n      }\n    },\n  });\n}\n\n/**\n * General vector codec, if `itemCodec` is fixed size type, it will create a fixvec codec, otherwise a dynvec codec will be created.\n * @param itemCodec\n */\nexport function vector<T extends BytesCodec>(itemCodec: T): ArrayCodec<T> {\n  if (isFixedCodec(itemCodec)) {\n    return fixvec(itemCodec);\n  }\n  return dynvec(itemCodec);\n}\n\n/**\n * Table is a dynamic-size type. It can be considered as a dynvec but the length is fixed.\n * @param shape The table shape, item codec can be dynamic size\n * @param fields the shape's keys. Also provide an order for pack/unpack.\n */\nexport function table<T extends Record<string, BytesCodec>>(\n  shape: T,\n  fields: (keyof T)[]\n): ObjectCodec<T> {\n  checkShape(shape, fields);\n  return createBytesCodec({\n    pack(obj) {\n      const headerLength = 4 + fields.length * 4;\n      const objectCodec = createObjectCodec(shape);\n      const packedObj = objectCodec.pack(\n        obj as { [K in keyof T]: PackParam<T[K]> }\n      );\n      const packed = fields.reduce(\n        (result, field) => {\n          const packedItem = packedObj[field];\n          const packedOffset = Uint32LE.pack(result.offset);\n          return {\n            header: concat(result.header, packedOffset),\n            body: concat(result.body, packedItem),\n            offset: result.offset + packedItem.byteLength,\n          };\n        },\n        {\n          header: new ArrayBuffer(0),\n          body: new ArrayBuffer(0),\n          offset: headerLength,\n        }\n      );\n      const packedTotalSize = Uint32LE.pack(\n        packed.header.byteLength + packed.body.byteLength + 4\n      );\n      return concat(packedTotalSize, packed.header, packed.body);\n    },\n    unpack(buf) {\n      const totalSize = Uint32LE.unpack(buf.slice(0, 4));\n      if (totalSize !== buf.byteLength) {\n        throw new Error(\n          `Invalid buffer size, read from header: ${totalSize}, actual: ${buf.byteLength}`\n        );\n      }\n      if (totalSize <= 4 || fields.length === 0) {\n        return {} as PartialNullable<{\n          [key in keyof T]: UnpackResult<T[key]>;\n        }>;\n      } else {\n        const offsets = fields.map((_, index) =>\n          Uint32LE.unpack(buf.slice(4 + index * 4, 8 + index * 4))\n        );\n        offsets.push(totalSize);\n        const obj = {};\n        for (let index = 0; index < offsets.length - 1; index++) {\n          const start = offsets[index];\n          const end = offsets[index + 1];\n          const field = fields[index];\n          const itemCodec = shape[field];\n          const itemBuf = buf.slice(start, end);\n          Object.assign(obj, { [field]: itemCodec.unpack(itemBuf) });\n        }\n        return obj as PartialNullable<{\n          [key in keyof T]: UnpackResult<T[key]>;\n        }>;\n      }\n    },\n  });\n}\n\n/**\n * Union is a dynamic-size type.\n * Serializing a union has two steps:\n * - Serialize a item type id in bytes as a 32 bit unsigned integer in little-endian. The item type id is the index of the inner items, and it's starting at 0.\n * - Serialize the inner item.\n * @param itemCodec the union item record\n * @param fields the list of itemCodec's keys. It's also provide an order for pack/unpack.\n */\nexport function union<T extends Record<string, BytesCodec>>(\n  itemCodec: T,\n  fields: (keyof T)[]\n): UnionCodec<T> {\n  return createBytesCodec({\n    pack(obj) {\n      const type = obj.type;\n      const typeName = `Union(${fields.join(\" | \")})`;\n\n      /* c8 ignore next */\n      if (typeof type !== \"string\") {\n        throw new CodecBaseParseError(\n          `Invalid type in union, type must be a string`,\n          typeName\n        );\n      }\n\n      const fieldIndex = fields.indexOf(type);\n      if (fieldIndex === -1) {\n        throw new CodecBaseParseError(\n          `Unknown union type: ${String(obj.type)}`,\n          typeName\n        );\n      }\n      const packedFieldIndex = Uint32LE.pack(fieldIndex);\n      const packedBody = itemCodec[type].pack(obj.value);\n      return concat(packedFieldIndex, packedBody);\n    },\n    unpack(buf) {\n      const typeIndex = Uint32LE.unpack(buf.slice(0, 4));\n      const type = fields[typeIndex];\n      return { type, value: itemCodec[type].unpack(buf.slice(4)) };\n    },\n  });\n}\n\n/**\n * Option is a dynamic-size type.\n * Serializing an option depends on whether it is empty or not:\n * - if it's empty, there is zero bytes (the size is 0).\n * - if it's not empty, just serialize the inner item (the size is same as the inner item's size).\n * @param itemCodec\n */\nexport function option<T extends BytesCodec>(itemCodec: T): OptionCodec<T> {\n  return createBytesCodec({\n    pack(obj?) {\n      const nullableCodec = createNullableCodec(itemCodec);\n      if (obj !== undefined && obj !== null) {\n        return nullableCodec.pack(obj);\n      } else {\n        return Uint8Array.from([]);\n      }\n    },\n    unpack(buf) {\n      if (buf.byteLength === 0) {\n        return undefined;\n      }\n      return itemCodec.unpack(buf);\n    },\n  });\n}\n"],"mappings":";;;;;;;;;;;;;;AAYA;;AAUA;;AACA;;AACA;;AACA;;AAzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAqDA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,KAAT,CACLC,SADK,EAELC,SAFK,EAGkB;EACvB,MAAMC,kBAAkB,GAAG,IAAAC,2BAAA,EAAiBH,SAAjB,CAA3B;EACA,OAAO,IAAAI,2BAAA,EAAsB;IAC3BC,UAAU,EAAEL,SAAS,CAACK,UAAV,GAAuBJ,SADR;;IAE3BK,IAAI,CAACC,KAAD,EAAQ;MACV,MAAMC,QAAQ,GAAGN,kBAAkB,CAACI,IAAnB,CAAwBC,KAAxB,CAAjB;MACA,OAAO,IAAAE,aAAA,EAAO,GAAGD,QAAV,CAAP;IACD,CAL0B;;IAM3BE,MAAM,CAACC,GAAD,EAAM;MACV,MAAMC,MAAyB,GAAG,EAAlC;MACA,MAAMC,UAAU,GAAGb,SAAS,CAACK,UAA7B;;MACA,KAAK,IAAIS,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGH,GAAG,CAACN,UAAlC,EAA8CS,MAAM,IAAID,UAAxD,EAAoE;QAClED,MAAM,CAACG,IAAP,CAAYf,SAAS,CAACU,MAAV,CAAiBC,GAAG,CAACK,KAAJ,CAAUF,MAAV,EAAkBA,MAAM,GAAGD,UAA3B,CAAjB,CAAZ;MACD;;MACD,OAAOD,MAAP;IACD;;EAb0B,CAAtB,CAAP;AAeD;;AAED,SAASK,IAAT,CAAcC,EAAd,EAA6BC,EAA7B,EAA4C;EAC1C,OAAOD,EAAE,CAACE,MAAH,CAAWC,CAAD,IAAO,CAACF,EAAE,CAACG,QAAH,CAAYD,CAAZ,CAAlB,CAAP;AACD;;AAED,SAASE,UAAT,CAAuBC,KAAvB,EAAiCC,MAAjC,EAAsD;EACpD,MAAMC,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,CAAlB;EAEA,MAAMK,aAAa,GAAGZ,IAAI,CAACS,SAAD,EAAYD,MAAZ,CAA1B;EACA,MAAMK,YAAY,GAAGb,IAAI,CAACQ,MAAD,EAASC,SAAT,CAAzB;;EAEA,IAAIG,aAAa,CAACE,MAAd,GAAuB,CAAvB,IAA4BD,YAAY,CAACC,MAAb,GAAsB,CAAtD,EAAyD;IACvD,MAAM,IAAIC,KAAJ,CACH,iCAAgCH,aAAa,CAACI,IAAd,CAC/B,IAD+B,CAE/B,aAAYH,YAAY,CAACG,IAAb,CAAkB,IAAlB,CAAwB,EAHlC,CAAN;EAKD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASC,MAAT,CACLV,KADK,EAELC,MAFK,EAGmB;EACxBF,UAAU,CAACC,KAAD,EAAQC,MAAR,CAAV;EACA,MAAMU,WAAW,GAAG,IAAAC,4BAAA,EAAkBZ,KAAlB,CAApB;EACA,OAAO,IAAApB,2BAAA,EAAsB;IAC3BC,UAAU,EAAEoB,MAAM,CAACY,MAAP,CAAc,CAACC,GAAD,EAAMC,KAAN,KAAgBD,GAAG,GAAGd,KAAK,CAACe,KAAD,CAAL,CAAalC,UAAjD,EAA6D,CAA7D,CADe;;IAE3BC,IAAI,CAACkC,GAAD,EAAM;MACR,MAAMC,MAAM,GAAGN,WAAW,CAAC7B,IAAZ,CACbkC,GADa,CAAf;MAGA,OAAOf,MAAM,CAACY,MAAP,CAAc,CAACzB,MAAD,EAAS2B,KAAT,KAAmB;QACtC,OAAO,IAAA9B,aAAA,EAAOG,MAAP,EAAe6B,MAAM,CAACF,KAAD,CAArB,CAAP;MACD,CAFM,EAEJG,UAAU,CAACC,IAAX,CAAgB,EAAhB,CAFI,CAAP;IAGD,CAT0B;;IAU3BjC,MAAM,CAACC,GAAD,EAAM;MACV,MAAMC,MAAM,GAAG,EAAf;MAGA,IAAIE,MAAM,GAAG,CAAb;MAEAW,MAAM,CAACmB,OAAP,CAAgBL,KAAD,IAAW;QACxB,MAAMvC,SAAS,GAAGwB,KAAK,CAACe,KAAD,CAAvB;QACA,MAAMM,OAAO,GAAGlC,GAAG,CAACK,KAAJ,CAAUF,MAAV,EAAkBA,MAAM,GAAGd,SAAS,CAACK,UAArC,CAAhB;QACAsB,MAAM,CAACmB,MAAP,CAAclC,MAAd,EAAsB;UAAE,CAAC2B,KAAD,GAASvC,SAAS,CAACU,MAAV,CAAiBmC,OAAjB;QAAX,CAAtB;QAEA/B,MAAM,GAAGA,MAAM,GAAGd,SAAS,CAACK,UAA5B;MACD,CAND;MAQA,OAAOO,MAAP;IACD;;EAzB0B,CAAtB,CAAP;AA2BD;AAED;AACA;AACA;AACA;;;AACO,SAASmC,MAAT,CAA2C/C,SAA3C,EAAwE;EAC7E,OAAO,IAAAgD,sBAAA,EAAiB;IACtB1C,IAAI,CAACC,KAAD,EAAQ;MACV,MAAM0C,UAAU,GAAG,IAAA9C,2BAAA,EAAiBH,SAAjB,CAAnB;MACA,OAAO,IAAAS,aAAA,EACLyC,gBAAA,CAAS5C,IAAT,CAAcC,KAAK,CAACwB,MAApB,CADK,EAELkB,UAAU,CACP3C,IADH,CACQC,KADR,EAEG8B,MAFH,CAEU,CAAC1B,GAAD,EAAMwC,IAAN,KAAe,IAAA1C,aAAA,EAAOE,GAAP,EAAYwC,IAAZ,CAFzB,EAE4C,IAAIC,WAAJ,CAAgB,CAAhB,CAF5C,CAFK,CAAP;IAMD,CATqB;;IAUtB1C,MAAM,CAACC,GAAD,EAAM;MACV,IAAIA,GAAG,CAACN,UAAJ,GAAiB,CAArB,EAAwB;QACtB,MAAM,IAAI2B,KAAJ,CACH,+DAA8DrB,GAAG,CAACN,UAAW,EAD1E,CAAN;MAGD;;MACD,MAAMJ,SAAS,GAAGiD,gBAAA,CAASxC,MAAT,CAAgBC,GAAG,CAACK,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAhB,CAAlB;;MACA,OAAOjB,KAAK,CAACC,SAAD,EAAYC,SAAZ,CAAL,CAA4BS,MAA5B,CAAmCC,GAAG,CAACK,KAAJ,CAAU,CAAV,CAAnC,CAAP;IACD;;EAlBqB,CAAjB,CAAP;AAoBD;AAED;AACA;AACA;AACA;AACA;;;AACO,SAASqC,MAAT,CAAsCrD,SAAtC,EAAmE;EACxE,OAAO,IAAAgD,sBAAA,EAAiB;IACtB1C,IAAI,CAACkC,GAAD,EAAM;MACR,MAAMS,UAAU,GAAG,IAAA9C,2BAAA,EAAiBH,SAAjB,CAAnB;MACA,MAAMyC,MAAM,GAAGQ,UAAU,CAAC3C,IAAX,CAAgBkC,GAAhB,EAAqBH,MAArB,CACb,CAACzB,MAAD,EAASuC,IAAT,KAAkB;QAChB,MAAMG,YAAY,GAAGJ,gBAAA,CAAS5C,IAAT,CAAcM,MAAM,CAACE,MAArB,CAArB;;QACA,OAAO;UACLyC,MAAM,EAAE,IAAA9C,aAAA,EAAOG,MAAM,CAAC2C,MAAd,EAAsBD,YAAtB,CADH;UAELE,IAAI,EAAE,IAAA/C,aAAA,EAAOG,MAAM,CAAC4C,IAAd,EAAoBL,IAApB,CAFD;UAGLrC,MAAM,EAAEF,MAAM,CAACE,MAAP,GAAgBqC,IAAI,CAAC9C;QAHxB,CAAP;MAKD,CARY,EASb;QACEkD,MAAM,EAAE,IAAIH,WAAJ,CAAgB,CAAhB,CADV;QAEEI,IAAI,EAAE,IAAIJ,WAAJ,CAAgB,CAAhB,CAFR;QAGEtC,MAAM,EAAE,IAAI0B,GAAG,CAACT,MAAJ,GAAa;MAH3B,CATa,CAAf;;MAeA,MAAM0B,eAAe,GAAGP,gBAAA,CAAS5C,IAAT,CACtBmC,MAAM,CAACc,MAAP,CAAclD,UAAd,GAA2BoC,MAAM,CAACe,IAAP,CAAYnD,UAAvC,GAAoD,CAD9B,CAAxB;;MAGA,OAAO,IAAAI,aAAA,EAAOgD,eAAP,EAAwBhB,MAAM,CAACc,MAA/B,EAAuCd,MAAM,CAACe,IAA9C,CAAP;IACD,CAtBqB;;IAuBtB9C,MAAM,CAACC,GAAD,EAAM;MACV,MAAM+C,SAAS,GAAGR,gBAAA,CAASxC,MAAT,CAAgBC,GAAG,CAACK,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAhB,CAAlB;;MACA,IAAI0C,SAAS,KAAK/C,GAAG,CAACN,UAAtB,EAAkC;QAChC,MAAM,IAAI2B,KAAJ,CACH,0CAAyC0B,SAAU,aAAY/C,GAAG,CAACN,UAAW,EAD3E,CAAN;MAGD;;MACD,MAAMO,MAAyB,GAAG,EAAlC;;MACA,IAAI8C,SAAS,IAAI,CAAjB,EAAoB;QAClB,OAAO9C,MAAP;MACD,CAFD,MAEO;QACL,MAAM+C,OAAO,GAAGT,gBAAA,CAASxC,MAAT,CAAgBC,GAAG,CAACK,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAhB,CAAhB;;QACA,MAAMf,SAAS,GAAG,CAAC0D,OAAO,GAAG,CAAX,IAAgB,CAAlC;QACA,MAAMC,OAAO,GAAG,IAAIC,KAAJ,CAAU5D,SAAV,EACb6D,IADa,CACR,CADQ,EAEbC,GAFa,CAET,CAACC,CAAD,EAAIC,KAAJ,KACHf,gBAAA,CAASxC,MAAT,CAAgBC,GAAG,CAACK,KAAJ,CAAU,IAAIiD,KAAK,GAAG,CAAtB,EAAyB,IAAIA,KAAK,GAAG,CAArC,CAAhB,CAHY,CAAhB;QAKAL,OAAO,CAAC7C,IAAR,CAAa2C,SAAb;QACA,MAAM9C,MAAyB,GAAG,EAAlC;;QACA,KAAK,IAAIqD,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGL,OAAO,CAAC7B,MAAR,GAAiB,CAA7C,EAAgDkC,KAAK,EAArD,EAAyD;UACvD,MAAMC,KAAK,GAAGN,OAAO,CAACK,KAAD,CAArB;UACA,MAAME,GAAG,GAAGP,OAAO,CAACK,KAAK,GAAG,CAAT,CAAnB;UACA,MAAMpB,OAAO,GAAGlC,GAAG,CAACK,KAAJ,CAAUkD,KAAV,EAAiBC,GAAjB,CAAhB;UACAvD,MAAM,CAACG,IAAP,CAAYf,SAAS,CAACU,MAAV,CAAiBmC,OAAjB,CAAZ;QACD;;QACD,OAAOjC,MAAP;MACD;IACF;;EAnDqB,CAAjB,CAAP;AAqDD;AAED;AACA;AACA;AACA;;;AACO,SAASwD,MAAT,CAAsCpE,SAAtC,EAAmE;EACxE,IAAI,IAAAqE,kBAAA,EAAarE,SAAb,CAAJ,EAA6B;IAC3B,OAAO+C,MAAM,CAAC/C,SAAD,CAAb;EACD;;EACD,OAAOqD,MAAM,CAACrD,SAAD,CAAb;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,SAASsE,KAAT,CACL9C,KADK,EAELC,MAFK,EAGW;EAChBF,UAAU,CAACC,KAAD,EAAQC,MAAR,CAAV;EACA,OAAO,IAAAuB,sBAAA,EAAiB;IACtB1C,IAAI,CAACkC,GAAD,EAAM;MACR,MAAM+B,YAAY,GAAG,IAAI9C,MAAM,CAACM,MAAP,GAAgB,CAAzC;MACA,MAAMI,WAAW,GAAG,IAAAC,4BAAA,EAAkBZ,KAAlB,CAApB;MACA,MAAMgD,SAAS,GAAGrC,WAAW,CAAC7B,IAAZ,CAChBkC,GADgB,CAAlB;MAGA,MAAMC,MAAM,GAAGhB,MAAM,CAACY,MAAP,CACb,CAACzB,MAAD,EAAS2B,KAAT,KAAmB;QACjB,MAAMkC,UAAU,GAAGD,SAAS,CAACjC,KAAD,CAA5B;;QACA,MAAMmC,YAAY,GAAGxB,gBAAA,CAAS5C,IAAT,CAAcM,MAAM,CAACE,MAArB,CAArB;;QACA,OAAO;UACLyC,MAAM,EAAE,IAAA9C,aAAA,EAAOG,MAAM,CAAC2C,MAAd,EAAsBmB,YAAtB,CADH;UAELlB,IAAI,EAAE,IAAA/C,aAAA,EAAOG,MAAM,CAAC4C,IAAd,EAAoBiB,UAApB,CAFD;UAGL3D,MAAM,EAAEF,MAAM,CAACE,MAAP,GAAgB2D,UAAU,CAACpE;QAH9B,CAAP;MAKD,CATY,EAUb;QACEkD,MAAM,EAAE,IAAIH,WAAJ,CAAgB,CAAhB,CADV;QAEEI,IAAI,EAAE,IAAIJ,WAAJ,CAAgB,CAAhB,CAFR;QAGEtC,MAAM,EAAEyD;MAHV,CAVa,CAAf;;MAgBA,MAAMd,eAAe,GAAGP,gBAAA,CAAS5C,IAAT,CACtBmC,MAAM,CAACc,MAAP,CAAclD,UAAd,GAA2BoC,MAAM,CAACe,IAAP,CAAYnD,UAAvC,GAAoD,CAD9B,CAAxB;;MAGA,OAAO,IAAAI,aAAA,EAAOgD,eAAP,EAAwBhB,MAAM,CAACc,MAA/B,EAAuCd,MAAM,CAACe,IAA9C,CAAP;IACD,CA3BqB;;IA4BtB9C,MAAM,CAACC,GAAD,EAAM;MACV,MAAM+C,SAAS,GAAGR,gBAAA,CAASxC,MAAT,CAAgBC,GAAG,CAACK,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAhB,CAAlB;;MACA,IAAI0C,SAAS,KAAK/C,GAAG,CAACN,UAAtB,EAAkC;QAChC,MAAM,IAAI2B,KAAJ,CACH,0CAAyC0B,SAAU,aAAY/C,GAAG,CAACN,UAAW,EAD3E,CAAN;MAGD;;MACD,IAAIqD,SAAS,IAAI,CAAb,IAAkBjC,MAAM,CAACM,MAAP,KAAkB,CAAxC,EAA2C;QACzC,OAAO,EAAP;MAGD,CAJD,MAIO;QACL,MAAM6B,OAAO,GAAGnC,MAAM,CAACsC,GAAP,CAAW,CAACC,CAAD,EAAIC,KAAJ,KACzBf,gBAAA,CAASxC,MAAT,CAAgBC,GAAG,CAACK,KAAJ,CAAU,IAAIiD,KAAK,GAAG,CAAtB,EAAyB,IAAIA,KAAK,GAAG,CAArC,CAAhB,CADc,CAAhB;QAGAL,OAAO,CAAC7C,IAAR,CAAa2C,SAAb;QACA,MAAMlB,GAAG,GAAG,EAAZ;;QACA,KAAK,IAAIyB,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGL,OAAO,CAAC7B,MAAR,GAAiB,CAA7C,EAAgDkC,KAAK,EAArD,EAAyD;UACvD,MAAMC,KAAK,GAAGN,OAAO,CAACK,KAAD,CAArB;UACA,MAAME,GAAG,GAAGP,OAAO,CAACK,KAAK,GAAG,CAAT,CAAnB;UACA,MAAM1B,KAAK,GAAGd,MAAM,CAACwC,KAAD,CAApB;UACA,MAAMjE,SAAS,GAAGwB,KAAK,CAACe,KAAD,CAAvB;UACA,MAAMM,OAAO,GAAGlC,GAAG,CAACK,KAAJ,CAAUkD,KAAV,EAAiBC,GAAjB,CAAhB;UACAxC,MAAM,CAACmB,MAAP,CAAcN,GAAd,EAAmB;YAAE,CAACD,KAAD,GAASvC,SAAS,CAACU,MAAV,CAAiBmC,OAAjB;UAAX,CAAnB;QACD;;QACD,OAAOL,GAAP;MAGD;IACF;;EAzDqB,CAAjB,CAAP;AA2DD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASmC,KAAT,CACL3E,SADK,EAELyB,MAFK,EAGU;EACf,OAAO,IAAAuB,sBAAA,EAAiB;IACtB1C,IAAI,CAACkC,GAAD,EAAM;MACR,MAAMoC,IAAI,GAAGpC,GAAG,CAACoC,IAAjB;MACA,MAAMC,QAAQ,GAAI,SAAQpD,MAAM,CAACQ,IAAP,CAAY,KAAZ,CAAmB,GAA7C;MAEA;;MACA,IAAI,OAAO2C,IAAP,KAAgB,QAApB,EAA8B;QAC5B,MAAM,IAAIE,0BAAJ,CACH,8CADG,EAEJD,QAFI,CAAN;MAID;;MAED,MAAME,UAAU,GAAGtD,MAAM,CAACuD,OAAP,CAAeJ,IAAf,CAAnB;;MACA,IAAIG,UAAU,KAAK,CAAC,CAApB,EAAuB;QACrB,MAAM,IAAID,0BAAJ,CACH,uBAAsBG,MAAM,CAACzC,GAAG,CAACoC,IAAL,CAAW,EADpC,EAEJC,QAFI,CAAN;MAID;;MACD,MAAMK,gBAAgB,GAAGhC,gBAAA,CAAS5C,IAAT,CAAcyE,UAAd,CAAzB;;MACA,MAAMI,UAAU,GAAGnF,SAAS,CAAC4E,IAAD,CAAT,CAAgBtE,IAAhB,CAAqBkC,GAAG,CAAC4C,KAAzB,CAAnB;MACA,OAAO,IAAA3E,aAAA,EAAOyE,gBAAP,EAAyBC,UAAzB,CAAP;IACD,CAvBqB;;IAwBtBzE,MAAM,CAACC,GAAD,EAAM;MACV,MAAM0E,SAAS,GAAGnC,gBAAA,CAASxC,MAAT,CAAgBC,GAAG,CAACK,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAhB,CAAlB;;MACA,MAAM4D,IAAI,GAAGnD,MAAM,CAAC4D,SAAD,CAAnB;MACA,OAAO;QAAET,IAAF;QAAQQ,KAAK,EAAEpF,SAAS,CAAC4E,IAAD,CAAT,CAAgBlE,MAAhB,CAAuBC,GAAG,CAACK,KAAJ,CAAU,CAAV,CAAvB;MAAf,CAAP;IACD;;EA5BqB,CAAjB,CAAP;AA8BD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASsE,MAAT,CAAsCtF,SAAtC,EAAoE;EACzE,OAAO,IAAAgD,sBAAA,EAAiB;IACtB1C,IAAI,CAACkC,GAAD,EAAO;MACT,MAAM+C,aAAa,GAAG,IAAAC,8BAAA,EAAoBxF,SAApB,CAAtB;;MACA,IAAIwC,GAAG,KAAKiD,SAAR,IAAqBjD,GAAG,KAAK,IAAjC,EAAuC;QACrC,OAAO+C,aAAa,CAACjF,IAAd,CAAmBkC,GAAnB,CAAP;MACD,CAFD,MAEO;QACL,OAAOE,UAAU,CAACC,IAAX,CAAgB,EAAhB,CAAP;MACD;IACF,CARqB;;IAStBjC,MAAM,CAACC,GAAD,EAAM;MACV,IAAIA,GAAG,CAACN,UAAJ,KAAmB,CAAvB,EAA0B;QACxB,OAAOoF,SAAP;MACD;;MACD,OAAOzF,SAAS,CAACU,MAAV,CAAiBC,GAAjB,CAAP;IACD;;EAdqB,CAAjB,CAAP;AAgBD"}