{"version":3,"file":"base.js","names":["createBytesCodec","codec","pack","unpacked","unpack","bytesLike","bytify","isFixedCodec","isObjectLike","__isFixedCodec__","createFixedBytesCodec","byteLength","u","packed","assertBufferLength","buf"],"sources":["../src/base.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { assertBufferLength, isObjectLike } from \"./utils\";\nimport { bytify } from \"./bytes\";\n\nexport interface Codec<\n  Packed,\n  Unpacked,\n  Packable = Unpacked,\n  Unpackable = Packed\n> {\n  pack: (packable: Packable) => Packed;\n  unpack: (unpackable: Unpackable) => Unpacked;\n}\n\nexport type AnyCodec = Codec<any, any>;\n\nexport type PackResult<T extends AnyCodec> = T extends Codec<\n  infer Packed,\n  infer Unpacked,\n  infer Packable,\n  infer Unpackable\n>\n  ? Packed\n  : never;\nexport type PackParam<T extends AnyCodec> = T extends Codec<\n  infer Packed,\n  infer Unpacked,\n  infer Packable,\n  infer Unpackable\n>\n  ? Packable\n  : never;\n\nexport type UnpackResult<T extends AnyCodec> = T extends Codec<\n  infer Packed,\n  infer Unpacked,\n  infer Packable,\n  infer Unpackable\n>\n  ? Unpacked\n  : never;\n\nexport type UnpackParam<T extends AnyCodec> = T extends Codec<\n  infer Packed,\n  infer Unpacked,\n  infer Packable,\n  infer Unpackable\n>\n  ? Unpackable\n  : never;\n\nexport type Uint8ArrayCodec<Unpacked = any, Packable = Unpacked> = Codec<\n  Uint8Array,\n  Unpacked,\n  Packable\n>;\n\nexport type BytesLike = ArrayLike<number> | ArrayBuffer | string;\n\nexport type BytesCodec<Unpacked = any, Packable = Unpacked> = Codec<\n  Uint8Array,\n  Unpacked,\n  Packable,\n  BytesLike\n>;\n\n/**\n * This function helps to create a codec that can\n * @param codec\n */\nexport function createBytesCodec<Unpacked, Packable = Unpacked>(\n  codec: Uint8ArrayCodec<Unpacked, Packable>\n): BytesCodec<Unpacked, Packable> {\n  return {\n    pack: (unpacked) => codec.pack(unpacked),\n    unpack: (bytesLike) => codec.unpack(bytify(bytesLike)),\n  };\n}\n\nexport type Fixed = {\n  readonly __isFixedCodec__: true;\n  readonly byteLength: number;\n};\n\nexport type FixedBytesCodec<Unpacked = any, Packable = Unpacked> = BytesCodec<\n  Unpacked,\n  Packable\n> &\n  Fixed;\n\nexport function isFixedCodec<T>(\n  codec: BytesCodec<T>\n): codec is FixedBytesCodec<T> {\n  return isObjectLike(codec) && !!codec.__isFixedCodec__;\n}\n\nexport function createFixedBytesCodec<Unpacked, Packable = Unpacked>(\n  codec: Uint8ArrayCodec<Unpacked, Packable> & { byteLength: number }\n): FixedBytesCodec<Unpacked, Packable> {\n  const byteLength = codec.byteLength;\n  return {\n    __isFixedCodec__: true,\n    byteLength,\n    ...createBytesCodec({\n      pack: (u) => {\n        const packed = codec.pack(u);\n        assertBufferLength(packed, byteLength);\n        return packed;\n      },\n      unpack: (buf) => {\n        assertBufferLength(buf, byteLength);\n        return codec.unpack(buf);\n      },\n    }),\n  };\n}\n"],"mappings":";;;;;;;;;AACA;;AACA;;AAFA;;AAkEA;AACA;AACA;AACA;AACO,SAASA,gBAAT,CACLC,KADK,EAE2B;EAChC,OAAO;IACLC,IAAI,EAAGC,QAAD,IAAcF,KAAK,CAACC,IAAN,CAAWC,QAAX,CADf;IAELC,MAAM,EAAGC,SAAD,IAAeJ,KAAK,CAACG,MAAN,CAAa,IAAAE,aAAA,EAAOD,SAAP,CAAb;EAFlB,CAAP;AAID;;AAaM,SAASE,YAAT,CACLN,KADK,EAEwB;EAC7B,OAAO,IAAAO,mBAAA,EAAaP,KAAb,KAAuB,CAAC,CAACA,KAAK,CAACQ,gBAAtC;AACD;;AAEM,SAASC,qBAAT,CACLT,KADK,EAEgC;EACrC,MAAMU,UAAU,GAAGV,KAAK,CAACU,UAAzB;EACA,OAAO;IACLF,gBAAgB,EAAE,IADb;IAELE,UAFK;IAGL,GAAGX,gBAAgB,CAAC;MAClBE,IAAI,EAAGU,CAAD,IAAO;QACX,MAAMC,MAAM,GAAGZ,KAAK,CAACC,IAAN,CAAWU,CAAX,CAAf;QACA,IAAAE,yBAAA,EAAmBD,MAAnB,EAA2BF,UAA3B;QACA,OAAOE,MAAP;MACD,CALiB;MAMlBT,MAAM,EAAGW,GAAD,IAAS;QACf,IAAAD,yBAAA,EAAmBC,GAAnB,EAAwBJ,UAAxB;QACA,OAAOV,KAAK,CAACG,MAAN,CAAaW,GAAb,CAAP;MACD;IATiB,CAAD;EAHd,CAAP;AAeD"}