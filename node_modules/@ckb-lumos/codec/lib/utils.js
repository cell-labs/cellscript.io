"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertBufferLength = assertBufferLength;
exports.assertHexDecimal = assertHexDecimal;
exports.assertHexString = assertHexString;
exports.assertMinBufferLength = assertMinBufferLength;
exports.assertUtf8String = assertUtf8String;
exports.isObjectLike = isObjectLike;
exports.trackCodeExecuteError = trackCodeExecuteError;

var _error = require("./error");

const HEX_DECIMAL_REGEX = /^0x([0-9a-fA-F])+$/;
const HEX_DECIMAL_WITH_BYTELENGTH_REGEX_MAP = new Map();

function assertHexDecimal(str, byteLength) {
  if (byteLength) {
    let regex = HEX_DECIMAL_WITH_BYTELENGTH_REGEX_MAP.get(byteLength);

    if (!regex) {
      const newRegex = RegExp(String.raw`^0x([0-9a-fA-F]){1,${byteLength * 2}}$`);
      HEX_DECIMAL_WITH_BYTELENGTH_REGEX_MAP.set(byteLength, newRegex);
      regex = newRegex;
    }

    if (!regex.test(str)) {
      throw new Error("Invalid hex decimal!");
    }
  } else {
    if (!HEX_DECIMAL_REGEX.test(str)) {
      throw new Error("Invalid hex decimal!");
    }
  }
}

const HEX_STRING_REGEX = /^0x([0-9a-fA-F][0-9a-fA-F])*$/;
const HEX_STRING_WITH_BYTELENGTH_REGEX_MAP = new Map();

function assertHexString(str, byteLength) {
  if (byteLength) {
    let regex = HEX_STRING_WITH_BYTELENGTH_REGEX_MAP.get(byteLength);

    if (!regex) {
      const newRegex = RegExp(String.raw`^0x([0-9a-fA-F][0-9a-fA-F]){${byteLength}}$`);
      HEX_STRING_WITH_BYTELENGTH_REGEX_MAP.set(byteLength, newRegex);
      regex = newRegex;
    }

    if (!regex.test(str)) {
      throw new Error("Invalid hex string!");
    }
  } else {
    if (!HEX_STRING_REGEX.test(str)) {
      throw new Error("Invalid hex string!");
    }
  }
}

function assertUtf8String(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);

    if (c > 0xff) {
      throw new Error("Invalid UTF-8 raw string!");
    }
  }
}

function assertBufferLength(buf, length) {
  if (buf.byteLength !== length) {
    throw new Error(`Invalid buffer length: ${buf.byteLength}, should be ${length}`);
  }
}

function assertMinBufferLength(buf, length) {
  if (buf.byteLength < length) {
    throw new Error(`Invalid buffer length: ${buf.byteLength}, should be at least ${length}`);
  }
}

function isObjectLike(x) {
  if (!x) return false;
  return typeof x === "object";
}

function trackCodeExecuteError(path, fn) {
  try {
    return fn();
  } catch (e) {
    const readableError = (0, _error.isCodecExecuteError)(e) ? e : new _error.CodecExecuteError(e);
    readableError.updateKey(path);
    throw readableError;
  }
}
//# sourceMappingURL=utils.js.map