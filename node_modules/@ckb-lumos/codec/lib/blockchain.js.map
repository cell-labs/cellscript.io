{"version":3,"file":"blockchain.js","names":["createFixedHexBytesCodec","byteLength","createFixedBytesCodec","pack","hex","bytify","unpack","buf","hexify","Bytes","byteVecOf","BytesOpt","option","BytesVec","vector","Byte32","Byte32Vec","WitnessArgsOf","payload","table","lock","input_type","output_type","HexifyCodec","createBytesCodec","WitnessArgs"],"sources":["../src/blockchain.ts"],"sourcesContent":["import {\n  AnyCodec,\n  BytesCodec,\n  BytesLike,\n  createBytesCodec,\n  createFixedBytesCodec,\n  FixedBytesCodec,\n  PackParam,\n  UnpackResult,\n} from \"./base\";\nimport { bytify, hexify } from \"./bytes\";\nimport { byteVecOf, option, table, vector } from \"./molecule\";\n\nexport function createFixedHexBytesCodec(\n  byteLength: number\n): FixedBytesCodec<string, BytesLike> {\n  return createFixedBytesCodec({\n    byteLength,\n    pack: (hex) => bytify(hex),\n    unpack: (buf) => hexify(buf),\n  });\n}\n\n/**\n * placeholder codec, generally used as a placeholder\n * ```\n * // for example, when some BytesOpt is not used, it will be filled with this codec\n * // option BytesOpt (Bytes);\n * const UnusedBytesOpt = UnknownOpt\n * ```\n */\n// export const UnusedOpt = option(Unknown);\n\n// vector Bytes <byte>\nexport const Bytes = byteVecOf({ pack: bytify, unpack: hexify });\n\nexport const BytesOpt = option(Bytes);\nexport const BytesVec = vector(Bytes);\nexport const Byte32 = createFixedHexBytesCodec(32);\nexport const Byte32Vec = vector(Byte32);\n\nexport function WitnessArgsOf<\n  LockCodec extends AnyCodec,\n  InputTypeCodec extends AnyCodec,\n  OutputTypeCodec extends AnyCodec\n>(payload: {\n  lock: LockCodec;\n  input_type: InputTypeCodec;\n  output_type: OutputTypeCodec;\n}): BytesCodec<\n  {\n    lock?: UnpackResult<LockCodec>;\n    input_type?: UnpackResult<InputTypeCodec>;\n    output_type?: UnpackResult<OutputTypeCodec>;\n  },\n  {\n    lock?: PackParam<LockCodec>;\n    input_type?: PackParam<InputTypeCodec>;\n    output_type?: PackParam<OutputTypeCodec>;\n  }\n> {\n  return table(\n    {\n      lock: option(byteVecOf(payload.lock)),\n      input_type: option(byteVecOf(payload.input_type)),\n      output_type: option(byteVecOf(payload.output_type)),\n    },\n    [\"lock\", \"input_type\", \"output_type\"]\n  );\n}\n\nconst HexifyCodec = createBytesCodec<string, BytesLike>({\n  pack: bytify,\n  unpack: hexify,\n});\n\n/**\n *\n * @example\n * ```ts\n * // secp256k1 lock witness\n * WitnessArgs.pack({ lock: '0x' + '00'.repeat(65) })\n * ```\n */\nexport const WitnessArgs = WitnessArgsOf({\n  lock: HexifyCodec,\n  input_type: HexifyCodec,\n  output_type: HexifyCodec,\n});\n"],"mappings":";;;;;;;;;AAAA;;AAUA;;AACA;;AAEO,SAASA,wBAAT,CACLC,UADK,EAE+B;EACpC,OAAO,IAAAC,2BAAA,EAAsB;IAC3BD,UAD2B;IAE3BE,IAAI,EAAGC,GAAD,IAAS,IAAAC,aAAA,EAAOD,GAAP,CAFY;IAG3BE,MAAM,EAAGC,GAAD,IAAS,IAAAC,aAAA,EAAOD,GAAP;EAHU,CAAtB,CAAP;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACO,MAAME,KAAK,GAAG,IAAAC,mBAAA,EAAU;EAAEP,IAAI,EAAEE,aAAR;EAAgBC,MAAM,EAAEE;AAAxB,CAAV,CAAd;;AAEA,MAAMG,QAAQ,GAAG,IAAAC,gBAAA,EAAOH,KAAP,CAAjB;;AACA,MAAMI,QAAQ,GAAG,IAAAC,gBAAA,EAAOL,KAAP,CAAjB;;AACA,MAAMM,MAAM,GAAGf,wBAAwB,CAAC,EAAD,CAAvC;;AACA,MAAMgB,SAAS,GAAG,IAAAF,gBAAA,EAAOC,MAAP,CAAlB;;;AAEA,SAASE,aAAT,CAILC,OAJK,EAmBL;EACA,OAAO,IAAAC,eAAA,EACL;IACEC,IAAI,EAAE,IAAAR,gBAAA,EAAO,IAAAF,mBAAA,EAAUQ,OAAO,CAACE,IAAlB,CAAP,CADR;IAEEC,UAAU,EAAE,IAAAT,gBAAA,EAAO,IAAAF,mBAAA,EAAUQ,OAAO,CAACG,UAAlB,CAAP,CAFd;IAGEC,WAAW,EAAE,IAAAV,gBAAA,EAAO,IAAAF,mBAAA,EAAUQ,OAAO,CAACI,WAAlB,CAAP;EAHf,CADK,EAML,CAAC,MAAD,EAAS,YAAT,EAAuB,aAAvB,CANK,CAAP;AAQD;;AAED,MAAMC,WAAW,GAAG,IAAAC,sBAAA,EAAoC;EACtDrB,IAAI,EAAEE,aADgD;EAEtDC,MAAM,EAAEE;AAF8C,CAApC,CAApB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,MAAMiB,WAAW,GAAGR,aAAa,CAAC;EACvCG,IAAI,EAAEG,WADiC;EAEvCF,UAAU,EAAEE,WAF2B;EAGvCD,WAAW,EAAEC;AAH0B,CAAD,CAAjC"}