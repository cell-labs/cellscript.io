{"version":3,"file":"transaction_collector.js","names":["CKBIndexerTransactionCollector","BaseIndexerModule","TransactionCollector","constructor","indexer","queries","CKBRpcUrl","options","defaultOptions","skipMissing","includeStatus","filterOptions","asBaseTransactionCollector","fetchIndexerTransaction","lastCursor","searchKeyFilter","sizeLimit","bufferSize","order","indexerTransactionList","objects","services","instanceOfScriptWrapper","lock","type","getTransactionByLockAndTypeIndependent","getTransactions","generateSearchKey","filterByTypeIoTypeAndLockIoType","getResolvedTransactionRequestPayload","unresolvedTransactionList","requestPayload","resolvedTransactionRequestId","forEach","unresolvedTransaction","index","indexerTransaction","ioType","unresolvedOutPoint","transaction","inputs","Number","ioIndex","previousOutput","push","id","jsonrpc","method","params","txHash","fetchResolvedTransaction","txIoTypeInputOutPointList","resolvedTransaction","length","requestBatch","getResolvedCell","resolvedTransactionList","outputs","find","tx","result","hash","Error","resolvedCell","filterTransaction","filteredTransactionList","filter","isCellScriptArgsValid","map","txStatus","getTransactionListFromRpc","queryWithTypeAdditionOptions","queryWithLockAdditionOptions","lockLastCursor","typeLastCursor","split","queriesWithoutType","undefined","transactionByLock","queriesWithoutLock","transactionByType","intersection","transactionList1","transactionList2","tx1","tx2","item","targetTx","hashList","getDetailRequestData","hashItem","transactionList","then","response","isLockArgsLenMatched","args","argsLen","getHexStringBytes","targetCell","lockArgsLen","typeArgsLen","filterByIoType","inputResult","count","getTxWithCursor","counter","txs","buffer","skippedCount","skip","getTransactionHashes","transactionHashes","collect"],"sources":["../src/transaction_collector.ts"],"sourcesContent":["import {\n  TransactionCollectorOptions,\n  indexer as BaseIndexerModule,\n  Output,\n  OutPoint,\n  TransactionWithStatus,\n  TransactionCollector as BaseTransactionCollector,\n  QueryOptions,\n  Transaction,\n} from \"@ckb-lumos/base\";\nimport {\n  SearchKeyFilter,\n  CKBIndexerQueryOptions,\n  IndexerTransaction,\n  IndexerTransactionList,\n  IOType,\n  Order,\n  GetTransactionRPCResult,\n  JsonRprRequestBody,\n} from \"./type\";\nimport { CkbIndexer } from \"./indexer\";\nimport * as services from \"./services\";\n\ninterface GetTransactionDetailResult {\n  objects: TransactionWithStatus[];\n  lastCursor: string | undefined;\n}\n\nexport class CKBIndexerTransactionCollector extends BaseIndexerModule.TransactionCollector {\n  filterOptions: TransactionCollectorOptions;\n  constructor(\n    public indexer: CkbIndexer,\n    public queries: CKBIndexerQueryOptions,\n    public CKBRpcUrl: string,\n    public options?: TransactionCollectorOptions\n  ) {\n    super(indexer, queries, options);\n    const defaultOptions: TransactionCollectorOptions = {\n      skipMissing: false,\n      includeStatus: true,\n    };\n    this.filterOptions = { ...defaultOptions, ...this.options };\n  }\n\n  public static asBaseTransactionCollector(\n    CKBRpcUrl: string\n  ): typeof BaseTransactionCollector {\n    return class extends BaseIndexerModule.TransactionCollector {\n      constructor(\n        indexer: CkbIndexer,\n        queries: QueryOptions,\n        options?: TransactionCollectorOptions\n      ) {\n        super(indexer, queries, options);\n        return new CKBIndexerTransactionCollector(\n          indexer,\n          queries,\n          CKBRpcUrl,\n          options\n        );\n      }\n    };\n  }\n  public async fetchIndexerTransaction(\n    queries: CKBIndexerQueryOptions,\n    lastCursor?: string\n  ): Promise<IndexerTransactionList> {\n    const searchKeyFilter: SearchKeyFilter = {\n      sizeLimit: queries.bufferSize,\n      order: queries.order as Order,\n    };\n    if (lastCursor) {\n      searchKeyFilter.lastCursor = lastCursor;\n    }\n    let indexerTransactionList: IndexerTransactionList = {\n      objects: [],\n      lastCursor: \"\",\n    };\n    /*\n     * if both lock and type exist,we need search them in independent and then get intersection\n     * cause ckb-indexer use searchKey script on each cell but native indexer use lock and type on transaction,\n     * and one transaction may have many cells both in input and output, more detail in test 'Test query transaction by both input lock and output type script'\n     */\n\n    //if both lock and type, search search them in independent and then get intersection, GetTransactionsResults.lastCursor change to `${lockLastCursor}-${typeLastCursor}`\n    if (\n      services.instanceOfScriptWrapper(queries.lock) &&\n      services.instanceOfScriptWrapper(queries.type)\n    ) {\n      indexerTransactionList =\n        await this.getTransactionByLockAndTypeIndependent(searchKeyFilter);\n      lastCursor = indexerTransactionList.lastCursor;\n    } else {\n      //query by ScriptWrapper.script,block_range,order\n      indexerTransactionList = await this.indexer.getTransactions(\n        services.generateSearchKey(queries),\n        searchKeyFilter\n      );\n      lastCursor = indexerTransactionList.lastCursor;\n    }\n    // filter by ScriptWrapper.io_type\n    indexerTransactionList.objects = this.filterByTypeIoTypeAndLockIoType(\n      indexerTransactionList.objects,\n      queries\n    );\n    return indexerTransactionList;\n  }\n\n  public getResolvedTransactionRequestPayload(\n    unresolvedTransactionList: TransactionWithStatus[],\n    indexerTransactionList: IndexerTransactionList\n  ): JsonRprRequestBody[] {\n    const requestPayload: JsonRprRequestBody[] = [];\n    let resolvedTransactionRequestId = 0;\n    unresolvedTransactionList.forEach(\n      (unresolvedTransaction: TransactionWithStatus, index: number) => {\n        const indexerTransaction = indexerTransactionList.objects[index];\n        if (indexerTransaction.ioType === \"input\") {\n          const unresolvedOutPoint: OutPoint =\n            unresolvedTransaction.transaction.inputs[\n              Number(indexerTransaction.ioIndex)\n            ].previousOutput;\n          requestPayload.push({\n            id: resolvedTransactionRequestId++,\n            jsonrpc: \"2.0\",\n            method: \"get_transaction\",\n            params: [unresolvedOutPoint.txHash],\n          });\n        }\n      }\n    );\n    return requestPayload;\n  }\n\n  public async fetchResolvedTransaction(\n    txIoTypeInputOutPointList: JsonRprRequestBody[]\n  ): Promise<GetTransactionRPCResult[]> {\n    let resolvedTransaction: GetTransactionRPCResult[] = [];\n    if (txIoTypeInputOutPointList.length <= 0) {\n      return resolvedTransaction;\n    }\n    resolvedTransaction = await services.requestBatch(\n      this.CKBRpcUrl,\n      txIoTypeInputOutPointList\n    );\n    return resolvedTransaction;\n  }\n\n  public getResolvedCell(\n    unresolvedTransaction: TransactionWithStatus,\n    resolvedTransactionList: GetTransactionRPCResult[],\n    indexerTransaction: IndexerTransaction\n  ): Output {\n    if (indexerTransaction.ioType !== \"input\") {\n      return unresolvedTransaction.transaction.outputs[\n        Number(indexerTransaction.ioIndex)\n      ];\n    } else {\n      const unresolvedOutPoint =\n        unresolvedTransaction.transaction.inputs[\n          Number(indexerTransaction.ioIndex)\n        ].previousOutput;\n      const resolvedTransaction = resolvedTransactionList.find((tx) => {\n        return tx.result.transaction.hash === unresolvedOutPoint.txHash;\n      });\n      if (!resolvedTransaction) {\n        throw new Error(`Impossible: can NOT find resolved transaction!`);\n      }\n      const resolvedCell =\n        resolvedTransaction.result.transaction.outputs[\n          Number(unresolvedOutPoint.index)\n        ];\n      return resolvedCell;\n    }\n  }\n\n  //filter by ScriptWrapper.argsLen\n  public filterTransaction(\n    unresolvedTransactionList: TransactionWithStatus[],\n    resolvedTransactionList: GetTransactionRPCResult[],\n    indexerTransactionList: IndexerTransactionList\n  ): TransactionWithStatus[] {\n    const filteredTransactionList = unresolvedTransactionList.filter(\n      (unresolvedTransaction: TransactionWithStatus, index: number) => {\n        const resolvedCell: Output = this.getResolvedCell(\n          unresolvedTransaction,\n          resolvedTransactionList,\n          indexerTransactionList.objects[index]\n        );\n        return this.isCellScriptArgsValid(resolvedCell);\n      }\n    );\n    const objects = filteredTransactionList.map((tx) => ({\n      transaction: tx.transaction,\n      txStatus: tx.txStatus,\n    }));\n    return objects;\n  }\n\n  /*\n   *lock?: ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *type?:  ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *data?: will not filter\n   *argsLen?: filter after get transaction detail;\n   *fromBlock?: query by ckb-indexer;\n   *toBlock?: query by ckb-indexer;\n   *skip?: filter after get transaction from ckb-indexer;;\n   *order?: query by ckb-indexer;\n   */\n  public async getTransactions(\n    lastCursor?: string\n  ): Promise<GetTransactionDetailResult> {\n    const indexerTransactionList: IndexerTransactionList =\n      await this.fetchIndexerTransaction(this.queries, lastCursor);\n    lastCursor = indexerTransactionList.lastCursor;\n\n    // return if transaction hash list if empty\n    if (indexerTransactionList.objects.length === 0) {\n      return {\n        objects: [],\n        lastCursor: lastCursor,\n      };\n    }\n    const unresolvedTransactionList: TransactionWithStatus[] =\n      await this.getTransactionListFromRpc(indexerTransactionList);\n    const requestPayload = this.getResolvedTransactionRequestPayload(\n      unresolvedTransactionList,\n      indexerTransactionList\n    );\n    const resolvedTransactionList = await this.fetchResolvedTransaction(\n      requestPayload\n    );\n    const objects = this.filterTransaction(\n      unresolvedTransactionList,\n      resolvedTransactionList,\n      indexerTransactionList\n    );\n    return {\n      objects: objects,\n      lastCursor: lastCursor,\n    };\n  }\n\n  private async getTransactionByLockAndTypeIndependent(\n    searchKeyFilter: SearchKeyFilter\n  ): Promise<IndexerTransactionList> {\n    const queryWithTypeAdditionOptions = { ...searchKeyFilter };\n    const queryWithLockAdditionOptions = { ...searchKeyFilter };\n    if (searchKeyFilter.lastCursor) {\n      const [lockLastCursor, typeLastCursor] =\n        searchKeyFilter.lastCursor.split(\"-\");\n      queryWithLockAdditionOptions.lastCursor = lockLastCursor;\n      queryWithTypeAdditionOptions.lastCursor = typeLastCursor;\n    }\n    const queriesWithoutType = { ...this.queries, type: undefined };\n    const transactionByLock = await this.indexer.getTransactions(\n      services.generateSearchKey(queriesWithoutType),\n      queryWithTypeAdditionOptions\n    );\n    const queriesWithoutLock = { ...this.queries, lock: undefined };\n    const transactionByType = await this.indexer.getTransactions(\n      services.generateSearchKey(queriesWithoutLock),\n      queryWithLockAdditionOptions\n    );\n\n    const intersection = (\n      transactionList1: IndexerTransaction[],\n      transactionList2: IndexerTransaction[]\n    ) => {\n      const result: IndexerTransaction[] = [];\n      transactionList1.forEach((tx1) => {\n        const tx2 = transactionList2.find((item) => item.txHash === tx1.txHash);\n        if (tx2) {\n          // put the output io_type to intersection result, cause output have cells\n          const targetTx = tx1.ioType === \"output\" ? tx1 : tx2;\n          // change io_type to both cause targetTx exist both input and output\n          result.push({ ...targetTx, ioType: \"both\" });\n        }\n      });\n      return result;\n    };\n    const hashList = intersection(\n      transactionByType.objects,\n      transactionByLock.objects\n    );\n    const lastCursor =\n      transactionByLock.lastCursor + \"-\" + transactionByType.lastCursor;\n    const objects = hashList;\n    return { objects, lastCursor };\n  }\n\n  private getTransactionListFromRpc = async (\n    indexerTransactionList: IndexerTransactionList\n  ) => {\n    const getDetailRequestData = indexerTransactionList.objects.map(\n      (hashItem: IndexerTransaction, index: number) => {\n        return {\n          id: index,\n          jsonrpc: \"2.0\",\n          method: \"get_transaction\",\n          params: [hashItem.txHash],\n        };\n      }\n    );\n    const transactionList: TransactionWithStatus[] = await services\n      .requestBatch(this.CKBRpcUrl, getDetailRequestData)\n      .then((response: GetTransactionRPCResult[]) => {\n        return response.map(\n          (item: GetTransactionRPCResult): TransactionWithStatus => {\n            if (!this.filterOptions.skipMissing && !item.result) {\n              throw new Error(\n                `Transaction ${\n                  indexerTransactionList.objects[item.id].txHash\n                } is missing!`\n              );\n            }\n            return { ...item.result };\n          }\n        );\n      });\n    return transactionList;\n  };\n\n  private isLockArgsLenMatched = (\n    args: string | undefined,\n    argsLen?: number | \"any\"\n  ) => {\n    if (!argsLen) return true;\n    if (argsLen === \"any\") return true;\n    if (argsLen === -1) return true;\n    return services.getHexStringBytes(args as string) === argsLen;\n  };\n\n  // only valid after pass flow three validate\n  private isCellScriptArgsValid = (targetCell: Output) => {\n    if (this.queries.lock) {\n      const lockArgsLen = services.instanceOfScriptWrapper(this.queries.lock)\n        ? this.queries.lock.argsLen\n        : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.lock.args, lockArgsLen)) {\n        return false;\n      }\n    }\n\n    if (this.queries.type && this.queries.type !== \"empty\") {\n      const typeArgsLen = services.instanceOfScriptWrapper(this.queries.type)\n        ? this.queries.type.argsLen\n        : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.type?.args, typeArgsLen)) {\n        return false;\n      }\n    }\n\n    if (this.queries.type && this.queries.type === \"empty\") {\n      if (targetCell.type) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  private filterByIoType = (\n    inputResult: IndexerTransaction[],\n    ioType: IOType\n  ) => {\n    if (ioType === \"both\") {\n      return inputResult;\n    }\n    if (ioType === \"input\" || ioType === \"output\") {\n      return inputResult.filter(\n        (item: IndexerTransaction) =>\n          item.ioType === ioType || item.ioType === \"both\"\n      );\n    }\n    return inputResult;\n  };\n\n  private filterByTypeIoTypeAndLockIoType = (\n    inputResult: IndexerTransaction[],\n    queries: CKBIndexerQueryOptions\n  ) => {\n    let result = inputResult;\n    if (services.instanceOfScriptWrapper(queries.lock) && queries.lock.ioType) {\n      result = this.filterByIoType(result, queries.lock.ioType);\n    }\n    if (services.instanceOfScriptWrapper(queries.type) && queries.type.ioType) {\n      result = this.filterByIoType(result, queries.type.ioType);\n    }\n    return result;\n  };\n\n  async count(): Promise<number> {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    let counter = 0;\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return 0;\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        counter += 1;\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return counter;\n  }\n  async getTransactionHashes(): Promise<string[]> {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n\n    const transactionHashes: string[] = [];\n    //skip query result in first query\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return [];\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (txs[index].transaction.hash) {\n          transactionHashes.push(txs[index].transaction.hash as string);\n        }\n      }\n\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return transactionHashes;\n  }\n  async *collect(): AsyncGenerator<\n    TransactionWithStatus | Transaction,\n    undefined,\n    unknown\n  > {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    //skip query result in first query\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return undefined;\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (this.filterOptions.includeStatus) {\n          yield txs[index];\n        } else {\n          yield txs[index].transaction;\n        }\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n  }\n}\n"],"mappings":"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"}