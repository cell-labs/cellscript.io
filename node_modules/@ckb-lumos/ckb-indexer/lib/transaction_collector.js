"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CKBIndexerTransactionCollector = void 0;

var _base = require("@ckb-lumos/base");

var services = _interopRequireWildcard(require("./services"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class CKBIndexerTransactionCollector extends _base.indexer.TransactionCollector {
  constructor(indexer, queries, CKBRpcUrl, options) {
    super(indexer, queries, options);
    this.indexer = indexer;
    this.queries = queries;
    this.CKBRpcUrl = CKBRpcUrl;
    this.options = options;
    const defaultOptions = {
      skipMissing: false,
      includeStatus: true
    };
    this.filterOptions = { ...defaultOptions,
      ...this.options
    };
  }

  static asBaseTransactionCollector(CKBRpcUrl) {
    return class extends _base.indexer.TransactionCollector {
      constructor(indexer, queries, options) {
        super(indexer, queries, options);
        return new CKBIndexerTransactionCollector(indexer, queries, CKBRpcUrl, options);
      }

    };
  }

  async fetchIndexerTransaction(queries, lastCursor) {
    const searchKeyFilter = {
      sizeLimit: queries.bufferSize,
      order: queries.order
    };

    if (lastCursor) {
      searchKeyFilter.lastCursor = lastCursor;
    }

    let indexerTransactionList = {
      objects: [],
      lastCursor: ""
    };
    /*
     * if both lock and type exist,we need search them in independent and then get intersection
     * cause ckb-indexer use searchKey script on each cell but native indexer use lock and type on transaction,
     * and one transaction may have many cells both in input and output, more detail in test 'Test query transaction by both input lock and output type script'
     */
    //if both lock and type, search search them in independent and then get intersection, GetTransactionsResults.lastCursor change to `${lockLastCursor}-${typeLastCursor}`

    if (services.instanceOfScriptWrapper(queries.lock) && services.instanceOfScriptWrapper(queries.type)) {
      indexerTransactionList = await this.getTransactionByLockAndTypeIndependent(searchKeyFilter);
      lastCursor = indexerTransactionList.lastCursor;
    } else {
      //query by ScriptWrapper.script,block_range,order
      indexerTransactionList = await this.indexer.getTransactions(services.generateSearchKey(queries), searchKeyFilter);
      lastCursor = indexerTransactionList.lastCursor;
    } // filter by ScriptWrapper.io_type


    indexerTransactionList.objects = this.filterByTypeIoTypeAndLockIoType(indexerTransactionList.objects, queries);
    return indexerTransactionList;
  }

  getResolvedTransactionRequestPayload(unresolvedTransactionList, indexerTransactionList) {
    const requestPayload = [];
    let resolvedTransactionRequestId = 0;
    unresolvedTransactionList.forEach((unresolvedTransaction, index) => {
      const indexerTransaction = indexerTransactionList.objects[index];

      if (indexerTransaction.ioType === "input") {
        const unresolvedOutPoint = unresolvedTransaction.transaction.inputs[Number(indexerTransaction.ioIndex)].previousOutput;
        requestPayload.push({
          id: resolvedTransactionRequestId++,
          jsonrpc: "2.0",
          method: "get_transaction",
          params: [unresolvedOutPoint.txHash]
        });
      }
    });
    return requestPayload;
  }

  async fetchResolvedTransaction(txIoTypeInputOutPointList) {
    let resolvedTransaction = [];

    if (txIoTypeInputOutPointList.length <= 0) {
      return resolvedTransaction;
    }

    resolvedTransaction = await services.requestBatch(this.CKBRpcUrl, txIoTypeInputOutPointList);
    return resolvedTransaction;
  }

  getResolvedCell(unresolvedTransaction, resolvedTransactionList, indexerTransaction) {
    if (indexerTransaction.ioType !== "input") {
      return unresolvedTransaction.transaction.outputs[Number(indexerTransaction.ioIndex)];
    } else {
      const unresolvedOutPoint = unresolvedTransaction.transaction.inputs[Number(indexerTransaction.ioIndex)].previousOutput;
      const resolvedTransaction = resolvedTransactionList.find(tx => {
        return tx.result.transaction.hash === unresolvedOutPoint.txHash;
      });

      if (!resolvedTransaction) {
        throw new Error(`Impossible: can NOT find resolved transaction!`);
      }

      const resolvedCell = resolvedTransaction.result.transaction.outputs[Number(unresolvedOutPoint.index)];
      return resolvedCell;
    }
  } //filter by ScriptWrapper.argsLen


  filterTransaction(unresolvedTransactionList, resolvedTransactionList, indexerTransactionList) {
    const filteredTransactionList = unresolvedTransactionList.filter((unresolvedTransaction, index) => {
      const resolvedCell = this.getResolvedCell(unresolvedTransaction, resolvedTransactionList, indexerTransactionList.objects[index]);
      return this.isCellScriptArgsValid(resolvedCell);
    });
    const objects = filteredTransactionList.map(tx => ({
      transaction: tx.transaction,
      txStatus: tx.txStatus
    }));
    return objects;
  }
  /*
   *lock?: ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;
   *type?:  ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;
   *data?: will not filter
   *argsLen?: filter after get transaction detail;
   *fromBlock?: query by ckb-indexer;
   *toBlock?: query by ckb-indexer;
   *skip?: filter after get transaction from ckb-indexer;;
   *order?: query by ckb-indexer;
   */


  async getTransactions(lastCursor) {
    const indexerTransactionList = await this.fetchIndexerTransaction(this.queries, lastCursor);
    lastCursor = indexerTransactionList.lastCursor; // return if transaction hash list if empty

    if (indexerTransactionList.objects.length === 0) {
      return {
        objects: [],
        lastCursor: lastCursor
      };
    }

    const unresolvedTransactionList = await this.getTransactionListFromRpc(indexerTransactionList);
    const requestPayload = this.getResolvedTransactionRequestPayload(unresolvedTransactionList, indexerTransactionList);
    const resolvedTransactionList = await this.fetchResolvedTransaction(requestPayload);
    const objects = this.filterTransaction(unresolvedTransactionList, resolvedTransactionList, indexerTransactionList);
    return {
      objects: objects,
      lastCursor: lastCursor
    };
  }

  async getTransactionByLockAndTypeIndependent(searchKeyFilter) {
    const queryWithTypeAdditionOptions = { ...searchKeyFilter
    };
    const queryWithLockAdditionOptions = { ...searchKeyFilter
    };

    if (searchKeyFilter.lastCursor) {
      const [lockLastCursor, typeLastCursor] = searchKeyFilter.lastCursor.split("-");
      queryWithLockAdditionOptions.lastCursor = lockLastCursor;
      queryWithTypeAdditionOptions.lastCursor = typeLastCursor;
    }

    const queriesWithoutType = { ...this.queries,
      type: undefined
    };
    const transactionByLock = await this.indexer.getTransactions(services.generateSearchKey(queriesWithoutType), queryWithTypeAdditionOptions);
    const queriesWithoutLock = { ...this.queries,
      lock: undefined
    };
    const transactionByType = await this.indexer.getTransactions(services.generateSearchKey(queriesWithoutLock), queryWithLockAdditionOptions);

    const intersection = (transactionList1, transactionList2) => {
      const result = [];
      transactionList1.forEach(tx1 => {
        const tx2 = transactionList2.find(item => item.txHash === tx1.txHash);

        if (tx2) {
          // put the output io_type to intersection result, cause output have cells
          const targetTx = tx1.ioType === "output" ? tx1 : tx2; // change io_type to both cause targetTx exist both input and output

          result.push({ ...targetTx,
            ioType: "both"
          });
        }
      });
      return result;
    };

    const hashList = intersection(transactionByType.objects, transactionByLock.objects);
    const lastCursor = transactionByLock.lastCursor + "-" + transactionByType.lastCursor;
    const objects = hashList;
    return {
      objects,
      lastCursor
    };
  }

  getTransactionListFromRpc = async indexerTransactionList => {
    const getDetailRequestData = indexerTransactionList.objects.map((hashItem, index) => {
      return {
        id: index,
        jsonrpc: "2.0",
        method: "get_transaction",
        params: [hashItem.txHash]
      };
    });
    const transactionList = await services.requestBatch(this.CKBRpcUrl, getDetailRequestData).then(response => {
      return response.map(item => {
        if (!this.filterOptions.skipMissing && !item.result) {
          throw new Error(`Transaction ${indexerTransactionList.objects[item.id].txHash} is missing!`);
        }

        return { ...item.result
        };
      });
    });
    return transactionList;
  };
  isLockArgsLenMatched = (args, argsLen) => {
    if (!argsLen) return true;
    if (argsLen === "any") return true;
    if (argsLen === -1) return true;
    return services.getHexStringBytes(args) === argsLen;
  }; // only valid after pass flow three validate

  isCellScriptArgsValid = targetCell => {
    if (this.queries.lock) {
      const lockArgsLen = services.instanceOfScriptWrapper(this.queries.lock) ? this.queries.lock.argsLen : this.queries.argsLen;

      if (!this.isLockArgsLenMatched(targetCell.lock.args, lockArgsLen)) {
        return false;
      }
    }

    if (this.queries.type && this.queries.type !== "empty") {
      var _targetCell$type;

      const typeArgsLen = services.instanceOfScriptWrapper(this.queries.type) ? this.queries.type.argsLen : this.queries.argsLen;

      if (!this.isLockArgsLenMatched((_targetCell$type = targetCell.type) === null || _targetCell$type === void 0 ? void 0 : _targetCell$type.args, typeArgsLen)) {
        return false;
      }
    }

    if (this.queries.type && this.queries.type === "empty") {
      if (targetCell.type) {
        return false;
      }
    }

    return true;
  };
  filterByIoType = (inputResult, ioType) => {
    if (ioType === "both") {
      return inputResult;
    }

    if (ioType === "input" || ioType === "output") {
      return inputResult.filter(item => item.ioType === ioType || item.ioType === "both");
    }

    return inputResult;
  };
  filterByTypeIoTypeAndLockIoType = (inputResult, queries) => {
    let result = inputResult;

    if (services.instanceOfScriptWrapper(queries.lock) && queries.lock.ioType) {
      result = this.filterByIoType(result, queries.lock.ioType);
    }

    if (services.instanceOfScriptWrapper(queries.type) && queries.type.ioType) {
      result = this.filterByIoType(result, queries.type.ioType);
    }

    return result;
  };

  async count() {
    let lastCursor = undefined;

    const getTxWithCursor = async () => {
      const result = await this.getTransactions(lastCursor);
      lastCursor = result.lastCursor;
      return result.objects;
    };

    let counter = 0;
    let txs = await getTxWithCursor();

    if (txs.length === 0) {
      return 0;
    }

    let buffer = getTxWithCursor();
    let index = 0;
    let skippedCount = 0;

    while (true) {
      if (this.queries.skip && skippedCount < this.queries.skip) {
        skippedCount++;
      } else {
        counter += 1;
      }

      index++; //reset index and exchange `txs` and `buffer` after count last tx

      if (index === txs.length) {
        index = 0;
        txs = await buffer; // break if can not get more txs

        if (txs.length === 0) {
          break;
        }

        buffer = getTxWithCursor();
      }
    }

    return counter;
  }

  async getTransactionHashes() {
    let lastCursor = undefined;

    const getTxWithCursor = async () => {
      const result = await this.getTransactions(lastCursor);
      lastCursor = result.lastCursor;
      return result.objects;
    };

    const transactionHashes = []; //skip query result in first query

    let txs = await getTxWithCursor();

    if (txs.length === 0) {
      return [];
    }

    let buffer = getTxWithCursor();
    let index = 0;
    let skippedCount = 0;

    while (true) {
      if (this.queries.skip && skippedCount < this.queries.skip) {
        skippedCount++;
      } else {
        if (txs[index].transaction.hash) {
          transactionHashes.push(txs[index].transaction.hash);
        }
      }

      index++; //reset index and exchange `txs` and `buffer` after count last tx

      if (index === txs.length) {
        index = 0;
        txs = await buffer; // break if can not get more txs

        if (txs.length === 0) {
          break;
        }

        buffer = getTxWithCursor();
      }
    }

    return transactionHashes;
  }

  async *collect() {
    let lastCursor = undefined;

    const getTxWithCursor = async () => {
      const result = await this.getTransactions(lastCursor);
      lastCursor = result.lastCursor;
      return result.objects;
    }; //skip query result in first query


    let txs = await getTxWithCursor();

    if (txs.length === 0) {
      return undefined;
    }

    let buffer = getTxWithCursor();
    let index = 0;
    let skippedCount = 0;

    while (true) {
      if (this.queries.skip && skippedCount < this.queries.skip) {
        skippedCount++;
      } else {
        if (this.filterOptions.includeStatus) {
          yield txs[index];
        } else {
          yield txs[index].transaction;
        }
      }

      index++; //reset index and exchange `txs` and `buffer` after count last tx

      if (index === txs.length) {
        index = 0;
        txs = await buffer; // break if can not get more txs

        if (txs.length === 0) {
          break;
        }

        buffer = getTxWithCursor();
      }
    }
  }

}

exports.CKBIndexerTransactionCollector = CKBIndexerTransactionCollector;
//# sourceMappingURL=transaction_collector.js.map