/// <reference types="node" />
import { CellCollector, CellProvider } from "@ckb-lumos/base";
import { EventEmitter } from "events";
import { CKBIndexerQueryOptions, GetCellsResults, IndexerTransactionList, IndexerEmitter, SearchKey, GetTransactionsSearchKey, SearchKeyFilter, Terminator, OtherQueryOptions, TerminableCellFetcher, GetCellsRpc } from "./type";
import type * as IndexerType from "./indexerType";
/** CkbIndexer.collector will not get cell with blockHash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get blockHash if you need. */
export declare class CkbIndexer implements CellProvider, TerminableCellFetcher {
    ckbIndexerUrl: string;
    ckbRpcUrl?: string | undefined;
    static version: string;
    uri: string;
    ckbIndexerUri: string;
    medianTimeEmitters: EventEmitter[];
    emitters: IndexerEmitter[];
    isSubscribeRunning: boolean;
    constructor(ckbIndexerUrl: string, ckbRpcUrl?: string | undefined);
    private getCkbRpc;
    private getIndexerRpc;
    tip(): Promise<IndexerType.Tip>;
    asyncSleep(timeout: number): Promise<void>;
    waitForSync(blockDifference?: number): Promise<void>;
    /** collector cells without blockHash by default.if you need blockHash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl.
     * don't use OtherQueryOption if you don't need blockHash,cause it will slowly your collect.
     */
    collector(queries: CKBIndexerQueryOptions, otherQueryOptions?: OtherQueryOptions): CellCollector;
    getCells(searchKey: SearchKey, terminator?: Terminator, searchKeyFilter?: SearchKeyFilter): Promise<GetCellsResults>;
    getTransactions<Group extends boolean = false>(searchKey: GetTransactionsSearchKey<Group>, searchKeyFilter?: SearchKeyFilter): Promise<IndexerTransactionList<Group>>;
    running(): boolean;
    start(): void;
    startForever(): void;
    stop(): void;
    subscribe(queries: CKBIndexerQueryOptions): EventEmitter;
    private loop;
    private scheduleLoop;
    private poll;
    private publishAppendBlockEvents;
    private filterEvents;
    private checkFilterOptions;
    private checkArgs;
    private emitMedianTimeEvents;
    subscribeMedianTime(): EventEmitter;
}
export declare class TerminableCellAdapter implements TerminableCellFetcher {
    private getCellsableRpc;
    constructor(getCellsableRpc: {
        getCells: GetCellsRpc;
    });
    getCells(searchKey: SearchKey, terminator?: Terminator, searchKeyFilter?: SearchKeyFilter): Promise<GetCellsResults>;
}
//# sourceMappingURL=indexer.d.ts.map