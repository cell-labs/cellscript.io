"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TerminableCellAdapter = exports.CkbIndexer = void 0;

var _base = require("@ckb-lumos/base");

var _services = require("./services");

var _collector = require("./collector");

var _events = require("events");

var _type = require("./type");

var _bi = require("@ckb-lumos/bi");

var _rpc = require("./rpc");

var _rpc2 = require("@ckb-lumos/rpc");

var _toolkit = require("@ckb-lumos/toolkit");

const DefaultTerminator = () => {
  return {
    stop: false,
    push: true
  };
};

function defaultLogger(level, message) {
  console.log(`[${level}] ${message}`);
}
/** CkbIndexer.collector will not get cell with blockHash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get blockHash if you need. */


class CkbIndexer {
  static version = "0.4.1";
  medianTimeEmitters = [];
  emitters = [];
  isSubscribeRunning = false;

  constructor(ckbIndexerUrl, ckbRpcUrl) {
    this.ckbIndexerUrl = ckbIndexerUrl;
    this.ckbRpcUrl = ckbRpcUrl;
    this.uri = ckbRpcUrl || ckbIndexerUrl;
    this.ckbIndexerUri = ckbIndexerUrl;
  }

  getCkbRpc() {
    return new _rpc2.CKBRPC(this.uri);
  }
  /* c8 ignore next 12 */


  getIndexerRpc() {
    if (this.uri === this.ckbIndexerUri) {
      const rpc = this.getCkbRpc();
      return { ...rpc,
        getTip: rpc.getIndexerTip
      };
    }

    return new _rpc.RPC(this.ckbIndexerUri);
  }

  async tip() {
    return await this.getIndexerRpc().getTip();
  }

  asyncSleep(timeout) {
    return new Promise(resolve => setTimeout(resolve, timeout));
  }

  async waitForSync(blockDifference = 0) {
    const rpcTipNumber = parseInt((await this.getCkbRpc().getTipHeader()).number, 16);

    while (true) {
      const indexerTipNumber = parseInt((await this.tip()).blockNumber, 16);

      if (indexerTipNumber + blockDifference >= rpcTipNumber) {
        return;
      }

      await this.asyncSleep(1000);
    }
  }
  /** collector cells without blockHash by default.if you need blockHash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl.
   * don't use OtherQueryOption if you don't need blockHash,cause it will slowly your collect.
   */


  collector(queries, otherQueryOptions) {
    return new _collector.CKBCellCollector(this, queries, otherQueryOptions);
  }

  async getCells(searchKey, terminator = DefaultTerminator, searchKeyFilter = {}) {
    return new TerminableCellAdapter(this.getIndexerRpc()).getCells(searchKey, terminator, searchKeyFilter);
  }

  async getTransactions(searchKey, searchKeyFilter = {}) {
    let infos = [];
    let cursor = searchKeyFilter.lastCursor;
    const sizeLimit = searchKeyFilter.sizeLimit || 100;
    const order = searchKeyFilter.order || "asc";

    while (true) {
      const res = await this.getIndexerRpc().getTransactions(searchKey, order, `0x${sizeLimit.toString(16)}`, cursor);
      const txs = res.objects;
      cursor = res.lastCursor;
      infos = infos.concat(txs);

      if (txs.length <= sizeLimit) {
        break;
      }
    }

    return {
      objects: infos,
      lastCursor: cursor
    };
  }

  running() {
    return true;
  }

  start() {
    defaultLogger("warn", "deprecated: no need to start the ckb-indexer manually");
  }

  startForever() {
    defaultLogger("warn", "deprecated: no need to startForever the ckb-indexer manually");
  }

  stop() {
    defaultLogger("warn", "deprecated: no need to stop the ckb-indexer manually");
  }

  subscribe(queries) {
    this.isSubscribeRunning = true;
    this.scheduleLoop();

    if (queries.lock && queries.type) {
      throw new Error("The notification machanism only supports you subscribing for one script once so far!");
    }

    if (queries.toBlock !== null || queries.skip !== null) {
      defaultLogger("warn", "The passing fields such as toBlock and skip are ignored in subscribe() method.");
    }

    const emitter = new _type.IndexerEmitter();
    emitter.argsLen = queries.argsLen;
    emitter.outputData = queries.data;

    if (queries.fromBlock) {
      _base.utils.assertHexadecimal("fromBlock", queries.fromBlock);
    }

    emitter.fromBlock = !queries.fromBlock ? _bi.BI.from(0) : _bi.BI.from(queries.fromBlock);

    if (queries.lock) {
      _toolkit.validators.ValidateScript(queries.lock);

      emitter.lock = queries.lock;
    } else if (queries.type && queries.type !== "empty") {
      _toolkit.validators.ValidateScript(queries.type);

      emitter.type = queries.type;
    } else {
      throw new Error("Either lock or type script must be provided!");
    }

    this.emitters.push(emitter);
    return emitter;
  }

  loop() {
    if (!this.isSubscribeRunning) {
      return;
    }

    this.poll().then(timeout => {
      this.scheduleLoop(timeout);
    }).catch(e => {
      defaultLogger("error", `Error occurs: ${e} ${e.stack}, stopping indexer!`);
      this.isSubscribeRunning = false;
    });
  }

  scheduleLoop(timeout = 1) {
    setTimeout(() => {
      this.loop();
    }, timeout);
  }

  async poll() {
    let timeout = 1;
    const tip = await this.tip();
    const {
      blockNumber,
      blockHash
    } = tip;

    if (blockNumber === "0x0") {
      const block = await this.getCkbRpc().getBlockByNumber(blockNumber);
      await this.publishAppendBlockEvents(block);
    }

    const nextBlockNumber = _bi.BI.from(blockNumber).add(1);

    const block = await this.getCkbRpc().getBlockByNumber(`0x${nextBlockNumber.toString(16)}`);

    if (block) {
      if (block.header.parentHash === blockHash) {
        await this.publishAppendBlockEvents(block);
      } else {
        const block = await this.getCkbRpc().getBlockByNumber(blockNumber);
        await this.publishAppendBlockEvents(block);
      }
    } else {
      const block = await this.getCkbRpc().getBlockByNumber(blockNumber);
      await this.publishAppendBlockEvents(block);
      timeout = 3 * 1000;
    }

    return timeout;
  }

  async publishAppendBlockEvents(block) {
    for (const [txIndex, tx] of block.transactions.entries()) {
      const blockNumber = block.header.number; // publish changed events if subscribed script exists in previous output cells , skip the cellbase.

      if (txIndex > 0) {
        const requestData = tx.inputs.map((input, index) => {
          return {
            id: index,
            jsonrpc: "2.0",
            method: "get_transaction",
            params: [input.previousOutput.txHash]
          };
        }); // batch request by block

        const transactionResponse = await (0, _services.requestBatch)(this.uri, requestData).then(response => {
          return response.map((item, index) => {
            const cellIndex = tx.inputs[index].previousOutput.index;
            const outputCell = item.result.transaction.outputs[parseInt(cellIndex)];
            const outputData = item.result.transaction.outputsData[parseInt(cellIndex)];
            return {
              output: outputCell,
              outputData
            };
          });
        });
        transactionResponse.forEach(({
          output,
          outputData
        }) => {
          this.filterEvents(output, blockNumber, outputData);
        });
      } // publish changed events if subscribed script exists in output cells.


      for (const [outputIndex, output] of tx.outputs.entries()) {
        const outputData = tx.outputsData[outputIndex];
        this.filterEvents(output, blockNumber, outputData);
      }
    }

    await this.emitMedianTimeEvents();
  }

  filterEvents(output, blockNumber, outputData) {
    for (const emitter of this.emitters) {
      if (emitter.lock !== undefined && this.checkFilterOptions(emitter, blockNumber, outputData, emitter.lock, output.lock)) {
        emitter.emit("changed");
      }
    }

    if (output.type !== null) {
      for (const emitter of this.emitters) {
        if (emitter.type !== undefined && this.checkFilterOptions(emitter, blockNumber, outputData, emitter.type, output.type)) {
          emitter.emit("changed");
        }
      }
    }
  }

  checkFilterOptions(emitter, blockNumber, outputData, emitterScript, script) {
    const checkBlockNumber = emitter.fromBlock ? _bi.BI.from(emitter.fromBlock).lte(blockNumber) : true;
    const checkOutputData = emitter.outputData === "any" || !emitter.outputData ? true : emitter.outputData === outputData;
    const checkScript = !script ? true : emitterScript.codeHash === script.codeHash && emitterScript.hashType === script.hashType && this.checkArgs(emitter.argsLen, emitterScript.args, script.args);
    return checkBlockNumber && checkOutputData && checkScript;
  }

  checkArgs(argsLen, emitterArgs, args) {
    if (argsLen === -1 || !argsLen && argsLen !== 0) {
      return emitterArgs === args;
    } else if (typeof argsLen === "number" && args.length === argsLen * 2 + 2) {
      return args.substring(0, emitterArgs.length) === emitterArgs;
    } else if (argsLen === "any") {
      return args.substring(0, emitterArgs.length) === emitterArgs;
    } else {
      return false;
    }
  }

  async emitMedianTimeEvents() {
    if (this.medianTimeEmitters.length === 0) {
      return;
    }

    const info = await this.getCkbRpc().getBlockchainInfo();
    const medianTime = info.medianTime;

    for (const medianTimeEmitter of this.medianTimeEmitters) {
      medianTimeEmitter.emit("changed", medianTime);
    }
  }

  subscribeMedianTime() {
    this.isSubscribeRunning = true;
    this.scheduleLoop();
    const medianTimeEmitter = new _events.EventEmitter();
    this.medianTimeEmitters.push(medianTimeEmitter);
    return medianTimeEmitter;
  }

}

exports.CkbIndexer = CkbIndexer;

class TerminableCellAdapter {
  constructor(getCellsableRpc) {
    this.getCellsableRpc = getCellsableRpc;
  }

  async getCells(searchKey, terminator = DefaultTerminator, searchKeyFilter = {}) {
    const infos = [];
    let cursor = searchKeyFilter.lastCursor;
    const sizeLimit = searchKeyFilter.sizeLimit || 100;
    const order = searchKeyFilter.order || "asc";
    const index = 0;

    while (true) {
      const res = await this.getCellsableRpc.getCells(searchKey, order, `0x${sizeLimit.toString(16)}`, cursor);
      const liveCells = res.objects;
      cursor = res.lastCursor;

      for (const liveCell of liveCells) {
        const cell = {
          cellOutput: liveCell.output,
          data: liveCell.outputData,
          outPoint: liveCell.outPoint ? liveCell.outPoint : undefined,
          blockNumber: liveCell.blockNumber
        };
        const {
          stop,
          push
        } = terminator(index, cell);

        if (push) {
          infos.push(cell);
        }

        if (stop) {
          return {
            objects: infos,
            lastCursor: cursor
          };
        }
      }

      if (liveCells.length <= sizeLimit) {
        break;
      }
    }

    return {
      objects: infos,
      lastCursor: cursor
    };
  }

}

exports.TerminableCellAdapter = TerminableCellAdapter;
//# sourceMappingURL=indexer.js.map