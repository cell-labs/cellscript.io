"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CKBCellCollector = void 0;

var _base = require("@ckb-lumos/base");

var _toolkit = require("@ckb-lumos/toolkit");

var _services = require("./services");

var _crossFetch = _interopRequireDefault(require("cross-fetch"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** CellCollector will not get cell with blockHash by default, please use OtherQueryOptions.withBlockHash and OtherQueryOptions.CKBRpcUrl to get blockHash if you need. */
class CKBCellCollector {
  constructor(terminableCellFetcher, queries, otherQueryOptions) {
    this.terminableCellFetcher = terminableCellFetcher;
    this.queries = queries;
    this.otherQueryOptions = otherQueryOptions;
    const defaultQuery = {
      lock: undefined,
      type: undefined,
      argsLen: -1,
      data: "any",
      fromBlock: undefined,
      toBlock: undefined,
      order: "asc",
      skip: undefined,
      outputDataLenRange: undefined,
      outputCapacityRange: undefined,
      bufferSize: undefined
    };
    this.queries = { ...defaultQuery,
      ...this.queries
    };
    this.validateQueryOption(this.queries);
    this.convertQueryOptionToSearchKey();
  }

  validateQueryOption(queries) {
    if (!queries.lock && (!queries.type || queries.type === "empty")) {
      throw new Error("Either lock or type script must be provided!");
    }

    if (queries.lock) {
      if (!(0, _services.instanceOfScriptWrapper)(queries.lock)) {
        _toolkit.validators.ValidateScript(queries.lock);
      } else if ((0, _services.instanceOfScriptWrapper)(queries.lock)) {
        _toolkit.validators.ValidateScript(queries.lock.script);
      }
    }

    if (queries.type && queries.type !== "empty") {
      if (typeof queries.type === "object" && !(0, _services.instanceOfScriptWrapper)(queries.type)) {
        _toolkit.validators.ValidateScript(queries.type);
      } else if (typeof queries.type === "object" && (0, _services.instanceOfScriptWrapper)(queries.type)) {
        _toolkit.validators.ValidateScript(queries.type.script);
      }
    }

    if (queries.fromBlock) {
      _base.utils.assertHexadecimal("fromBlock", queries.fromBlock);
    }

    if (queries.toBlock) {
      _base.utils.assertHexadecimal("toBlock", queries.toBlock);
    }

    if (queries.order !== "asc" && queries.order !== "desc") {
      throw new Error("Order must be either asc or desc!");
    }

    if (queries.outputCapacityRange) {
      _base.utils.assertHexadecimal("outputCapacityRange[0]", queries.outputCapacityRange[0]);

      _base.utils.assertHexadecimal("outputCapacityRange[1]", queries.outputCapacityRange[1]);
    }

    if (queries.outputDataLenRange) {
      _base.utils.assertHexadecimal("outputDataLenRange[0]", queries.outputDataLenRange[0]);

      _base.utils.assertHexadecimal("outputDataLenRange[1]", queries.outputDataLenRange[1]);
    }

    if (queries.scriptLenRange) {
      _base.utils.assertHexadecimal("scriptLenRange[0]", queries.scriptLenRange[0]);

      _base.utils.assertHexadecimal("scriptLenRange[1]", queries.scriptLenRange[1]);
    }

    if (queries.outputDataLenRange && queries.data && queries.data !== "any") {
      const dataLen = (0, _services.getHexStringBytes)(queries.data);

      if (dataLen < Number(queries.outputDataLenRange[0]) || dataLen >= Number(queries.outputDataLenRange[1])) {
        throw new Error("data length not match outputDataLenRange");
      }
    }

    if (queries.skip && typeof queries.skip !== "number") {
      throw new Error("skip must be a number!");
    }

    if (queries.bufferSize && typeof queries.bufferSize !== "number") {
      throw new Error("bufferSize must be a number!");
    }
  }

  convertQueryOptionToSearchKey() {
    const queryLock = this.queries.lock; // unWrap `ScriptWrapper` into `Script`.

    if (queryLock) {
      if ((0, _services.instanceOfScriptWrapper)(queryLock)) {
        _toolkit.validators.ValidateScript(queryLock.script);

        this.queries.lock = queryLock.script;
      }
    } // unWrap `ScriptWrapper` into `Script`.


    if (this.queries.type && this.queries.type !== "empty") {
      if (typeof this.queries.type === "object" && (0, _services.instanceOfScriptWrapper)(this.queries.type)) {
        _toolkit.validators.ValidateScript(this.queries.type.script);

        this.queries.type = this.queries.type.script;
      }
    }

    if (!this.queries.outputDataLenRange) {
      if (this.queries.data && this.queries.data !== "any") {
        const dataLenRange = (0, _services.getHexStringBytes)(this.queries.data);
        this.queries.outputDataLenRange = ["0x" + dataLenRange.toString(16), "0x" + (dataLenRange + 1).toString(16)];
      }
    }

    if (!this.queries.scriptLenRange && this.queries.type === "empty") {
      this.queries.scriptLenRange = ["0x0", "0x1"];
    }
  }

  async getLiveCell(lastCursor) {
    const searchKeyFilter = {
      sizeLimit: this.queries.bufferSize,
      order: this.queries.order
    };

    if (lastCursor) {
      searchKeyFilter.lastCursor = lastCursor;
    }

    const result = await this.terminableCellFetcher.getCells((0, _services.generateSearchKey)(this.queries), undefined, searchKeyFilter);
    return result;
  }

  shouldSkipped(cell, skippedCount = 0) {
    if (this.queries.skip && skippedCount < this.queries.skip) {
      return true;
    }

    if (cell && this.queries.type === "empty" && cell.cellOutput.type) {
      return true;
    }

    if (this.queries.data !== "any" && cell.data !== this.queries.data) {
      return true;
    }

    if (this.queries.argsLen !== -1 && this.queries.argsLen !== "any" && (0, _services.getHexStringBytes)(cell.cellOutput.lock.args) !== this.queries.argsLen) {
      return true;
    }
  }

  async count() {
    let lastCursor = undefined;

    const getCellWithCursor = async () => {
      const result = await this.getLiveCell(lastCursor);
      lastCursor = result.lastCursor;
      return result.objects;
    };

    let counter = 0;
    let cells = await getCellWithCursor();

    if (cells.length === 0) {
      return 0;
    }

    let buffer = getCellWithCursor();
    let index = 0;
    let skippedCount = 0;

    while (true) {
      if (!this.shouldSkipped(cells[index], skippedCount)) {
        counter += 1;
      } else {
        skippedCount++;
      }

      index++; //reset index and exchange `cells` and `buffer` after count last cell

      if (index === cells.length) {
        index = 0;
        cells = await buffer; // break if can not get more cells

        if (cells.length === 0) {
          break;
        }

        buffer = getCellWithCursor();
      }
    }

    return counter;
  } // eslint-disable-next-line


  async request(rpcUrl, data) {
    const res = await (0, _crossFetch.default)(rpcUrl, {
      method: "POST",
      body: JSON.stringify(data),
      headers: {
        "Content-Type": "application/json"
      }
    });

    if (res.status !== 200) {
      throw new Error(`indexer request failed with HTTP code ${res.status}`);
    }

    const result = await res.json();

    if (result.error !== undefined) {
      throw new Error(`indexer request rpc failed with error: ${JSON.stringify(result.error)}`);
    }

    return result;
  }

  async getLiveCellWithBlockHash(lastCursor) {
    if (!this.otherQueryOptions) {
      throw new Error("CKB Rpc URL must provide");
    }

    const result = await this.getLiveCell(lastCursor);

    if (result.objects.length === 0) {
      return result;
    }

    const requestData = result.objects.map((cell, index) => {
      return {
        id: index,
        jsonrpc: "2.0",
        method: "get_block_hash",
        params: [cell.blockNumber]
      };
    });
    const blockHashList = await this.request(this.otherQueryOptions.ckbRpcUrl, requestData);
    result.objects = result.objects.map((item, index) => {
      const rpcResponse = blockHashList.find(responseItem => responseItem.id === index);
      const blockHash = rpcResponse && rpcResponse.result;
      return { ...item,
        blockHash
      };
    });
    return result;
  }
  /** collect cells without blockHash by default.if you need blockHash, please add OtherQueryOptions.withBlockHash and OtherQueryOptions.ckbRpcUrl when constructor CellCollect.
   * don't use OtherQueryOption if you don't need blockHash,cause it will slowly your collect.
   */


  async *collect() {
    //TODO: fix return type
    const withBlockHash = this.otherQueryOptions && "withBlockHash" in this.otherQueryOptions && this.otherQueryOptions.withBlockHash;
    let lastCursor = undefined;

    const getCellWithCursor = async () => {
      const result = await (withBlockHash ? this.getLiveCellWithBlockHash(lastCursor) : this.getLiveCell(lastCursor));
      lastCursor = result.lastCursor;
      return result.objects;
    };

    let cells = await getCellWithCursor();

    if (cells.length === 0) {
      return;
    }

    let buffer = getCellWithCursor();
    let index = 0;
    let skippedCount = 0;

    while (true) {
      if (!this.shouldSkipped(cells[index], skippedCount)) {
        yield cells[index];
      } else {
        skippedCount++;
      }

      index++; //reset index and exchange `cells` and `buffer` after yield last cell

      if (index === cells.length) {
        index = 0;
        cells = await buffer; // break if can not get more cells

        if (cells.length === 0) {
          break;
        }

        buffer = getCellWithCursor();
      }
    }
  }

}

exports.CKBCellCollector = CKBCellCollector;
//# sourceMappingURL=collector.js.map