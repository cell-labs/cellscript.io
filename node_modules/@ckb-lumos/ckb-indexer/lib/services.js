"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHexStringBytes = exports.generateSearchKey = void 0;
exports.instanceOfScriptWrapper = instanceOfScriptWrapper;
exports.requestBatch = void 0;

var _base = require("@ckb-lumos/base");

var _crossFetch = _interopRequireDefault(require("cross-fetch"));

var _bi = require("@ckb-lumos/bi");

var _paramsFormatter = require("./paramsFormatter");

var _resultFormatter = require("./resultFormatter");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function instanceOfScriptWrapper(object) {
  return typeof object === "object" && object != null && "script" in object;
}

const UnwrapScriptWrapper = inputScript => {
  if (instanceOfScriptWrapper(inputScript)) {
    return inputScript.script;
  }

  return inputScript;
};

const generateSearchKey = queries => {
  let script = undefined;
  const filter = {};
  let script_type = undefined;

  if (queries.lock) {
    const lock = UnwrapScriptWrapper(queries.lock);
    script = (0, _paramsFormatter.toScript)(lock);
    script_type = "lock";

    if (queries.type && typeof queries.type !== "string") {
      const type = UnwrapScriptWrapper(queries.type);
      filter.script = (0, _paramsFormatter.toScript)(type);
    }
  } else if (queries.type && typeof queries.type !== "string") {
    const type = UnwrapScriptWrapper(queries.type);
    script = (0, _paramsFormatter.toScript)(type);
    script_type = "type";
  }

  let block_range = null;

  if (queries.fromBlock && queries.toBlock) {
    //toBlock+1 cause toBlock need to be included
    block_range = [queries.fromBlock, `0x${_bi.BI.from(queries.toBlock).add(1).toString(16)}`];
  }

  if (block_range) {
    filter.block_range = block_range;
  }

  if (queries.outputDataLenRange) {
    filter.output_data_len_range = queries.outputDataLenRange;
  }

  if (queries.outputCapacityRange) {
    filter.output_capacity_range = queries.outputCapacityRange;
  }

  if (queries.scriptLenRange) {
    filter.script_len_range = queries.scriptLenRange;
  }

  if (!script) {
    throw new Error("Either lock or type script must be provided!");
  }

  if (!script_type) {
    throw new Error("script_type must be provided");
  }

  return (0, _resultFormatter.toSearchKey)({
    script,
    script_type,
    filter
  });
};

exports.generateSearchKey = generateSearchKey;

const getHexStringBytes = hexString => {
  _base.utils.assertHexString("", hexString);

  return Math.ceil(hexString.substr(2).length / 2);
}; // eslint-disable-next-line @typescript-eslint/no-explicit-any


exports.getHexStringBytes = getHexStringBytes;

const requestBatch = async (rpcUrl, data) => {
  const res = await (0, _crossFetch.default)(rpcUrl, {
    method: "POST",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json"
    }
  });

  if (res.status !== 200) {
    throw new Error(`indexer request failed with HTTP code ${res.status}`);
  }

  const result = await res.json();

  if (result.error !== undefined) {
    throw new Error(`indexer request rpc failed with error: ${JSON.stringify(result.error)}`);
  }

  return result;
};

exports.requestBatch = requestBatch;
//# sourceMappingURL=services.js.map